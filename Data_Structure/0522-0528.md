# ç›®å½•
## [æ¦‚å¿µé—®é¢˜](https://github.com/AdorableLake/408_Questions//main/Data_Structure/0522-0528.md#æ¦‚å¿µé—®é¢˜-1)
### [1. çº¿æ€§è¡¨çš„åŸºæœ¬æ“ä½œ](https://github.com/AdorableLake/408_Questions/blob/main/Data_Structure/0522-0528.md#1-çº¿æ€§è¡¨çš„åŸºæœ¬æ“ä½œ-1)
### [2. å•é“¾è¡¨çš„æŒ‰åºåˆ é™¤é—®é¢˜](https://github.com/AdorableLake/408_Questions/blob/main/Data_Structure/0522-0528.md#2-å•é“¾è¡¨çš„æŒ‰åºåˆ é™¤é—®é¢˜-1)
### [3. çº¿æ€§è¡¨æ¦‚å¿µé—®é¢˜](https://github.com/AdorableLake/408_Questions/blob/main/Data_Structure/0522-0528.md#3-çº¿æ€§è¡¨æ¦‚å¿µé—®é¢˜-1)
### [4. å¾ªç¯é“¾è¡¨ä¸å¯¹åº”éå¾ªç¯é“¾è¡¨çš„æ“ä½œå¯¹æ¯”é—®é¢˜](https://github.com/AdorableLake/408_Questions/blob/main/Data_Structure/0522-0528.md#4-å¾ªç¯é“¾è¡¨ä¸å¯¹åº”éå¾ªç¯é“¾è¡¨çš„æ“ä½œå¯¹æ¯”é—®é¢˜-1)

## [ç»¼åˆé—®é¢˜](url)


## æ¦‚å¿µé—®é¢˜

## 1. çº¿æ€§è¡¨çš„åŸºæœ¬æ“ä½œ
```C
//åˆå§‹åŒ–
InitList(&L);
//é”€æ¯
DestroyList(&L);

//æ’å…¥
ListInsert(&L,i,e);
//åˆ é™¤
ListDelete(&L,i,&e);
```
ä¸Šè¿°å››ç§åŸºæœ¬æ“ä½œçš„ `&` ï¼ˆå¼•ç”¨ä¼ å…¥å‚æ•°ï¼‰æ˜¯ C++ ä½¿ç”¨ï¼Œåº”ç”¨åˆ° C è¯­è¨€ä¸Šæ˜¯éœ€è¦è½¬æ¢æˆ `*`ï¼ˆå³ï¼šä½¿ç”¨æŒ‡é’ˆè¡¨è¿°ï¼‰

å®é™…ä½¿ç”¨ä¸­æœ‰ç‚¹è¿·æƒ‘ã€‚

ä¾‹å¦‚ï¼š

```C
#include<stdio.h>
#define MaxSize 10    //å®šä¹‰æœ€å¤§é•¿åº¦
typedef struct  
{
  int data[MaxSize];  //ç”¨é™æ€æ•°ç»„å­˜æ”¾æ•°æ®å…ƒç´ 
  int length;         //é¡ºåºè¡¨çš„å½“å‰é•¿åº¦
}SqList;              //é¡ºåºè¡¨çš„ç±»å‹å®šä¹‰

//åŸºæœ¬æ“ä½œï¼šåˆå§‹åŒ–ä¸€ä¸ªé¡ºåºè¡¨
void InitList(SqList &L)
{
  for(int i=0; i<MaxSize; i++)
  {
    L.data[i]=0;      //å°†æ‰€æœ‰æ•°æ®å…ƒç´ è®¾ç½®ä¸ºé»˜è®¤åˆå§‹å€¼
  }
  L.length=0;         //é¡ºåºè¡¨åˆå§‹é•¿åº¦ä¸º0
}

int main()
{
  SqList L;
  InitList(L);
  //å°è¯•â€œè¿è§„æ‰“å°â€æ•´ä¸ªæ•°ç»„
  for(int i=0; i<MaxSize; i++)
  {
    printf("data[%d]=%d\n",i,L.data[i]);
  }
}
```

### ç–‘é—®ï¼š
ä¸Šè¿°ä¸­çš„

```
void InitList(SqList &L)
```

å±äºå“ªç§è¯­è¨€ï¼Ÿå¯ä»¥ç”¨åœ¨Cè¯­è¨€ç­”é¢˜ä¸Šå—ï¼Ÿ

[è¿”å›é¡µé¦–](https://github.com/AdorableLake/408_Questions/blob/main/Data_Structure/0522-0528.md#ç›®å½•)

## 2. å•é“¾è¡¨çš„æŒ‰åºåˆ é™¤é—®é¢˜

ä¸å¸¦å¤´ç»“ç‚¹çš„æƒ…å†µä¸‹ï¼Œéœ€è¦å¯¹ç¬¬ä¸€ä¸ªå…ƒç´ ç‰¹æ®Šå¤„ç†å—ï¼Ÿ
  
```C
bool ListDelete( LinkList &L, int i, ElemType &e )
{
  if( i<1 )
  {
    return false;
  }
  LNode *p;                   //æŒ‡é’ˆ p æŒ‡å‘å½“å‰æ‰«æåˆ°çš„ç»“ç‚¹
  int j=0;                    //
  p=L;                        // L æŒ‡å‘å¤´ç»“ç‚¹ï¼Œå¤´ç»“ç‚¹æ˜¯ç¬¬0ä¸ªç»“ç‚¹ï¼Œä¸å­˜å‚¨æ•°æ®
  while( p!=NULL && j<i-1 )   //å¾ªç¯æ‰¾åˆ°ç¬¬ i-1 ä¸ªç»“ç‚¹
  {
    p = p -> next;
    j++;
  }
  if( p==NULL )               //å½“ i å€¼ä¸åˆæ³•æ—¶ï¼Œè¿”å›æç¤ºâ€œé”™è¯¯â€ 
  {
    return false;
  }
  if( p ->next==NULL )        //å½“ç¬¬ i-1 ä¸ªç»“ç‚¹æ˜¯æœ€åä¸€ä¸ªç»“ç‚¹æ—¶ï¼Œè¿”å›æç¤ºâ€œé”™è¯¯â€
  {
    return false;
  }
  LNode *q = p->next;         //ä»¤æŒ‡é’ˆ q æŒ‡å‘è¢«åˆ é™¤ç»“ç‚¹
  e = q->next;                //ç”¨æ•°æ®å…ƒç´  e è¿”å›åˆ é™¤å…ƒç´ çš„å€¼
  p->next = q->next;          //å°† *q æ‰€åœ¨ç»“ç‚¹ä»é“¾ä¸­æ–­å¼€
  free(q);                    //ç”¨ free å‡½æ•°é‡Šæ”¾å­˜å‚¨ç©ºé—´
  return true;                //è¿”å›æç¤ºâ€œæ“ä½œæˆåŠŸâ€
}

typedef struct LNode
{
  ElemType data;
  struct LNode *next;
}LNode, *LinkList;
```

ä¸ªäººè®¤ä¸ºä¸éœ€è¦ï¼Œå› ä¸ºi=1æ—¶ï¼Œå¯ä»¥åŒ…å«åœ¨åç»­ `j<i-1` çš„æƒ…å†µé‡Œã€‚

ä½†ä¸çŸ¥é“æ˜¯å¦é€»è¾‘æ­£ç¡®ï¼Ÿ

[è¿”å›é¡µé¦–](https://github.com/AdorableLake/408_Questions/blob/main/Data_Structure/0522-0528.md#ç›®å½•)

## 3. çº¿æ€§è¡¨æ¦‚å¿µé—®é¢˜
çº¿æ€§è¡¨ç« èŠ‚å‡ºç°äº†å½¢å¦‚
```
LNode *p = L->next;
```
çš„ä»£ç ã€‚

### ç–‘æƒ‘
### 3.1. `next`
`*p`åœ¨Cä¸­æœ‰ä¸‰ç§å«ä¹‰ï¼šè¡¨ç¤ºä¹˜æ³•ï¼›è¡¨ç¤ºé—´æ¥è¿ç®—ç¬¦ï¼›è¡¨ç¤ºæŒ‡é’ˆã€‚

è¿™é‡Œçš„è¯æ˜¯è¡¨ç¤ºæŒ‡é’ˆï¼›

è€Œ`L->next`æˆ‘çŸ¥é“`->`ä»£è¡¨çš„æ˜¯æŒ‡å¼•ä½“ç»“æ„ï¼Œé‚£ä¹ˆ`next`æ˜¯éœ€è¦è‡ªå®šä¹‰çš„å‡½æ•°å˜é‡ï¼Œè¿˜æ˜¯åœ¨çº¿æ€§è¡¨å¤´æ–‡ä»¶ä¸­å°±å®šä¹‰å¥½çš„æ•°æ®å…ƒç´ ç»„æˆéƒ¨åˆ†å‘¢ï¼Ÿ

### æ›´æ–°
åœ¨çœ‹åŒé“¾è¡¨çš„æ—¶å€™å‘ç°`*next`æ˜¯åœ¨ç»“æ„ä½“ä¸­å…ˆå‰å®šä¹‰å¥½çš„ï¼Œçœ‹æ ·å­è¿˜æ˜¯è¦åŠæ—¶æ€»ç»“ğŸ˜‚

### 3.2. `L`
å¾ˆå¤šçº¿æ€§è¡¨ç›¸å…³åŸºæœ¬æ“ä½œä¸­ä¼šæœ‰è¿”å›`L`çš„æ“ä½œï¼Œå¦‚

```C
LNode *GetElem(LinkList L, int i)
{
  if(i<0)
  {
    return NULL;
  }
  LNode *p;
  int j=0;
  p = L;
  while( p!=NULL && j<i )
  {
    p=p->next;
    j++;
  }
  return p;
}
```
ä»¥åŠ
```C
LNode *GetElem(LinkList L, int i)
{
  int j=1;
  LNode *p = L->next;
  if(i++0)
  {
    return L;
  }
  else if(i<1)
  {
    return NULL;
  }
  while( p!=NULL && j<i )
  {
    p=p->next;
    j++;
  }
  return p;
}
```
### ç–‘é—®
#### 3.2.1
å…¶ä¸­æˆ‘èƒ½çŸ¥é“ï¼Œç¬¬ä¸€æ®µä»£ç ä¸­çš„`p = L`ï¼Œ`p`æ˜¯é“¾è¡¨ä¸­çš„æŒ‡é’ˆå˜é‡ï¼Œ`L`æ˜¯é“¾è¡¨ã€‚è¿™ä»£è¡¨çš„æ˜¯å°†é“¾è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªæ•°æ®å…ƒç´ èµ‹å€¼ç»™æŒ‡é’ˆçš„æ„æ€å—ï¼Ÿ

### æ›´æ–°
åœ¨åç»­å­¦ä¹ ä¸­ï¼Œå‘ç°äº†åœ¨å®šä¹‰äº†é“¾è¡¨çš„ä»£ç ä¸­ï¼Œåˆå§‹åŒ–çš„éƒ¨åˆ†æœ‰å¯¹`L`çš„å®šä¹‰
```
//å¾ªç¯å•é“¾è¡¨ä¸å•é“¾è¡¨çš„åŒºåˆ«åœ¨äºåˆå§‹åŒ–ä¸­çš„æ­¥éª¤
bool InitList(LinkList &L)
{
  L = (LNode *)malloc(sizeof(LNode));   //ä½¿ç”¨ malloc å‡½æ•°ç”³è¯·ä¸€éƒ¨åˆ†ç©ºé—´ç»™åˆ°å¤´ç»“ç‚¹ L
  if(L==NULL)           //å†…å­˜ä¸è¶³åˆ†é…å¤±è´¥çš„æƒ…å†µ
  {
    return false;
  }
  L->next = L;          //åŒºåˆ«å•é“¾è¡¨ä¸å¾ªç¯å•é“¾è¡¨çš„åœ°æ–¹ï¼Œå¤´ç»“ç‚¹ L çš„ next ä»æŒ‡å‘å¤´ç»“ç‚¹
  return true;
}
//æ‘˜è‡ªå¾ªç¯å•é“¾è¡¨çš„åˆå§‹åŒ–ç¬”è®°
```

#### 3.2.2
ç¬¬äºŒæ®µä»£ç ä¸­`return L`ï¼Œè¿”å›å€¼æ˜¯é“¾è¡¨ä¸­çš„æŸä¸€ä¸ªæ•°æ®å…ƒç´ å—ï¼Ÿ

### æ›´æ–°
åœ¨åç»­å­¦ä¹ ä¸­ï¼Œæ˜ç™½äº†è¿™æ®µä»£ç çš„æ„æ€æ˜¯è¿”å›è¯¥é“¾è¡¨çš„å¤´æŒ‡é’ˆã€‚

[è¿”å›é¡µé¦–](https://github.com/AdorableLake/408_Questions/blob/main/Data_Structure/0522-0528.md#ç›®å½•)

## 4. å¾ªç¯é“¾è¡¨ä¸å¯¹åº”éå¾ªç¯é“¾è¡¨çš„æ“ä½œå¯¹æ¯”é—®é¢˜
### 4.1 å¾ªç¯å•é“¾è¡¨çš„åˆ é™¤ã€æ’å…¥æ“ä½œ
```C
//å•é“¾è¡¨çš„æŒ‰ä½åºåˆ é™¤
bool ListDelete( LinkList &L, int i, ElemType &e )
{
  if( i<1 )
  {
    return false;
  }
  LNode *p;                   //æŒ‡é’ˆ p æŒ‡å‘å½“å‰æ‰«æåˆ°çš„ç»“ç‚¹
  int j=0;                    //
  p=L;                        // L æŒ‡å‘å¤´ç»“ç‚¹ï¼Œå¤´ç»“ç‚¹æ˜¯ç¬¬0ä¸ªç»“ç‚¹ï¼Œä¸å­˜å‚¨æ•°æ®
  while( p!=NULL && j<i-1 )   //å¾ªç¯æ‰¾åˆ°ç¬¬ i-1 ä¸ªç»“ç‚¹
  {
    p = p -> next;
    j++;
  }
  if( p==NULL )               //å½“ i å€¼ä¸åˆæ³•æ—¶ï¼Œè¿”å›æç¤ºâ€œé”™è¯¯â€ 
  {
    return false;
  }
  if( p ->next==NULL )        //å½“ç¬¬ i-1 ä¸ªç»“ç‚¹æ˜¯æœ€åä¸€ä¸ªç»“ç‚¹æ—¶ï¼Œè¿”å›æç¤ºâ€œé”™è¯¯â€
  {
    return false;
  }
  LNode *q = p->next;         //ä»¤æŒ‡é’ˆ q æŒ‡å‘è¢«åˆ é™¤ç»“ç‚¹
  e = q->next;                //ç”¨æ•°æ®å…ƒç´  e è¿”å›åˆ é™¤å…ƒç´ çš„å€¼
  p->next = q->next;          //å°† *q æ‰€åœ¨ç»“ç‚¹ä»é“¾ä¸­æ–­å¼€
  free(q);                    //ç”¨ free å‡½æ•°é‡Šæ”¾å­˜å‚¨ç©ºé—´
  return true;                //è¿”å›æç¤ºâ€œæ“ä½œæˆåŠŸâ€
}
```
```C
//å•é“¾è¡¨çš„æŒ‡å®šç»“ç‚¹åˆ é™¤
bool DeleteNode( LNode *p )
{
  if( p==NULL )
  {
    return false;
  }
  LNode *q = p->next;       //ä»¤ q æŒ‡å‘ *p çš„åç»­ç»“ç‚¹
  p->data = p->next->data;  //å’Œåç»§ç»“ç‚¹äº¤æ¢æ•°æ®åŸŸ
  p->next = q->next;        //å°† *q ç»“ç‚¹ä»é“¾ä¸­æ–­å¼€
  free(q);                  //é‡Šæ”¾åç»§ç»“ç‚¹çš„å­˜å‚¨ç©ºé—´
  return true;
}
```
ä¸Šè¿°ä¸ºå•é“¾è¡¨çš„åˆ é™¤ç»“ç‚¹æ“ä½œ

### ç–‘æƒ‘
å¾ªç¯å•é“¾è¡¨çš„åˆ é™¤ã€æ’å…¥æ“ä½œæ˜¯å¦å’Œå•é“¾è¡¨ä¸€è‡´ï¼Ÿå¦‚æœ‰ä¸åŒï¼Œä¸ç”¨ç‚¹æœ‰å“ªäº›ï¼Ÿæ˜¯å¦éœ€è¦åŒºåˆ†å¤´ç»“ç‚¹çš„æƒ…å†µï¼Ÿ

### 4.2 å¾ªç¯åŒé“¾è¡¨çš„åˆ é™¤ã€æ’å…¥æ“ä½œ 
```C
//åŒé“¾è¡¨çš„åˆ é™¤æ“ä½œ
bool DeleteNextDNode( DNode *p )
{
  if( p==NULL )                 //å¦‚æœ p ä¸ºç©ºæŒ‡é’ˆï¼Œå³ä¸ºåˆ¤ç©ºæ“ä½œ
  {
    return false;
  }
  DNode *q = p->next;           //å®šä¹‰ q ä¸º p çš„åç»§ç»“ç‚¹
  if( q==NULL )                 //å¦‚æœ p ä¸ºæœ€åä¸€ä¸ªç»“ç‚¹
  {
    return false;
  }
  p->next = q->next;            
  if( q->next != NULL )         // q ä¸æ˜¯æœ€åä¸€ä¸ªç»“ç‚¹
  {
    q->next->prior = q;         //å°† q çš„åç»§ç»“ç‚¹æŒ‡å‘å‰é©±èŠ‚ç‚¹ï¼Œå¹¶æŒ‡å‘ q æ‰€ä»£è¡¨çš„æ•°æ®å…ƒç´ 
  }
  free(q);                      //é‡Šæ”¾ q
  return true;
}
```

```C
//åŒé“¾è¡¨çš„åæ’æ“ä½œ
bool InsertNextDNode(DNode *p, DNode *s)
{
  if( p==NULL || s==NULL )
  {
    return false;
  }
  
  //ä»¥ä¸‹å‡ è¡Œä¸ºæ ¸å¿ƒä»£ç 
  s->next = p->next;      //ä»¤ s çš„åç»§ç»“ç‚¹ä¸ p çš„åç»§ç»“ç‚¹ç›¸ç­‰
  if(p->next != NULL)     //æ¡ä»¶åˆ¤æ–­ p ç»“ç‚¹åæ˜¯å¦æœ‰åç»§ç»“ç‚¹
  {
    p->next->prior = s;
  }
  s->prior = p;
  p->next = s;
  
  return true;
}
```
### ç–‘æƒ‘
åŒé“¾è¡¨åœ¨æ‰§è¡Œåˆ é™¤ã€æ’å…¥æ“ä½œæ—¶ï¼Œéœ€è¦å¯¹è¾¹ç•Œæƒ…å†µè¿›è¡Œåˆ¤å®šï¼›

è€Œå¾ªç¯åŒé“¾è¡¨ç”±äºè¡¨å°¾å•å…ƒçš„åç»§ç»“ç‚¹æŒ‡å‘å¤´ç»“ç‚¹ï¼Œå¤´ç»“ç‚¹çš„å‰é©±èŠ‚ç‚¹æŒ‡å‘è¡¨å°¾å•å…ƒï¼Œå› æ­¤åœ¨å¯¹å…¶æ‰§è¡Œåˆ é™¤ã€æ’å…¥ç­‰æ“ä½œæ—¶ï¼Œæ˜¯å¦æ˜¯ä¸éœ€è¦ç±»ä¼¼çš„åˆ¤æ–­æ¡ä»¶ï¼Ÿ

å³ï¼šä¸‹é¢ä»£ç æ˜¯å¦æ­£ç¡®ï¼Ÿ
```C
//åœ¨ p ç»“ç‚¹ä¹‹åæ’å…¥ s ç»“ç‚¹ï¼ˆåæ’æ“ä½œï¼‰
bool InsertNextDNode(DNode *p, DNode *s)
{
  s->next = p->next;      //å°† *s æ’å…¥åˆ°ç»“ç‚¹ *p ä¹‹å    
  p->next->prior = s;
  s->prior = p;
  p->next = s;
  return true;
}

//å¾ªç¯åŒé“¾è¡¨çš„åˆ é™¤æ“ä½œ
bool DeleteNextDNode(DNode *p)
{
  p->next = q->next;
  q->next->prior = p;
  free(q);
  return true;
}
```

[è¿”å›é¡µé¦–](https://github.com/AdorableLake/408_Questions/blob/main/Data_Structure/0522-0528.md#ç›®å½•)
