# Chapter 2: LinkList

01. 在双链表中向 p 所指的结点之前插入一个结点 q 的操作为（ ）

```C
A. 
p->prior=q;
// 错误点：已经把p结点之前的结覆盖成了q;
q->next=p; 
p->prior->next=q; 
// p->prior->next=q;
q->prior=p->prior;

B. 
q->prior=p->prior;
p->prior->next=q;
q->next=p;
p->prior=q->next;

C.
q->next->next=q;
q->next=p;
q->prior->next=q;
q->next=p;

D.
p->prior->next=q;
q->next=p;
q->prior=p->prior;
p->prior=q;

// 插入操作中：不断赋值
// 原则：有用的结点不能被覆盖
```

02. 在双项链表存储结构中，删除 p 所指的结点时必须修改指针（ ）

```C
A.
p->llink->rlink=p->rlink;
p->rlink->llink=p->llink;

B.
p->llink=p->llink->llink;
p->llink->rlink=p;

C.
p->rlink->llink=p;
p->rlink=p->rlink->rlink=p;

D.
p->rlink=p->llink->llink;
p->llink=p->rlink->rlink;

// 直接将左右结点链接即可
```

03. 在长度为 n 的有序单链表中插入一个新结点，并仍然保持有序的时间复杂度是（ ）

```
A. O(1) 
B. O(n) 
C. O(n^2)   
D. O(nlog2n)

// O(n)=O(n)+O(1) (访问+插入)
```

04. 一个链表最常用的操作是在末尾插入结点和删除结点，则选用（ ）最节省时间

```
A. 带头结点的双循环链表 // ==> O(1)/插入 O(1)/删除
B. 单循环链表 // ==> O(n)/插入 O(n)/删除
C. 带尾指针的单循环链表 // ==> O(1)/插入 O(n)/删除
D. 单链表 // ==> O(n)/插入 O(n)
```

05. 设对 n （n>1）个元素的线性表的运算只有4种：删除第一个元素；删除最后一个元素；在第一个元素之前插入新元素；在最后一个元素之后插入新元素，则最好使用（ ）

```
A. 只有尾结点指针没有头结点指针的循环单链表
B. 只有尾结点指针没有头结点指针的非循环双链表
C. 只有头结点指针没有尾结点指针的循环双链表
D. 既有尾结点指针又有头结点指针的循环单链表
```

# Chapter 3: Stack

01. 设链表不带头结点且所有操作均在表头进行，则下列最不适合作为链栈的是（ ）

```
A. 只有表头结点指针，没有表尾指针的双向循环链表
B. 只有表尾结点指针，没有表头指针的双向循环链表
C. 只有表头结点指针，没有表尾指针的单向循环链表
D. 只有表尾结点指针，没有表头指针的单向循环链表
```

02. 链栈（不带头结点）执行 Pop 操作，并将出栈的元素存在 x 中，则执行（ ）

```
A. 
x=top;
top=top->next;

B.
x=top->data;

C. 
top=top->next;
x=top->data;

D.
x=top->data;
top=top->next;
```

03. 经过以下栈的操作后，变量 x 的值为（ ）

```C
InitStack(st);
Push(st, a);
Push(st, b);
Pop(st, x);
Top(st, x);

A. a    
B. b    
C. NULL 
D. FALSE
```

✅04. 「2013真题」 一个栈的入栈序列为1，2，3，···，n，出栈序列是P1，P2，P3，···，Pn。若P2=3，则P3可能取值的个数是（ ）

```
A. n-3
B. n-2
C. n-1
D. 无法确定
```

✅05. 已知循环队列的存储空间为数组 A[21]，front 指向队头元素的前一个位置，rear 指向队尾元素，假设当前 front 和 rear 的值分别为 8 和 3，则该队列的长度为（ ）

```
A. 5
B. 6
C. 16
D. 17
```

✅06. 假设一个循环队列 Q[MaxSize] 的队列头指针为 front，队尾指针为 rear，队列的最大容量为 MaxSize，此外，该队列再没有其他数据成员，则判断该对的列满条件为（ ）

```C
A. Q.front==Q.rear;
B. Q.front+Q.rear>=MaxSize;
C. Q.front==(Q.rear+1)%MaxSize;
D. Q.rear=(Q.front+1)%MaxSize
```

07. 最适合用作链队的链表是（ ）

```
A. 带队首指针和队尾指针的循环单链表
B. 带队首指针和队尾指针的非循环单链表
C. 只带队首指针的非循环单链表
D. 只带队首指针的循环单链表
```

08. 用链式存储方式的队列进行删除操作时需要（ ）

```
A. 仅修改头指针
B. 仅修改尾指针
C. 头尾指针都要修改
D. 头尾指针可能都要修改
```

09. 在一个链队列中，假设队头指针为 front，队尾指针 rear，x 所指向的元素需要入队，则需要执行的操作为（ ）

```
A. front=x, front=front->next
B. x->next=front->next, front=x
C. rear->next=x, rear=x
D. rear->next=x, x->next=null, rear=x
```

✅10. 「2012真题」已知操作符包括 `+、-、*、/、（、）`。将中缀表达式 `a+b-a*((c+d)/e-f)+g` 转换为等价的后缀表达式 `ab+acd+e/f-*-g+` 时，用栈来存放暂时还不能确定运算次序的操作符，栈初始时为空时，转换过程中同时保存在栈中的操作符的最大个数是（ ）

```
A. 5
B. 7
C. 8
D. 11
```

✅11. 「2014真题」假设栈初始为空，将中缀表达式 `a/b+(c*d-e*f)/g` 转换为等价的后缀表达式的过程中，当扫描到 f 时，栈中的元素依次是（ ）

```
A. +(*-
B. +(-*
C. /+(*-*
D. /+-*
```

✅12. 若将 n 阶上三角矩阵 A 按列优先级压缩存放在一维数组 `B[1...n(n+1)/2+1]` 中，则存放到 `B[k]` 中的非零元素 `ai,j (1=<i,j=<n)` 的下标 i、j 与 k 的对应关系是（ ）

```
A. i(i+1)/2+j
B. i(i-1)/2+j-1
C. j(j-1)/2+i
D. j(j-1)/2+i-1

// 分成 S1 = 前(j-1)列的元素和; S2 = 第(j)列的元素
```

✅13. 若将 n 阶下三角矩阵 A 按列优先顺序压缩存放在一维数组 `B[1...n(n+1)/2+1]` 中，则存放到 `B[k]` 中的非零元素 `ai,j (1=<i,j=<n)` 的下标 i、j 与 k 的对应关系是（ ）

```
A. (j-1)*(2n-j+1)/2+i-j
B. (j-1)*(2n-j+2)/2+i-j+1
C. (j-1)*(2n-j+2)/2+i-j
D. (j-1)*(2n-j+1)/2+i-j-1

// 分成 S1 = 前(j-1)列的元素和; S2 = 第(j)列的元素
```
12、13对比

# Chapter 4: String

✅01. 「2015真题」已知字符串 S 为 'abaabaabacacaabaabcc'，模式串 t 为 'abaabc' 。采用 KMP 算法进行匹配，第一次出现“失配”（`s[i]!=t[j]`）时，i=j=5，则下次开始匹配时，i、j分别是（ ）

```
A. i=1, j=0
B. i=5, j=0
C. i=5, j=2
D. i=6, j=2
```

✅02. 「2019真题」设主串 T='abaabaabcabaabc'，模式串 S='abaabc'，采用 KMP 算法进行模式匹配，到匹配成功为止，在匹配过程中进行的单个字符间的比较次数是（ ）

```
// 6+4
A. 9
B. 10
C. 12
D. 15
```

# Chapter 5: Tree
✅01. 对于一棵具有 n 个结点、度为4的树来说，（ ）

```
A. 树的高度至多是 n-3
B. 树的高度至多是 n-4
C. 第 i 层上至多有 4*(i-1)
D. 至少在某一层上正好有 4 个结点
```

✅02. 假定一棵度为3的树中，结点数为50，则其最小高度为（ ）

```
A. 3
B. 4
C. 5
D. 6
```

✅03. 「2020真题」对于任意一棵高度为 5 且有 10 个结点的二叉树，若采用顺序存储结构进行保存，每个结点占 1 个存储单元（仅存放结点的数据信息），则存放该二叉树需要的存储单元数量至少是（ ）

```
// 所以二叉树的顺序存储结构使用满二叉树能够满足任意性？

A. 31
B. 16
C. 15
D. 10
```

✅04. 在下列关于二叉树遍历的说法中，正确的是（ ）

```
A. 若有一个结点是二叉树中某个子树的中序遍历结果序列的最后一个结点，则它一定是该子树的前序遍历结果序列的最后一个结点
B. 若有一个结点是二叉树中某个子树的前序遍历结果序列的最后一个结点，则它一定是该子树的中序遍历结果序列的最后一个结点
C. 若有一个叶子结点是二叉树中某个子树的中序遍历结果序列的最后一个结点，则它一定是该子树的前序遍历结果序列的最后一个结点
D. 若有一个叶子结点是二叉树中某个子树的前序遍历结果序列的最后一个结点，则它一定是该子树的中序遍历结果序列的最后一个结点
```

❌05. 在二叉树中有两个结点 m 和 n，若 m 是 n 的祖先，则使用（ ）可以找到从 m 到 n 的路径

```
A. 先序遍历
B. 中序遍历
C. 后序遍历
D. 层次遍历
```

✅06. 一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则改二叉树一定满足（ ）

```
// 错选为A
// 排除法

A. 所有的结点均无左孩子
B. 所有的结点均无右孩子
C. 只有一个叶结点
D. 是任意一棵二叉树
```

⭕️07. 一棵二叉树的前序遍历序列为 1234567，它的中序遍历序列可能是（ ）

```
A. 3124567
B. 1234567
C. 4135627
D. 1463572
```

✅08. 一棵左子树为空的二叉树在先序线索化后，其中空的链域个数是（ ）

```
// 不理解

// 所有线索化后的二叉树，其最前结点的左链域、最后结点的右链域均为空

A. 不确定
B. 0个
C. 1个
D. 2个
```

⭕️09. 「2012真题」若一棵二叉树的前序遍历序列为 a,e,b,d,c，后序遍历序列为 b,c,d,e,a，则跟结点的孩子结点是（ ）

```
A. e
B. e,b
C. e,c
D. 无法确定
```

✅10. 「2015真题」先序序列为 a,b,c,d 的不同二叉树个数是（ ）

```
// 利用数学归纳法

// (2n)!/(n+1)*n!*(2n-n)!, n=4

A. 13
B. 14
C. 15
D. 16
```
