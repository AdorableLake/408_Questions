# Catalog | 目录
## [Chapter 1](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#chapter-1-conception)
[1.2.6](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#126-level-structure--层次结构简述)

[1.3.3 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#133-performance--性能指标)

## [Chapter 2](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#chapter-2-data)
[2.1.5 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#215-code--numeral-system-编码与数制)

[2.2.7 解析看到 24](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#227-calculation--运算方法)

[2.3.3 解析未看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#233-calculation-of-float--浮点数的计算)

## [Chapter 3](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#chapter-3-storage)
[3.1.4 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#314-storage-level--存储结构)

[3.2.5 解析未看完](url)

# Chapter 1: Conception
## 1.2.6 Level Structure | 层次结构简述
02.  冯·诺依曼机的基本工作方式是（ ）

```
A. 控制流驱动方式
B. 多指令多数据流方式
C. 微程序控制方式
D. 数据流驱动方式
```

03. 下列（ ）是冯·诺依曼机工作方式的基本特点。

```
A. 多指令流单数据流
B. 按地址访问并顺序执行指令
C. 堆栈操作
D. 存储器按内容选择地址
```

04. 以下说法错误的是（ ）

```
A. 硬盘是外部设备
B. 软件的功能与硬件的功能在逻辑上是等效的
C. 硬件实现的功能一般比软件实现具有更高的执行速度
D. 软件的功能不能用硬件取代
```

05. 存放欲执行指令的寄存器是（ ）

```
A. MAR  // 地址寄存器
B. PC   // 程序计数器
C. MDR  // 数据寄存器
D. IR   // 指令寄存器
```

09. 在运算器中，不包含（ ）

```
A. 状态寄存器
B. 数据总线
C. ALU
D. 地址寄存器
```

10. 下列关于 CPU 存取速度的比较中，正确的是（ ）

```
A. Cache > 内存 > 寄存器
B. Cache > 寄存器 > 内存
C. 寄存器 > Cache > 内存
D. 寄存器 > 内存 > Cache
```

14. 关于编译程序和解释程序，下列说法中错误的是（ ）

```
// 解释语言：翻译一条语句立即执行一条语句 ==> 效率低
// 编译语言：翻译完全部语句再执行全部语句 ==> 效率高

A. 编译程序和解释程序的作用都是高级语言转换成机器语言程序
B. 编译程序编译时间较长，运行速度较快
C. 解释程序方法较简单，运行速度也快
D. 解释程序将源程序翻译成机器语言，并且翻译一条以后，立即执行这条语句
```

17. 下列叙述中，正确的是（ ）

```
I.   实际应用程序的测试结果能够全面代表计算机的性能
II.  系列机的基本特性是指令系统向后兼容
III. 软件和硬件在逻辑功能上是等价的

// I.   ==> 很显然错误
// II.  ==> 系列机：具有相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列
// III. ==> 根据冯·诺依曼机的原理，软件和硬件在逻辑上是等效的

A. II
B. III
C. II,III
D. I,II,III
```

20. 关于相联存储器，下列说法中正确的是（ ）

```
A. 只可以按地址寻址
B. 只可以按内容寻址
C. 即可按地址寻址又可按内容寻址
D. 以上说法均不完善
```

22. 「2009真题」冯·诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU 区分它们的依据是（ ）

```
A. 指令操作码的译码结果
B. 指令和数据的寻址方式
C. 指令周期的不同阶段
D. 指令和数据所在的存储单元
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 1.3.3 Performance | 性能指标
❓02. 存储字长是指（ ）

```
A. 存放在一个存储单元中的二进制代码组合
B. 存放在一个存储单元中的二进制代码位数
C. 存储单元的个数
D. 机器指令的位数
```

```
机器字长：计算机位数，即计算机一次能处理的二进制数的长度，为处理整数运算的部件的部件
指令字长：一个指令字中包含的二进制代码位数
存储字长：等于MDR位数
```

❓04. 下列关于机器字长、指令字长和存储字长的说法中，正确的是（ ）

```
I.   三者在数值上总是相等的
II.  三者在数值上可能不等
III. 存储字长是存放在一个存储单元中的二进制代码位数
IV.  数据字长是 MDR 的位数

A. I,III 
B. I,IV
C. II,III
D. II,IV
```

✅05. 32 位微机是指该计算机所用 CPU（ ）

```
A. 具有 32 位寄存器
B. 能同时处理 32 位的二进制数
C. 具有 32 个寄存器
D. 能处理 32 个字符
```

```
机器字长等于32位 => 能同时处理 32 位的二进制数
```

❓10. 计算机中，CPU 的 CPI 与下列（ ）因素无关

```
A. 时钟频率
B. 系统结构
C. 指令集
D. 计算机组织
```

```
CPI 与系统结构、指令集、计算机组织有关，但与时钟频率无关
```

✅14. 下列说法中，正确的是（ ）

```
I.   在微型计算机的广泛应用中，会计电算化属于科学计算方面的应用
II.  决定计算机计算精度的主要技术是计算机字长
III. 计算机 “运算速度” 指标的含义是每秒能执行多少条操作系统的命令
IV.  利用大规模集成电路技术把计算机的运算部件和控制部件做在一块集成电路芯片上，这样的一块芯片称为单片机

A. I,III
B. II,IV
C. II
D. I,III,IV
```

```
I.   => 属于数据处理方面，即应用方面
II.  => 对的
III. => 运算速度是每秒能执行多少条指令
IV.  => 这玩意被称为 CPU（运算部件和控制部件）
```

✅20. 「2017真题」假定计算机 M1 和 M2 具有相同的指令集体系结构（ISA），主频分别为 1.5Ghz 和 1.2GHz。在 M1 和 M2 上运行某基准程序 P，平均 CPI 分别为 2 和 1，则程序 P 在 M1 和 M2 上运行时间的比值是（ ）

```
A. 0.4
B. 0.625
C. 1.6
D. 2.5
```

```
运行时间 = 指令数 * CPI / 主频

比值 = （M1 时间=指令数*2/1.5）/（指令数*1/1.2）=（2/1.5）/（1/1.2） = 1.6
```

✅21. 「2020真题」下列给出的部件中，其位数（宽度）一定与机器字长相同的是（ ）

```
I.   ALU
II.  指令寄存器
III. 通用寄存器
IV.  浮点寄存器

A. I,II
B. I,III
C. II,III
D. II,III,IV
```

```
机器字长：CPU 内部用于整数运算的数据通路的宽度

用于整数运算的部件：ALU，通用寄存器
```

✅22. 「2021真题」2017年公布的全球超级计算机 TOP 500 排名中，我国 “神威·太湖之光” 超级计算机蝉联第一，其浮点运算速度为 93.0146 PFLOPS，说明该计算机每秒钟内完成的浮点操作次数约为（ ）

```
A. 9.3*10^13
B. 9.3*10^15
C. 9.3 千万亿次
D. 9.3 亿亿次
```

```
这题就离谱，为啥前面用幂后面用汉字

10^13 == 十万亿
10^15 == 千万亿
10^16 == 亿亿
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

# Chapter 2: Data
## 2.1.5 Code & Numeral System| 编码与数制
✅01. 下列各种数制的数中，最小的数是（ ）

```
A. (101001)2
B. (101001)BCD
C. (52)8
D. (233)16
```

```
A. (101001)2 = 29H
B. (101001)BCD = 29D
C. (52)8 = 2AH

*BCD 码现在不考了
```

❓14. 对于关于补码和移码关系的叙述中，（ ）是不正确的

```
A. 相同位数的补码和移码表示具有相同的数据表示范围
B. 零的补码和移码表示相同
C. 同一个数的补码和移码表示，其数值部分相同，而符号相反
D. 一般用移码表示浮点数的阶，而补码表示定点整数
```

```
以5位机器字长为例：
[0]补 = 00000 != [0]移 = 2^4 + 0 = 10000
```

❓15. 若[x]补 = 1, x1 x2 x3 x4 x5 x6，其中 xi 取 0 或 1，若要 x > -32，应当满足（ ）

```
A. x1 为 0，其他各位任意
B. x1 为 1，其他各位任意
C. x1 为 1，x2～x6 中至少有一位为 1
D. x1 为 0，x2～x6 中至少有一位为 1
```

```
补码转原码（负数）：符号位不变，数值位全部取反，末位加1
故 x1 一定为 1（取反后是0）
（那么如果 [x]原 = 10000000 呢？）
使用补码表示时，符号位相同的情况下，数值位越大，码值也越大
```

❓16. 设 x 为整数，[x]补 = 1, x1 x2 x3 x4 x5，若要 x < -16，x1～x5 应满足（ ）

```
// 同15

A. x1~x5 至少有一个为 1
B. x1 必须为 0，x2~x5 至少有一个为 1
C. x1 必须为 0，x2～x5 任意
D. x1 必须为 1，x2～x5 任意
```

✅17. 设 x 为真值，x* 为其绝对值，满足 [-x*]补 = [-x]补，当且仅当（ ）

```
// 冷知识：0 不是正数，也不是负数

A. x 任意 
B. x 为正数
C. x 为负数
D. 以上说法都不对
```

❓23. 若寄存器内容为 00000000，若它等于 -128，则为（ ）

```
A. 原码
B. 补码
C. 反码
D. 移码
```

```
寄存器长度为 8，[-128]移 = 2^7+(10000000) = 00000000
```

❓25. 下列为 8 位移码机器数 [x]移，求 [-x]移时，（ ）会发生溢出

```
A. 11111111
B. 00000000
C. 10000000
D. 01111111
```

```
B => -128, -(-128)=128 => 溢出
```

✅27. 在计算机中，通常用来表示主存地址的是（ ）

```
A. 移码
B. 补码
C. 原码
D. 无符号数
```

```
主存地址均为正数，因此采用无符号整数即可
```

✅30. 「2021真题」已知带符号整数用补码表示，变量 x,y,z 的机器数分别为 FFFDH,FFDFH,7FFCH，下列结论中，正确的是（ ）

```
A. 若 x,y,z 为无符号整数，则 z<x<y
B. 若 x,y,z 为无符号整数，则 x<y<z
C. 若 x,y,z 为带符号整数，则 x<y<z
D. 若 x,y,z 为带符号整数，则 y<x<z
```

```
若 x,y,z 为无符号整数，则 x>y>z （因为均是正数）
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 2.2.7 Calculation | 运算方法
✅04. 加法器中每位的进位生成信号 g 为（ ）

```
A. Xi xor Yi 
B. Xi*Yi
C. Xi*Yi*Ci
D. Xi+Yi+Ci
```

```
多位加法器为了加快运算速度而采用了快速进位链，其中包含两个信号：
1. 进位信号 g = Xi*Yi 
2. 进位传递信号 p = Xi xor Yi
```

❓10. 一个 8 位寄存器内的数值为 11001010，进位标志寄存器 C 为 0，若将此 8 位寄存器循环左移（不带进位位）1 位，则该 8 位寄存器和标志寄存器内的数值分别为（ ）

```
A. 1001 0100, 1
B. 1001 0101, 0
C. 1001 0101, 1
D. 1001 0100, 0
```

```
不带进位位的循环左移将最高位进入最低位和标志寄存器 CF 位

*还是不太明白
```

✅13. 16 位补码 0x8FA0 扩展为 32 位应该是（ ）

```
A. 0x0000 8FA0
B. 0xFFFF 8FA0
C. 0xFFFF FFA0
D. 0x8000 8FA0
```

```
16 位扩展为32位，符号位不变，附加位是符号位的扩展。
8FA0 是一个负数，因此附加位均用 1 填补附加位。
```

❓15. 关于模 4 补码，下列说法正确的是（ ）

```
A. 模 4 补码和模 2 补码不同，它更容易检查乘除运算中的溢出问题
B. 每个模 4 补码存储时只需一个符号位
C. 存储每个模 4 补码需要两个符号位
D. 模 4 补码，在算数与逻辑部件中为一个符号位
```

```
1. 模 4 补码
2. 模 2 补码

A：❌ 模 4 补码拥有模 2 补码的全部优点，并且更易检查加减运算中的溢出问题
B：✅ 存储模 4 补码仅需一个符号位，任意正确的数值，其模 4 补码的两个符号位都相同
C：❌ 理由同上
D：❌ 只有在 ALU 中进行运算中才会采用双符号位
```

✅17. 判断加减法溢出时，可采用判断进位的方式，若符号位的进位为 C0，最高位的进位为 C1，则产生溢出的条件是（ ）

```
I.   C0 产生进
II.  C1 产生进位
III. C0、C1 都产生进位
IV.  C0、C1 都不产生进位
V.   C0 产生进位，C1 不产生进位
VI.  C0 不产生进位，C1 产生进位

A. I,II
B. III
C. IV
D. V,VI
```

```
采用进位位来判断溢出时，当最高有效位进位和符号位进位的值不同的时候才产生溢出
1. 正溢出：两个正数相加，当最高有效位产生进位（即：C1 = 1），而符号位不产生进位（即：C0 = 0）
2. 负溢出：两个负数相加，最高有效位不产生进位（即：C1 = 0），而符号位产生进位（即：C0 = 1）
```

✅19. 若 [X]补 = X0.X1X2...Xn，其中 X0 为符号位，X1 为最高数位。若（ ），则当补码左移时，将会发生溢出

```
A. X0 = X1
B. X0 != X1
C. X1 = 0
D. X1 = 1
```

```
溢出判别法适用此种情况：
1. 符号位：由单符号位变成双符号位，然后左移，若两符号位不同则溢出，即 X0 != X1 时溢出；
2. 数值位：最高位进位和符号位进位不同导致溢出，此时 X1 != X0；
综上可知：X1 != X0 会在左移后导致溢出
```

❓22. 在原码一位乘法中，（ ）

```
A. 符号位参加运算
B. 符号位不参加运算
C. 符号位参加运算，并根据运算结果改变结果中的符号位
D. 符号位不参加运算，并根据运算结果确定结果中的符号·
```

```
在原码一位乘法中，符号位不参与运算，且单独处理，同号为正，异号为负
（那为啥 D 不对？）
```

✅24. 实现 N 位（不包括符号位）补码一位乘时，乘积为（ ）位

```
A. N
B. N+1
C. 2N
D. 2N+1
```

```
补码一位乘法运算过程中，一共向右移位 N 次，加上原先的 N 位，一共是 2N 位的数值位，又乘积结果需加上一位符号位，因此为 2N+1 位
```

✅25. 在原码不恢复余数法（又称原码加减交替法）的算法中，（ ）

```
A. 每步操作后，若不够减，则需恢复余数
B. 若为负商，则恢复余数
C. 整个算法过程中，从不恢复余数
D. 仅当最后一不够减时，才恢复一次余数
```

```
原码不恢复余数法中，只在最终余数为负时，才需要恢复余数
```

✅26. 下列关于补码除法的说法中，正确的是（ ）

```
A. 补码不恢复除法中，够减商 0，不够减商 1
B. 补码不恢复余数除法中，异号相除时，够减商 0，不够减商 1
C. 补码不恢复除法中，够减商 1，不够减商 0
D. 以上都不对
```

```
补码不恢复余数法中，异号相除时看够不够减，够减商0，不够减商1
```

❓27. 下列关于各种移位的说法正确的是（ ）

```
I.   假设机器数采用反码表示，当机器数为负时，左移时最高数位丢 0，结果出错；右移时最低数位丢 0，影响精度
II.  在算数移位的情况下，补码左移的前提条件是其原最高有效位与原符号位要相同
III. 在算数移位的情况下，双符号位的移位操作只有低符号位需要参加移位操作

A. I,III
B. II
C. III
D. I,II,III
```

```
I.   => 负数的反码的数值位与其原码相反
II.  => 补码表示时，正数符号位为 0，左移最高位为 0时，数据不会丢失；负数符号位为 1，左移最高位为 1时，数据不会丢失
III. => 双符号位表示时，只有最高符号位表示真正的符号，低符号位用于参与移位操作以判断是否发生溢出，如 01 表示正溢出，10 表示负溢出
```

❓29. 某计算机字长为 8 位，CPU 中有一个 8 位加法器。已知无符号数 x = 69，y = 38，如果在该加法器中计算 x-y，则加法器的两个输入端信息和输入的低位进位信息分别为（ ）

```
A. 0100 0101, 0010 0110, 0
B. 0100 0101, 1101 1001, 1
C. 0100 0101, 1101 1010, 0
D. 0100 0101, 1101 1010, 1
```

```
[x]补 = 0100 0101, [y]补 = 0010 0110, [-y]原 = 1010 0110, [-y]补 = 1101 1010
```

31. 某 8 位计算机中，x 和 y 是两个带符号整数，用补码表示，[x]补 = 44H，[y]补 = DCH，则 x/2 + 2y 的机器数及相应的溢出标志 OF 分别是（ ）

```
A. CAH,0
B. CAH,1
C. DAH,0
D. DAH,1
```

34. 「2012真题」某计算机存储器按字节编址，采用小端方式存放数据。假定编译器规定 int 和 short 型长度分别为 32 位和 16 位，并且数据按边界对齐存储。某 C 语言程序段如下：

```C
struct {
    int a;
    char b;
    short c;
} record;
record.a = 273;
```

若 record 变量的首地址为 0xC008，地址 0xC008 中的内容及 record.c 的地址分别为（ ）。

```
A. 0x00,0xC00D
B. 0x00,0xC00E
C. 0x11,0xC00D
D. 0x11,0xC00E
```

35. 「2012真题」假定编译器规定 int 和 short 类型长度分别为 32 位和 16 位，执行下列 C 语言语句（ ）

```C
unsigned short x=65530;
unsigned int y=x;
```

```
A. 0000 7FFAH
B. 0000 FFFAH
C. FFFF 7FFAH
D. FFFF FFFAH
```

36. 「2013真题」某字长为 8 位的计算机中，已知整型变量 x、y 的机器数分别为 [x]补 = 1 1110100, [y]补 = 1 0110000。若整型变量 z = 2x + y/2，则 z 的机器数为（ ）

```
A. 1 1000000
B. 0 0100100
C. 1 0101010
D. 溢出
```

38. 「2016真题」有如下 C 语言程序段

```C
short si = -32767;
unsigned short usi = si;
```

执行上述两条语句后，usi 的值为

```
A. -32767
B. 32767
C. 32768
D. 32769
```

41. 「2018真题」整数 x 的机器数为 1101 1000，分别对 x 进行逻辑右移 1 位和算数右移 1 位操作，得到的机器数各是（ ）

```
A. 1110 1100, 1110 1100
B. 0110 1100, 1110 1100
C. 1110 1100, 0110 1100
D. 0110 1100, 0110 1100
```

43. 「2018真题」减法指令 "sub R1,R2,R3" 的功能为 "(R1)-(R2)->(R3)"，该指令执行后将生成错位/借位标志 CF 和溢出标志 OF。若 (R1) = FFFF FFFFH， (R2) = FFFF FFF0H，则该减法指令执行后，CF 与 OF 分别为（ ）

```
A. CF=0,OF=0
B. CF=1,OF=0
C. CF=0,OF=1
D. CF=1,OF=1
```

44. 「2019真题」考虑以下 C 语言代码

```C
unsigned short usi = 65535;
short si = usi;
```
执行上述程序段后，si 的值是（ ）

```
A. -1
B. -32767
C. -32768
D. -65535
```

45. 「2020真题」在按字节编址，采用小端方式的 32 位计算机中，按边界对齐方式为以下 C 语言结构型变量 a 分配存储空间

```C
struct record {
    short x1;
    int x2;
} a;
```

若 a 的首地址位为 2020 FE00H，a 的成员变量 x2 的机器数为 1234 0000H，则其中 34H 所在存储单元的地址是（ ）

```
A. 2020 FE03H
B. 2020 FE04H
C. 2020 FE05H
D. 2020 FE06H
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 2.3.3 Calculation of Float | 浮点数的计算
03. 长度相同但格式不同的两种浮点数，假设前者基数大，后者基数小，其他规定均相同，则它们可表示的数的范围和精度为（ ）

```
A. 两者可表示的数的范围和精度相同
B. 前者可表示的数的范围大但精度低
C. 后者可表示的数的范围大且精度高
D. 前者可表示的数的范围大且精度高
```

05. 在规格化浮点运算中，若某浮点数为 2^5 * 1.10101，其中尾数为补码表示，则该数（ ）

```
A. 不需规格化
B. 需右移规格化
C. 需将尾数左移一位规格化
D. 需将尾数左移两位规格化
```

10. 按照 IEEE 754 标准规定的 32 位单精度浮点数 41A4C000H 对应的十进制数是（ ）

```
A. 4.59375
B. -20.59375
C. -4.59375
D. 20.59375
```

12. 如果某单精度浮点数、某原码、某补码、某移码的 32 位机器数为 0xF0000000，这些数从大到小的顺序是（ ）

```
A. 浮原补移
B. 浮移补原
C. 移原补浮
D. 移补原浮
```

✅16. 假定采用 IEEE 754 标准中的单精度浮点数格式表示一个数为 45100000H，则该数的值为（ ）

```
A. (+1.125)10 * 2^10
B. (+1.125)10 * 2^11
C. (+0.125)10 * 2^11
D. (+0.125)10 * 2^10
```

19. 若浮点数的尾数用补码表示，则下列（ ）中的尾数是规格化数形式

```
A. 1.11000
B. 0.01110
C. 0.01010
D. 1.00010
```

21. 下列关于舍入的说法，正确的是（ ）

```
I.   不仅仅只有浮点数需要舍入，定点数在运算时也可能要舍入
II.  在浮点数舍入中，只有左规格化时可能要舍入
III. 在浮点数舍入中，只有右规格化时可能要舍入
IV.  在浮点数舍入中，左、右规格化均可能要舍入
V.   舍入不一定产生误差

A. I,III,V
B. I,II,V
C. V
D. I,IV
```

22. 「2009真题」浮点数加减运算过程一般包括对阶、尾数运算、规格化、舍入和判断溢出等步骤。设浮点数的阶码和尾数均采用补码表示，且位数分别为 5 和 7 （均含两位符号位）。若有两个数 X = 2^7 * 29/32 和 Y = 2^5 * 5/8，则用浮点数加法计算 X+Y 的最终结果是（ ）

```
A. 00111 1100010
B. 00111 0100010
C. 01000 0010001
D. 发生溢出
```

24. 「2011真题」float 型数据通常用 IEEE 754 单精度格式表示，若编译器将 float 型变量 x 分配在一个 32 位浮点寄存器 FR1 中，且 x = -8.25，则 FR1 中的内容是（ ）

```
A. C104 0000H
B. C242 0000H
C. C184 0000H
D. C1C2 0000H
```

✅26. 「2013真题」某数采用 IEEE 754 单精度浮点数格式表示为 C640 0000H，则该数的值是（ ）

```
A. -1.5 * 2^13
B. -1.5 * 2^12
C. -0.5 * 2^13
D. -0.5 * 2^12
```

30. 「2020真题」已知带符号整数用补码表示，float 型数据用 IEEE 754 标准表示，假定变量 x 的类型只可能是 int 或 float，当 x 的机器数为 C800 0000H 时，x 的值可能是（ ）

```
A. -7 * 2^27
B. -2^16
C. 2^17
D. 25 * 2^27
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

# Chapter 3: Storage
## 3.1.4 Storage Level | 存储结构
✅03. 设机器字长为 32 位，一个容量为 16MB 的存储器，CPU 按半字寻址，其可寻址的单元数是（ ）

```
A. 2^24
B. 2^23
C. 2^22
D. 2^21
```

```
16MB = 2^24B => N = (2^24B) / (2B) = 2^23 = 16M
```

✅04. 相联存储器是按（ ）进行寻址的存储器

```
A. 地址指定方式
B. 堆栈存储方式
C. 内容指定方式和堆栈存储方式相结合
D. 内容指定方式和地址指定方式相结合
```

```
相联存储器：将存储单元所存内容的某一部分作为检索项去检索该存储器，并将存储器中与该检索项符合的存储单元内容进行读出或写入。因此是按照内容指定和地址指定方式相结合的方式进行寻址的存储器
```

✅06. 若某存储器存储周期为 250ns，每次读出 16 位，该存储器的数据传输率是（ ）

```
A. 4 * 10^6 B/s
B. 4 MB/s
C. 8 * 10^6 B/s
D. 8 * 2^20 B/s
```

```
传输速率即带宽，每个存储周期读出 16bit = 2B

BandWidth=(2B)/[250*10^(-9) s]=(8*10^6 B/s)=(8MB/s)

注意区分数据传输中的单位和容量的二进位单位不一样
```

✅07. 设机器字长为 64 位，存储容量为 128MB，若按字编址，它可寻址的单元个数是（ ）

```
A. 16MB
B. 16M
C. 32M
D. 32MB
```

```
64bit = 8B => N = (128MB)/(8B) = (16M) 
128MB = 2^27 * 8bit

N = 2^27 * 8 / 64 = 2^24 = 16M 
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 3.2.5 Main Storage | 主存储器
09. 某一 DRAM 芯片，采用地址复用技术，其容量为 1024*8 位，除电源和接地端外，该芯片的引脚数最少是（ ）（读写控制线为两根）

```
A. 16
B. 17
C. 19
D. 21
```

16. 一个四体并行低位交叉存储器，每个模块的容量是 64K*32 位，存取周期为 200ns，总线周期为 50ns，在下属说法中，（ ）是正确的

```
A. 在 200ns 内，存储器能向 CPU 提供 256 位二进制信息
B. 在 200ns 内，存储器能向 CPU 提供 128 位二进制信息
C. 在 50ns 内，每个模块能向 CPU 提供 32 位二进制信息
D. 以上都不对
```

17. 某机器采用四体低位交叉存储器，现分别执行下述操作：
    1. 读取 6 个连续地址单元存放的存储字，重复 80 次；
    2. 读取 8 个连续地址单元存放的存储字，重复 60 次。

    则 1,2花费时间之比为（ ）

```
A. 1:1
B. 2:1
C. 4:3
D. 3:4
``` 

18. 下列说法中，正确的是（ ）

```
I.   高位多体交叉存储器能很好地满足程序的局部性原理
II.  高位四体交叉存储器可能在一个存储周期内连续访问 4 个模块
III. 双端口存储器可以同时访问同一区间、同一单元
IV.  双端口存储器当两个端口的地址码相同时，必然会发生冲突

A. I,III
B. II,III
C. II,III,IV
D. III,IV
```

✅22. 「2014真题」某容量为 256MB 的存储器由若干 4M * 8bit 的 DRAM 芯片构成，该 DRAM 芯片的地址引脚和数据引脚总数是（ ）

```
A. 19
B. 22
C. 30
D. 36
```

```
4M * 8bit => N(data) = 8; N1(address) = log2(4M) = 22; 
DRAM 采用地址复用技术 => N(address) = N1/2 = 11

N = N(data)+N(address)=19
```

25. 「2017真题」某计算机主存按字节编址，由 4 个 64M * 8bit 的 DRAM 芯片采用交叉编址方式构成，并与宽度为 32 位的存储器总线相连，主存每次最多读写 32 位数据，若 double 型 变量 x 的主存地址为 804 001AH，则读取 x 需要的存储周期数是（ ）

```
A. 1
B. 2
C. 3
D. 4
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)
