# Catalog | 目录
## [Chapter 1 Conception | 概论](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#chapter-1-conception)
[1.2.6 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#126-level-structure--层次结构简述)

[1.3.3 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#133-performance--性能指标)

## [Chapter 2 Data | 数据](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#chapter-2-data)
[2.1.5 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#215-code--numeral-system-编码与数制)

[2.2.7 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#227-calculation--运算方法)

[2.3.3 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#233-calculation-of-float--浮点数的计算)

## [Chapter 3 Storage | 存储器](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#chapter-3-storage)
[3.1.4 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#314-storage-level--存储结构)

[3.2.5 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#325-main-storage--主存储器)

[3.3.5 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#335-link-between-main-storage-and-cpu--主存储器和-cpu-的连接)

[3.4.3 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#343-external-storage--外部存储)

[3.5.6 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#356-cache--高速缓冲器)

[3.6.6 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#366-virtual-storage--虚拟存储器)

## [Chapter 4 Order | 指令](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#chapter-4-order)
[4.1.5 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#415-formate-of-orders--指令的格式)

[4.2.3 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#423-method-of-find-address--寻址方式)

[4.3.5 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#435-assembly-order--机器级指令入门)

## [Chapter 5 CPU | 中央处理器](url)
[5.1.3 解析已看完](url)

[5.2.4 解析已看完](url)

[5.3.3 解析未看完](url)

# Chapter 1: Conception
## 1.2.6 Level Structure | 层次结构简述
02.  冯·诺依曼机的基本工作方式是（ ）

```
A. 控制流驱动方式
B. 多指令多数据流方式
C. 微程序控制方式
D. 数据流驱动方式
```

03. 下列（ ）是冯·诺依曼机工作方式的基本特点。

```
A. 多指令流单数据流
B. 按地址访问并顺序执行指令
C. 堆栈操作
D. 存储器按内容选择地址
```

04. 以下说法错误的是（ ）

```
A. 硬盘是外部设备
B. 软件的功能与硬件的功能在逻辑上是等效的
C. 硬件实现的功能一般比软件实现具有更高的执行速度
D. 软件的功能不能用硬件取代
```

05. 存放欲执行指令的寄存器是（ ）

```
A. MAR  // 地址寄存器
B. PC   // 程序计数器
C. MDR  // 数据寄存器
D. IR   // 指令寄存器
```

09. 在运算器中，不包含（ ）

```
A. 状态寄存器
B. 数据总线
C. ALU
D. 地址寄存器
```

10. 下列关于 CPU 存取速度的比较中，正确的是（ ）

```
A. Cache > 内存 > 寄存器
B. Cache > 寄存器 > 内存
C. 寄存器 > Cache > 内存
D. 寄存器 > 内存 > Cache
```

14. 关于编译程序和解释程序，下列说法中错误的是（ ）

```
// 解释语言：翻译一条语句立即执行一条语句 ==> 效率低
// 编译语言：翻译完全部语句再执行全部语句 ==> 效率高

A. 编译程序和解释程序的作用都是高级语言转换成机器语言程序
B. 编译程序编译时间较长，运行速度较快
C. 解释程序方法较简单，运行速度也快
D. 解释程序将源程序翻译成机器语言，并且翻译一条以后，立即执行这条语句
```

17. 下列叙述中，正确的是（ ）

```
I.   实际应用程序的测试结果能够全面代表计算机的性能
II.  系列机的基本特性是指令系统向后兼容
III. 软件和硬件在逻辑功能上是等价的

// I.   ==> 很显然错误
// II.  ==> 系列机：具有相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列
// III. ==> 根据冯·诺依曼机的原理，软件和硬件在逻辑上是等效的

A. II
B. III
C. II,III
D. I,II,III
```

20. 关于相联存储器，下列说法中正确的是（ ）

```
A. 只可以按地址寻址
B. 只可以按内容寻址
C. 即可按地址寻址又可按内容寻址
D. 以上说法均不完善
```

22. 「2009真题」冯·诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU 区分它们的依据是（ ）

```
A. 指令操作码的译码结果
B. 指令和数据的寻址方式
C. 指令周期的不同阶段
D. 指令和数据所在的存储单元
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 1.3.3 Performance | 性能指标
❓02. 存储字长是指（ ）

```
A. 存放在一个存储单元中的二进制代码组合
B. 存放在一个存储单元中的二进制代码位数
C. 存储单元的个数
D. 机器指令的位数
```

```
机器字长：计算机位数，即计算机一次能处理的二进制数的长度，为处理整数运算的部件的部件
指令字长：一个指令字中包含的二进制代码位数
存储字长：等于MDR位数
```

❓04. 下列关于机器字长、指令字长和存储字长的说法中，正确的是（ ）

```
I.   三者在数值上总是相等的
II.  三者在数值上可能不等
III. 存储字长是存放在一个存储单元中的二进制代码位数
IV.  数据字长是 MDR 的位数

A. I,III 
B. I,IV
C. II,III
D. II,IV
```

✅05. 32 位微机是指该计算机所用 CPU（ ）

```
A. 具有 32 位寄存器
B. 能同时处理 32 位的二进制数
C. 具有 32 个寄存器
D. 能处理 32 个字符
```

```
机器字长等于32位 => 能同时处理 32 位的二进制数
```

❓10. 计算机中，CPU 的 CPI 与下列（ ）因素无关

```
A. 时钟频率
B. 系统结构
C. 指令集
D. 计算机组织
```

```
CPI 与系统结构、指令集、计算机组织有关，但与时钟频率无关
```

✅14. 下列说法中，正确的是（ ）

```
I.   在微型计算机的广泛应用中，会计电算化属于科学计算方面的应用
II.  决定计算机计算精度的主要技术是计算机字长
III. 计算机 “运算速度” 指标的含义是每秒能执行多少条操作系统的命令
IV.  利用大规模集成电路技术把计算机的运算部件和控制部件做在一块集成电路芯片上，这样的一块芯片称为单片机

A. I,III
B. II,IV
C. II
D. I,III,IV
```

```
I.   => 属于数据处理方面，即应用方面
II.  => 对的
III. => 运算速度是每秒能执行多少条指令
IV.  => 这玩意被称为 CPU（运算部件和控制部件）
```

✅20. 「2017真题」假定计算机 M1 和 M2 具有相同的指令集体系结构（ISA），主频分别为 1.5Ghz 和 1.2GHz。在 M1 和 M2 上运行某基准程序 P，平均 CPI 分别为 2 和 1，则程序 P 在 M1 和 M2 上运行时间的比值是（ ）

```
A. 0.4
B. 0.625
C. 1.6
D. 2.5
```

```
运行时间 = 指令数 * CPI / 主频

比值 = （M1 时间=指令数*2/1.5）/（指令数*1/1.2）=（2/1.5）/（1/1.2） = 1.6
```

✅21. 「2020真题」下列给出的部件中，其位数（宽度）一定与机器字长相同的是（ ）

```
I.   ALU
II.  指令寄存器
III. 通用寄存器
IV.  浮点寄存器

A. I,II
B. I,III
C. II,III
D. II,III,IV
```

```
机器字长：CPU 内部用于整数运算的数据通路的宽度

用于整数运算的部件：ALU，通用寄存器
```

✅22. 「2021真题」2017年公布的全球超级计算机 TOP 500 排名中，我国 “神威·太湖之光” 超级计算机蝉联第一，其浮点运算速度为 93.0146 PFLOPS，说明该计算机每秒钟内完成的浮点操作次数约为（ ）

```
A. 9.3*10^13
B. 9.3*10^15
C. 9.3 千万亿次
D. 9.3 亿亿次
```

```
这题就离谱，为啥前面用幂后面用汉字

10^13 == 十万亿
10^15 == 千万亿
10^16 == 亿亿
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

# Chapter 2: Data
## 2.1.5 Code & Numeral System| 编码与数制
✅01. 下列各种数制的数中，最小的数是（ ）

```
A. (101001)2
B. (101001)BCD
C. (52)8
D. (233)16
```

```
A. (101001)2 = 29H
B. (101001)BCD = 29D
C. (52)8 = 2AH

*BCD 码现在不考了
```

❓14. 对于关于补码和移码关系的叙述中，（ ）是不正确的

```
A. 相同位数的补码和移码表示具有相同的数据表示范围
B. 零的补码和移码表示相同
C. 同一个数的补码和移码表示，其数值部分相同，而符号相反
D. 一般用移码表示浮点数的阶，而补码表示定点整数
```

```
以5位机器字长为例：
[0]补 = 00000 != [0]移 = 2^4 + 0 = 10000
```

❓15. 若[x]补 = 1, x1 x2 x3 x4 x5 x6，其中 xi 取 0 或 1，若要 x > -32，应当满足（ ）

```
A. x1 为 0，其他各位任意
B. x1 为 1，其他各位任意
C. x1 为 1，x2～x6 中至少有一位为 1
D. x1 为 0，x2～x6 中至少有一位为 1
```

```
补码转原码（负数）：符号位不变，数值位全部取反，末位加1
故 x1 一定为 1（取反后是0）
（那么如果 [x]原 = 10000000 呢？）
使用补码表示时，符号位相同的情况下，数值位越大，码值也越大
```

❓16. 设 x 为整数，[x]补 = 1, x1 x2 x3 x4 x5，若要 x < -16，x1～x5 应满足（ ）

```
// 同15

A. x1~x5 至少有一个为 1
B. x1 必须为 0，x2~x5 至少有一个为 1
C. x1 必须为 0，x2～x5 任意
D. x1 必须为 1，x2～x5 任意
```

✅17. 设 x 为真值，x* 为其绝对值，满足 [-x*]补 = [-x]补，当且仅当（ ）

```
// 冷知识：0 不是正数，也不是负数

A. x 任意 
B. x 为正数
C. x 为负数
D. 以上说法都不对
```

❓23. 若寄存器内容为 00000000，若它等于 -128，则为（ ）

```
A. 原码
B. 补码
C. 反码
D. 移码
```

```
寄存器长度为 8，[-128]移 = 2^7+(10000000) = 00000000
```

❓25. 下列为 8 位移码机器数 [x]移，求 [-x]移时，（ ）会发生溢出

```
A. 11111111
B. 00000000
C. 10000000
D. 01111111
```

```
B => -128, -(-128)=128 => 溢出
```

✅27. 在计算机中，通常用来表示主存地址的是（ ）

```
A. 移码
B. 补码
C. 原码
D. 无符号数
```

```
主存地址均为正数，因此采用无符号整数即可
```

✅30. 「2021真题」已知带符号整数用补码表示，变量 x,y,z 的机器数分别为 FFFDH,FFDFH,7FFCH，下列结论中，正确的是（ ）

```
A. 若 x,y,z 为无符号整数，则 z<x<y
B. 若 x,y,z 为无符号整数，则 x<y<z
C. 若 x,y,z 为带符号整数，则 x<y<z
D. 若 x,y,z 为带符号整数，则 y<x<z
```

```
若 x,y,z 为无符号整数，则 x>y>z （因为均是正数）
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 2.2.7 Calculation | 运算方法
✅04. 加法器中每位的进位生成信号 g 为（ ）

```
A. Xi xor Yi 
B. Xi*Yi
C. Xi*Yi*Ci
D. Xi+Yi+Ci
```

```
多位加法器为了加快运算速度而采用了快速进位链，其中包含两个信号：
1. 进位信号 g = Xi*Yi 
2. 进位传递信号 p = Xi xor Yi
```

❓10. 一个 8 位寄存器内的数值为 11001010，进位标志寄存器 C 为 0，若将此 8 位寄存器循环左移（不带进位位）1 位，则该 8 位寄存器和标志寄存器内的数值分别为（ ）

```
A. 1001 0100, 1
B. 1001 0101, 0
C. 1001 0101, 1
D. 1001 0100, 0
```

```
不带进位位的循环左移将最高位进入最低位和标志寄存器 CF 位

*还是不太明白
```

✅13. 16 位补码 0x8FA0 扩展为 32 位应该是（ ）

```
A. 0x0000 8FA0
B. 0xFFFF 8FA0
C. 0xFFFF FFA0
D. 0x8000 8FA0
```

```
16 位扩展为32位，符号位不变，附加位是符号位的扩展。
8FA0 是一个负数，因此附加位均用 1 填补附加位。
```

❓15. 关于模 4 补码，下列说法正确的是（ ）

```
A. 模 4 补码和模 2 补码不同，它更容易检查乘除运算中的溢出问题
B. 每个模 4 补码存储时只需一个符号位
C. 存储每个模 4 补码需要两个符号位
D. 模 4 补码，在算数与逻辑部件中为一个符号位
```

```
1. 模 4 补码
2. 模 2 补码

A：❌ 模 4 补码拥有模 2 补码的全部优点，并且更易检查加减运算中的溢出问题
B：✅ 存储模 4 补码仅需一个符号位，任意正确的数值，其模 4 补码的两个符号位都相同
C：❌ 理由同上
D：❌ 只有在 ALU 中进行运算中才会采用双符号位
```

✅17. 判断加减法溢出时，可采用判断进位的方式，若符号位的进位为 C0，最高位的进位为 C1，则产生溢出的条件是（ ）

```
I.   C0 产生进
II.  C1 产生进位
III. C0、C1 都产生进位
IV.  C0、C1 都不产生进位
V.   C0 产生进位，C1 不产生进位
VI.  C0 不产生进位，C1 产生进位

A. I,II
B. III
C. IV
D. V,VI
```

```
采用进位位来判断溢出时，当最高有效位进位和符号位进位的值不同的时候才产生溢出
1. 正溢出：两个正数相加，当最高有效位产生进位（即：C1 = 1），而符号位不产生进位（即：C0 = 0）
2. 负溢出：两个负数相加，最高有效位不产生进位（即：C1 = 0），而符号位产生进位（即：C0 = 1）
```

✅19. 若 [X]补 = X0.X1X2...Xn，其中 X0 为符号位，X1 为最高数位。若（ ），则当补码左移时，将会发生溢出

```
A. X0 = X1
B. X0 != X1
C. X1 = 0
D. X1 = 1
```

```
溢出判别法适用此种情况：
1. 符号位：由单符号位变成双符号位，然后左移，若两符号位不同则溢出，即 X0 != X1 时溢出；
2. 数值位：最高位进位和符号位进位不同导致溢出，此时 X1 != X0；
综上可知：X1 != X0 会在左移后导致溢出
```

❓22. 在原码一位乘法中，（ ）

```
A. 符号位参加运算
B. 符号位不参加运算
C. 符号位参加运算，并根据运算结果改变结果中的符号位
D. 符号位不参加运算，并根据运算结果确定结果中的符号·
```

```
在原码一位乘法中，符号位不参与运算，且单独处理，同号为正，异号为负
（那为啥 D 不对？）
```

✅24. 实现 N 位（不包括符号位）补码一位乘时，乘积为（ ）位

```
A. N
B. N+1
C. 2N
D. 2N+1
```

```
补码一位乘法运算过程中，一共向右移位 N 次，加上原先的 N 位，一共是 2N 位的数值位，又乘积结果需加上一位符号位，因此为 2N+1 位
```

✅25. 在原码不恢复余数法（又称原码加减交替法）的算法中，（ ）

```
A. 每步操作后，若不够减，则需恢复余数
B. 若为负商，则恢复余数
C. 整个算法过程中，从不恢复余数
D. 仅当最后一不够减时，才恢复一次余数
```

```
原码不恢复余数法中，只在最终余数为负时，才需要恢复余数
```

✅26. 下列关于补码除法的说法中，正确的是（ ）

```
A. 补码不恢复除法中，够减商 0，不够减商 1
B. 补码不恢复余数除法中，异号相除时，够减商 0，不够减商 1
C. 补码不恢复除法中，够减商 1，不够减商 0
D. 以上都不对
```

```
补码不恢复余数法中，异号相除时看够不够减，够减商0，不够减商1
```

❓27. 下列关于各种移位的说法正确的是（ ）

```
I.   假设机器数采用反码表示，当机器数为负时，左移时最高数位丢 0，结果出错；右移时最低数位丢 0，影响精度
II.  在算数移位的情况下，补码左移的前提条件是其原最高有效位与原符号位要相同
III. 在算数移位的情况下，双符号位的移位操作只有低符号位需要参加移位操作

A. I,III
B. II
C. III
D. I,II,III
```

```
I.   => 负数的反码的数值位与其原码相反
II.  => 补码表示时，正数符号位为 0，左移最高位为 0时，数据不会丢失；负数符号位为 1，左移最高位为 1时，数据不会丢失
III. => 双符号位表示时，只有最高符号位表示真正的符号，低符号位用于参与移位操作以判断是否发生溢出，如 01 表示正溢出，10 表示负溢出
```

✅29. 某计算机字长为 8 位，CPU 中有一个 8 位加法器。已知无符号数 x = 69，y = 38，如果在该加法器中计算 x-y，则加法器的两个输入端信息和输入的低位进位信息分别为（ ）

```
A. 0100 0101, 0010 0110, 0
B. 0100 0101, 1101 1001, 1
C. 0100 0101, 1101 1010, 0
D. 0100 0101, 1101 1010, 1
```

```
[x]补 = 0100 0101, [y]补 = 0010 0110, [-y]补 = 1101 1010 [-y]原 = 1010 0110, [-y]补 = 1101 1010

[x-y]补 = 0100 0101 + 1101 1001 + 1 = 0001 1111;
```

✅31. 某 8 位计算机中，x 和 y 是两个带符号整数，用补码表示，[x]补 = 44H，[y]补 = DCH，则 x/2 + 2y 的机器数及相应的溢出标志 OF 分别是（ ）

```
A. CAH,0
B. CAH,1
C. DAH,0
D. DAH,1
```

```
[x/2 + 2y]补 = [x]补 >> 1 + [y]补 << 1 = 0100 0100 >> 1 + 1101 1100 << 1 = 0010 0010 1011 1000 = 1101 1010 = DAH（这都是啥？ => 哦懂了）

[x]补 = 44H = 0100 0100 => [x]原 = 0100 0100 = 68 => [x/2] = 34 => [x/2]原/补 = 0010 0010 

[y]补 = DCH = 1101 1100 => [y]原 = 1010 0100 = -38 => [2y] = -76 => [2y]原 = 1100 1000 => [2y]补 = 1011 1000

[x/2 + 2y]补 = 0010 0010 + 1011 1000 = 1101 1010 => DAH
并且真值为 -42，未溢出，OF 为 0
```

34. 「2012真题」某计算机存储器按字节编址，采用小端方式存放数据。假定编译器规定 int 和 short 型长度分别为 32 位和 16 位，并且数据按边界对齐存储。某 C 语言程序段如下：

```C
struct {
    int a;
    char b;
    short c;
} record;
record.a = 273;
```

若 record 变量的首地址为 0xC008，地址 0xC008 中的内容及 record.c 的地址分别为（ ）。

```
A. 0x00,0xC00D
B. 0x00,0xC00E
C. 0x11,0xC00D
D. 0x11,0xC00E
```

```

```

✅35. 「2012真题」假定编译器规定 int 和 short 类型长度分别为 32 位和 16 位，执行下列 C 语言语句（ ）

```C
unsigned short x=65530;
unsigned int y=x;
```

```
A. 0000 7FFAH
B. 0000 FFFAH
C. FFFF 7FFAH
D. FFFF FFFAH
```

```
16 位 unsigned short 转换为 32 位 unsigned int，unsigned = 无符号数 => 新形式的高位用 0 填充

unsigned short max = 65535 = FFFFH => x = 65530 = FFFFH - 5H = FFFAH => y = 0000 FFFAH
```

❓36. 「2013真题」某字长为 8 位的计算机中，已知整型变量 x、y 的机器数分别为 [x]补 = 1 1110100, [y]补 = 1 0110000。若整型变量 z = 2x + y/2，则 z 的机器数为（ ）

```
A. 1 1000000
B. 0 0100100
C. 1 0101010
D. 溢出
```

```
[x]补 = 1 1110100, [y]补 = 1 0110000
[2x]补 = 1 1101000（算数左移）；[y/2]补 = 1 1011000（算数右移） => 均未损失精度或溢出
[2x + y/2] = 1 110 1000 + 1 101 1000 = 1 100 0000（怎么就没溢出呢）
```

❓38. 「2016真题」有如下 C 语言程序段

```C
short si = -32767;
unsigned short usi = si;
```

执行上述两条语句后，usi 的值为

```
A. -32767
B. 32767
C. 32768
D. 32769
```

```
C 语言中的数据在内存中使用补码表示，si 对应的数值的补码表示为 1000 0000 0000 0001；
而由 signed 型转化为等长的 unsigned 型数据时，符号位为数据的一部分，即将负数转化为无符号数，数值会发生变化。
因此二进制码一致，但符号位默认为零，此时 1000 0000 0000 0001 = 2^15 + 1
```

✅41. 「2018真题」某 32 位计算机按字节编址，采用小端方式。若语句 “int i=0;” 对应指令的机器代码为 “C7 45 FC 00 00 00”，则语句 “int i=-64;” 对应指令的机器代码是（ ）

```
A. C7 45 FC C0 FF FF FF
B. C7 45 FC 0C FF FF FF
C. C7 45 FC FF FF FF C0
D. C7 45 FC FF FF FF 0C
```

```
按字节编址，采用小端方式，低位的数据存储在低地址位，高位的数据存储在高地址位，并且按照一字节相对不变的顺序存储。
存储 0 的位数是后 32 位，则只需将 -64 的补码按字节存储在其中即可。 
-64 = FFFF FFC0H
按照小端方式则为：C0 FF FF FF => A
```

✅42. 「2018真题」整数 x 的机器数为 1101 1000，分别对 x 进行逻辑右移 1 位和算数右移 1 位操作，得到的机器数各是（ ）

```
A. 1110 1100, 1110 1100
B. 0110 1100, 1110 1100
C. 1110 1100, 0110 1100
D. 0110 1100, 0110 1100
```

```
逻辑移位：
无论左移还是右移，空位均补 0，且所有数字参与移动（包括符号位）；

算数移位：
符号位不参与移动，右移空位补符号位，左移空位补 0.
```

❓43. 「2018真题」减法指令 "sub R1,R2,R3" 的功能为 "(R1)-(R2)->(R3)"，该指令执行后将生成错位/借位标志 CF 和溢出标志 OF。若 (R1) = FFFF FFFFH， (R2) = FFFF FFF0H，则该减法指令执行后，CF 与 OF 分别为（ ）

```
A. CF=0,OF=0
B. CF=1,OF=0
C. CF=0,OF=1
D. CF=1,OF=1
```

```
[x]补 - [y]补 = [x]补 + [-y]补
[R1]补 - [R2]补 = [R1]补 + [-R2]补 
[-R2]补 = 0000 0010H => [R1]补 + [-R2]补 最高位进位和符号位进位均为 1

溢出位：当最高位进位和符号位进位的值不相同才会产生溢出 => OF = 0
R1 > R2 => CF = 0 （为啥？）
```

✅44. 「2019真题」考虑以下 C 语言代码

```C
unsigned short usi = 65535;
short si = usi;
```
执行上述程序段后，si 的值是（ ）

```
A. -1
B. -32767
C. -32768
D. -65535
```

```
unsigned short => 无符号整数
short => 带符号整数

65535 = 2^16 - 1 = 1111 1111 1111 1111 （无符号整数最大值）
short si = 1111 1111 1111 1111 => 带符号补码 => 1000 0000 0000 0001 = -1
```

✅45. 「2020真题」在按字节编址，采用小端方式的 32 位计算机中，按边界对齐方式为以下 C 语言结构型变量 a 分配存储空间

```C
struct record {
    short x1;
    int x2;
} a;
```

若 a 的首地址位为 2020 FE00H，a 的成员变量 x2 的机器数为 1234 0000H，则其中 34H 所在存储单元的地址是（ ）

```
A. 2020 FE03H
B. 2020 FE04H
C. 2020 FE05H
D. 2020 FE06H
```

```
short => 2B, int => 4B

| 2020 FE00H | 2020 FE01H | 2020 FE02H | 2020 FE03H |
    x1(LSB)      x1(MSB)

| 2020 FE04H | 2020 FE05H | 2020 FE06H | 2020 FE07H |
    x2(LSB)                                 x2(MSB)

34H => 2020 FE06H                
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 2.3.3 Calculation of Float | 浮点数的计算
✅03. 长度相同但格式不同的两种浮点数，假设前者基数大，后者基数小，其他规定均相同，则它们可表示的数的范围和精度为（ ）

```
A. 两者可表示的数的范围和精度相同
B. 前者可表示的数的范围大但精度低
C. 后者可表示的数的范围大且精度高
D. 前者可表示的数的范围大且精度高
```

```
基数越大，范围越大，但精度越低
```

✅05. 在规格化浮点运算中，若某浮点数为 2^5 * 1.10101，其中尾数为补码表示，则该数（ ）

```
A. 不需规格化
B. 需右移规格化
C. 需将尾数左移一位规格化
D. 需将尾数左移两位规格化
```

```
浮点数的规格化：尾数为补码表示，且为 1.0xxxx 形式时为规格化数。

本题中，尾数为 1.10101，需左移一位成为 1.0101，同时阶码减一变成 4
```

✅10. 按照 IEEE 754 标准规定的 32 位单精度浮点数 41A4C000H 对应的十进制数是（ ）

```
A. 4.59375
B. -20.59375
C. -4.59375
D. 20.59375
```

```
41A4 C000H = 0 10000011 01001001100000000000000 = 10100.10011 = 16+4+(2^-1)+(2^-4)+(2^-5)=20+0.5+0.0625+0.03125=20.59375
             |    ||                ||
           符号位  阶码（移码表示）    1.010010011
             +    ｜
                  2^7 + 3 - 127 = 4（？我算的 3；没事了）
```

✅12. 如果某单精度浮点数、某原码、某补码、某移码的 32 位机器数为 0xF0000000，这些数从大到小的顺序是（ ）

```
A. 浮原补移
B. 浮移补原
C. 移原补浮
D. 移补原浮
```

```
F000 0000 = 1111 0000 0000 0000 0000 0000 0000 0000
移 => 正数
原、补、浮 => 负数

补：-2^28
原：-(2^30+2^29+2^28)
浮：-1.0*2*97
```

✅16. 假定采用 IEEE 754 标准中的单精度浮点数格式表示一个数为 45100000H，则该数的值为（ ）

```
A. (+1.125)10 * 2^10
B. (+1.125)10 * 2^11
C. (+0.125)10 * 2^11
D. (+0.125)10 * 2^10
```

```
4510 0000H = 0100 0101 0001 0000 0000 0000 0000 0000 = 0 10001010 00100000000000000000000 = 1.001 * 2^11 = (+1.125)10 * 2^11 => B
                                                       |    ||              ||
                                                       +    11              1.001
```

✅19. 若浮点数的尾数用补码表示，则下列（ ）中的尾数是规格化数形式

```
A. 1.11000
B. 0.01110
C. 0.01010
D. 1.00010
```

```
补码规格化表示时小数点后一位与符号位不同 => D
```

✅21. 下列关于舍入的说法，正确的是（ ）

```
I.   不仅仅只有浮点数需要舍入，定点数在运算时也可能要舍入
II.  在浮点数舍入中，只有左规格化时可能要舍入
III. 在浮点数舍入中，只有右规格化时可能要舍入
IV.  在浮点数舍入中，左、右规格化均可能要舍入
V.   舍入不一定产生误差

A. I,III,V
B. I,II,V
C. V
D. I,IV
```

```
I.              => 舍入只属于浮点数
II./III./IV.    => 舍入有两种情况：对阶，右规格化
V.              => 舍入不一定产生误差，例：11.00 -> 11.0 => 无误差
```

✅22. 「2009真题」浮点数加减运算过程一般包括对阶、尾数运算、规格化、舍入和判断溢出等步骤。设浮点数的阶码和尾数均采用补码表示，且位数分别为 5 和 7 （均含两位符号位）。若有两个数 X = 2^7 * 29/32 和 Y = 2^5 * 5/8，则用浮点数加法计算 X+Y 的最终结果是（ ）

```
A. 00111 1100010
B. 00111 0100010
C. 01000 0010001
D. 发生溢出
```

```
X = 2^7 * 29/32 = 2^2 * 29 = 00111 0011101; Y = 2^5 * 5/8 = 2^2 * 5 = 00101 0010100; 
                               |     |                                  |      |
                              阶码   尾数                               阶码    尾数

X + Y = 2^2 * 34 = 2^2 * (2^5 + 2^1) = 2^8 * 0.10001 = 01000 0010001 => 溢出  
```

✅24. 「2011真题」float 型数据通常用 IEEE 754 单精度格式表示，若编译器将 float 型变量 x 分配在一个 32 位浮点寄存器 FR1 中，且 x = -8.25，则 FR1 中的内容是（ ）

```
A. C104 0000H
B. C242 0000H
C. C184 0000H
D. C1C2 0000H
```

```
x = -8.25 = -(2^3 + 2^-2) = -1000.01 = -0.10001 * 2^3 = 1 10000010 00001000100000000000000 => C104 0000H
```

✅26. 「2013真题」某数采用 IEEE 754 单精度浮点数格式表示为 C640 0000H，则该数的值是（ ）

```
A. -1.5 * 2^13
B. -1.5 * 2^12
C. -0.5 * 2^13
D. -0.5 * 2^12
```

```
C640 0000H = 1100 0110 0100 0000 0000 0000 0000 0000 = 1 10001100 10000000000000000000000 = - 2^13 * 1.1 = -1.5 * 2^13
```

✅30. 「2020真题」已知带符号整数用补码表示，float 型数据用 IEEE 754 标准表示，假定变量 x 的类型只可能是 int 或 float，当 x 的机器数为 C800 0000H 时，x 的值可能是（ ）

```
A. -7 * 2^27
B. -2^16
C. 2^17
D. 25 * 2^27
```

```
C800 0000H = 1100 1000 0000 0000 0000 0000 0000 0000 = 1 10010000 000000000000000000000 = - 2^17 * 1.0 => float

C800 0000H = 1100 1000 0000 0000 0000 0000 0000 0000 = 1 100 1000 0000 0000 0000 0000 0000 0000 = 1 011 1000 0000 0000 0000 0000 0000 0000 = - (2^29 + 2^28 + 2^27) = - 2^27 * (2^2 + 2^1 + 2^1) = - 2^27 * 7 => A 
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

# Chapter 3: Storage
## 3.1.4 Storage Level | 存储结构
✅03. 设机器字长为 32 位，一个容量为 16MB 的存储器，CPU 按半字寻址，其可寻址的单元数是（ ）

```
A. 2^24
B. 2^23
C. 2^22
D. 2^21
```

```
16MB = 2^24B => N = (2^24B) / (2B) = 2^23 = 16M
```

✅04. 相联存储器是按（ ）进行寻址的存储器

```
A. 地址指定方式
B. 堆栈存储方式
C. 内容指定方式和堆栈存储方式相结合
D. 内容指定方式和地址指定方式相结合
```

```
相联存储器：将存储单元所存内容的某一部分作为检索项去检索该存储器，并将存储器中与该检索项符合的存储单元内容进行读出或写入。因此是按照内容指定和地址指定方式相结合的方式进行寻址的存储器
```

✅06. 若某存储器存储周期为 250ns，每次读出 16 位，该存储器的数据传输率是（ ）

```
A. 4 * 10^6 B/s
B. 4 MB/s
C. 8 * 10^6 B/s
D. 8 * 2^20 B/s
```

```
传输速率即带宽，每个存储周期读出 16bit = 2B

BandWidth=(2B)/[250*10^(-9) s]=(8*10^6 B/s)=(8MB/s)

注意区分数据传输中的单位和容量的二进位单位不一样
```

✅07. 设机器字长为 64 位，存储容量为 128MB，若按字编址，它可寻址的单元个数是（ ）

```
A. 16MB
B. 16M
C. 32M
D. 32MB
```

```
64bit = 8B => N = (128MB)/(8B) = (16M) 
128MB = 2^27 * 8bit

N = 2^27 * 8 / 64 = 2^24 = 16M 
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 3.2.5 Main Storage | 主存储器
✅09. 某一 DRAM 芯片，采用地址复用技术，其容量为 1024*8 位，除电源和接地端外，该芯片的引脚数最少是（ ）（读写控制线为两根）

```
A. 16
B. 17
C. 19
D. 21
```

```
1024*8 = 2^10 * 2^3 => N(data) = 10/2 = 5（地址复用技术）; N(address) = 8; N(W/R) = 2; N(S) = 2（行通选+列通选，其中行通选代替片选线）;

N = 5+8+2+2 = 17
```

✅16. 一个四体并行低位交叉存储器，每个模块的容量是 64K*32 位，存取周期为 200ns，总线周期为 50ns，在下属说法中，（ ）是正确的

```
A. 在 200ns 内，存储器能向 CPU 提供 256 位二进制信息
B. 在 200ns 内，存储器能向 CPU 提供 128 位二进制信息
C. 在 50ns 内，每个模块能向 CPU 提供 32 位二进制信息
D. 以上都不对
```

```
低位交叉存储器采用流水线技术，因此该存储器可在一个读写周期内访问 4 个存储模块，因此 32 * 4 = 128 bit

*注：若从第一个字出发，到第四个字读写完成，应为 350ns（200+200-50）
```

✅17. 某机器采用四体低位交叉存储器，现分别执行下述操作：
    1. 读取 6 个连续地址单元存放的存储字，重复 80 次；
    2. 读取 8 个连续地址单元存放的存储字，重复 60 次。

    则 1,2花费时间之比为（ ）

```
A. 1:1
B. 2:1
C. 4:3
D. 3:4
``` 

```
第一种情况：前 79 轮每一轮均需花费 2T 进入下一轮；直到最后一轮，需要花费 1T + 1.25T = 2.25T；总计 79*2T + 2.25T = 160.25T

第二种情况：前 59 轮均需花费 2T 进入下一轮；直到最后一轮，需要等到第 8 个字存取完毕，需：2T + 0.75T = 2.75T；总计：59*2T + 2.75T = 120.75T

160.25/120.75 ～ 4/3 => C
```

✅18. 下列说法中，正确的是（ ）

```
I.   高位多体交叉存储器能很好地满足程序的局部性原理
II.  高位四体交叉存储器可能在一个存储周期内连续访问 4 个模块
III. 双端口存储器可以同时访问同一区间、同一单元
IV.  双端口存储器当两个端口的地址码相同时，必然会发生冲突

A. I,III
B. II,III
C. II,III,IV
D. III,IV
```

```
I.   => 高位多体交叉存储器在单个存储器中的字是连续存储，因此不满足程序的局部性原理
II.  => 高位多体交叉存储器可以在一个周期内访问连续的彼此地址相差一个存储体容量的 4 个字
III. => 双端口存储器可以同时访问同一区间、同一单元
IV.  => 访问时不会发生冲突
```

✅22. 「2014真题」某容量为 256MB 的存储器由若干 4M * 8bit 的 DRAM 芯片构成，该 DRAM 芯片的地址引脚和数据引脚总数是（ ）

```
A. 19
B. 22
C. 30
D. 36
```

```
4M * 8bit => N(data) = 8; N1(address) = log2(4M) = 22; 
DRAM 采用地址复用技术 => N(address) = N1/2 = 11

N = N(data)+N(address)=19
```

25. 「2017真题」某计算机主存按字节编址，由 4 个 64M * 8bit 的 DRAM 芯片采用交叉编址方式构成，并与宽度为 32 位的存储器总线相连，主存每次最多读写 32 位数据，若 double 型 变量 x 的主存地址为 804 001AH，则读取 x 需要的存储周期数是（ ）

```
A. 1
B. 2
C. 3
D. 4
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 3.3.5 Link between Main Storage and CPU | 主存储器和 CPU 的连接
✅02. 80386DX 是 32 位系统，以 4B 为编址单位，当在该系统中用 8KB（8K * 8 位）的存储芯片构造 32KB 的存储体时，应完成存储器的（ ）设计

```
A. 位扩展
B. 字扩展
C. 字位扩展
D. 字位均不扩展
```

```
以 4B 为编制地址，要扩展到 32 KB = 8K*32bit => 8KB*8bit 位扩展即可
```

❓07. 地址总线 A0（高位）～ A15（低位），用 4K * 4 位的存储芯片组成 16KB 存储器，则产生片选信号的译码器的输入地址线应该是（ ）

```
A. A2A3
B. A0A1
C. A12A13
D. A14A15
```

```
4K*4bit = 2^12 * 2^2 => A4-A15 = dataline, A2-A3 = addressline; 16KB = 4K*4bit * 4 * 2; 
```

✅09. 内存按字节编址，地址从 90000H 到 CFFFFH，若用存储容量为 16K * 8 位芯片构成该内存，至少需要的芯片数是（ ）

```
A. 2
B. 4
C. 8
D. 16
```

```
CFFFFH - 90000H + 1 = 40000H = 4*16^4 = 256K （*注意，这里已经按照字节编址了，因此每一单元实际为 1B）

256K/16K = 16
```

✅11. 如下图所示，若低位地址（A0～A11）接在内存芯片地址引脚上，高位地址（A12～A19）进行片选译码（其中 A14 和 A16 未参加译码），且片选信号低电平有效，则对图中所示的译码电路，不属于此译码空间的地址是（ ）

```
A19----------| & |
A18--|>=1|---|   |
A17--|   |---|   |
                  o--译码输出
A15----------|   |
A13----------|   |
A12----------|   |

A. AB000H ~ ABFFFH
B. BB000H ~ BBFFFH
C. EF000H ~ EFFFFH
D. FE000H ~ FEFFFH
```

```
A0~A11 = 2^12 
__   _____________________
CS = A19(A18+A17)A15A13A12

     18 16 1412
      | |  | |
AB = 1010 1011 => 101 111 => 11 111
     | |  | |
    19 17 1513

BB = 1011 1011 => 101 111 => 11 111

EF = 1110 1111 => 111 111 => 11 111

FE = 1111 1110 => 111 110 => 11 110
```

✅13. 「2010真题」假定用若干 2K * 4 位的芯片组成一个 8K * 8 位的存储器，则地址 0B1FH 所在芯片的最小地址是（ ）

```
A. 0000H
B. 0600H
C. 0800H
D. 0800H
```

```
8K*8bit = 2K*4bit * 4 * 2 => 2 位扩展 + 4 字扩展 => 每行需要 2 枚芯片，每列需要 4 枚芯片

地址排列如下：
0000H~07FFH
0800H~0FFFH
1000H~17FFH
1800H~1FFFH
```

✅14. 「2011真题」某计算机存储器按字节编址，主存地址空间大小为 64MB，现用 4M * 8 位的 RAM 芯片组成 32MB 的主存储器，则存储器地址寄存器 MAR 的位数至少是（ ）

```
A. 22 位
B. 23
C. 25 位
D. 26
```

```
主存按字节编址 1B = 8bit；主存地址空间大小为 64MB = 2^6 * 2^20 * 2^3 => MAR = 64M = 2^26 => 26bit;

❌：32MB = 2^25 * 2^3 => MAR = 25
```

16. 「2018真题」假定 DRAM芯片中存储阵列的行数为 r、列数为 c，对于一个 2K * 1 位的 DRAM 芯片，为保证其地址引脚最少，并尽量减少刷新开销，则 r、c 的取值分别是（ ）

```
A. 2048,1
B. 64,32
C. 32,64
D. 1,2048
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 3.4.3 External Storage | 外部存储
✅01. 一个磁盘的转速为 7200 r/min，每个磁道有 160 个扇区，每个扇区有 512 字节，则在理想情况下，其数据传输率为（ ）

```
A. 7200 * 160KB/s
B. 7200KB/s
C. 9600KB/s
D. 19200KB/s
```

```
V = rN = (7200/60)r/s * 160r * 0.5KB = 9600KB/s
```

✅04. 「2013真题」某磁盘的转速为 10000r/min，平均寻道时间为 6ms，磁盘传输速率是 20MB/s，磁盘控制器延迟为 0.2ms，读取一个 4KB 的扇区所需的平均时间约为（ ）

```
A. 9ms
B. 9.4ms
C. 12ms
D. 12.4ms
```

```
10000r/min => 60s/10000r => 60000ms/10000r => 6ms/r => T(search)= 6ms/2 = 3ms;

T(read) = 4KB/(20MB/s) = 4KB/(20*10^3KB/1000ms) = 0.2ms;

T = T(read) + T(Search) + T(search) + T(ping) = 0.2ms + 6ms + 3ms + 0.2ms = 9.4ms
```

✅06. 「2015真题」若磁盘转速 7200r/min，平均寻道时间为 8ms，每个磁道包含 1000 个扇区，则访问一个扇区的平均存取时间大约是（ ）

```
A. 8.1ms
B. 12.2ms
C. 16.3ms
D. 20.5ms
```

```
7200r/min => 120r/s => 60*1000/7200 ms/r => 4.17ms/half-r 
(60*1000/7200)/1000 = 0.01ms/block
T=4.17+0.01+8=12.18~12.2ms
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 3.5.6 Cache | 高速缓冲器
✅01. 在高速缓存系统中，主存容量为 12MB，Cache 容量为 400KB，则该存储系统的容量为（ ）

```
A. 12MB + 400KB
B. 12MB
C. 12MB-12MB+400KB
D. 12MB-400KB
```

```
各层次存储系统并非孤立工作，三级存储系统是围绕着主存来组织、管理和调度的。
Cache 里存放的是主存中一部分信息的副本，因此不能认为总容量是两个的加和
```

✅05. 某 32 位计算机的 Cache 容量为 16KB，Cache 行的大小为 16B，若主存与 Cache 地址映像采用直接映像方式，则主存地址为 0x1234E8F8 的单元装入 Cache 的地址是（ ）

```
A. 0001 0001 0011 01
B. 0100 0100 0110 10
C. 1010 0011 1110 00
D. 1101 0011 1010 00
```

```
16KB = 2^14 * 8bit => Cache address line = 14 => 按字节编址

直接映像方式：1234E8F8 = 0001 0010 0011 0100 1110 1000 1111 1000 
                                             |               |
                                             -----------------
                                                    | |
                                             1010 0011 1110 00 => 所求
```

❓07. 某存储系统中，主存容量是 Cache 容量的 4096 倍，Cache 被分为 64 个块，当主存地址和 Cache 地址采用直接映射方式时，地址映射表的大小为（ ）。（假设不考虑一致维护和替换算法位）

```
A. 6*4097bit
B. 64*12bit
C. 6*4096bit
D. 64*13bit
```

```
Cache 被分为 64 块 即拥有 64 行，采用直接映射方式，每一行相当于一组；
标记阵列每行存储 1 个标记项，又主存容量是 Cache 的 4096 = 2^12 倍，即地址长度比 Cache 长 12 位 => 主存标记项为 12 位；
再加上 1 位有效位，因此为 64*13bit
```

❓08. 有效容量为 128KB 的 Cache，每块 16B，采用 8 路组相联。字节地址为 1234567H 的单元调入该 Cache，则其 Tag 应为（ ）

```
A. 1234H
B. 2468H
C. 048DH
D. 12345H
```

```
组相联标记项结构

| 有效位 | 脏位 | 替换控制位 |

Cache 行的存储容量结构

| 有效位 | 标记位 | 每行存储的数据 |

块大小 16B = 2^4 B => 块内地址字段为 4 位；
Cache 容量为 128KB，采用 8 路组相联结构，共有 128KB/(16B*8) = 1024 = 2^10 组，组号字段为 10 位；
剩下位数为标记字段。

1234567H = 0001 0010 0011 0100 0101 0110 0111 
标记字段对应高 14 位 => 0001 0010 0011 01 => 00 0100 1000 1101 = 048DH
```

❓09. 有一主存-Cache 层次的存储器，其主存容量为 1MB，Cache 容量为 16KB，每块有 8 个字，每字 32 位，采用直接地址映像方式，Cache 起始字块为第 0 块，若主存地址为 35301H，且 CPU 访问 Cache 命中，则在 Cache 的第（ ）（十进制表示）字块中。

```
A. 152
B. 153
C. 154
D. 151
```

```
1MB/16KB = 2^6 => 主存字块标记为高 6 位

32B = 2^5B => 字块内地址映射为低 5 位


35301H = 0011 0101 0011 0000 0001 

=> 0011 01 | 01 0011 000 | 0 0001
       |           |          |
    主存字块  Cache 字块地址  字块内映射地址
             8+16+128=152       
```

✅10. 对于由高速缓存、主存、硬盘构成的三级存储体系，CPU 访问该存储系统时发送的地址为（ ）

```
A. 高速缓存地址
B. 虚拟地址
C. 主存物理地址
D. 硬盘地址
```

```
CPU 访存时，先需要查看的是主存地址是否在 Cache 中，因此发送的是主存物理地址；
只有在虚拟存储器中才会发送虚拟地址；
CPU 无法直接访问磁盘地址。
```

❓11. 设有 8 页的逻辑空间，每页有 1024B，他们被映射到 32 块的物理存储区中，则按字节编址逻辑地址的有效位是（ ），物理地址至少是（ ）位

```
A. 10,12
B. 10,15
C. 13,15
D. 13,12
```

```
8 pages = 2^3 pages => 3bit address
1024B/pages = 2^10B/pages => 10bit address/page

=> 13bit logical addresses

10bit address/block
32 blocks = 2^5 blocks => 5bit block

=> 15bit physical addresses
```

❓12. 假设主存地址位数为 32 位，按字节编址，主存和 Cache 之间采用全相联映射方式，主存块大小为 1 个字，每字 32 位，采用回写方式和随机替换策略，则能存放 32K 字数据的 Cache 的总容量至少应有（）位。

```
A. 1536K
B. 1568K
C. 2016K
D. 2048K
```

```
主存块大小 1 个字，32 位，按字节编址，块内地址占 2 位；

全相联映射的方式下，主存地址只有两个字段，标志位为 32-2=30 位；

采用回写法，需要 1 位修改位；

采用随机替换策略，无需替换控制位；

每个 Cache 行的总位数位 32bit（数据位）+ 30bit（标志位）+ 1bit（修改位）+ 1bit（有效位）= 64bit

=> 总容量 = 32K*64bit = 2048Kbit
```

❓13. 假设主存地址按字节编址，Cache 共有 64 行，采用四路组相联映射方式，主存块大小为 32 字节，所有编号都从 0 开始，则第 2593 号存储单元所在主存块的 Cache 组号是（ ）

```
A. 1
B. 17
C. 34
D. 81
```

```
主存块大小为 32 字节，按字节编址 => 块内地址有 5 位；

采用四路组相联映射方式，一共有 64/4 = 16 = 2^4 组 => 组号占 4 位；

2593 = 2048 + 512 + 32 + 1 = 0...0 1010 0010 0001 = 0...0101 0001 00001 
                                                              |     ｜
                                                             组号 块内地址
```

❓14. 假定 CPU 通过存储器总线读取数据的过程为：发送地址和读命令需 1 个时钟周期，存储器准备一个数据需 8 个时钟周期，总线上每传送 1 个数据需 1 个时钟周期。若主存和 Cache 之间交换的主存块大小为 64B，存取宽度和总线宽度都为 8B，则 Cache 的一次确实损失至少为（ ）个时钟周期。

```
A. 64
B. 72
C. 80
D. 160
```

```
一次缺失损失需要从主存读出一个主存块，即 64B，每个总线事务读取 8B，因此需要 8 个总线事务。

每个总线事务所用时间为 1+8+1 = 10 个时钟周期，共需要 80 个时钟周期。

*（建议看完第六章总线再来回顾一次）
```

❓15. 假定采用多模块交叉存储器组织方式，存储器芯片和总线支持突发传送，CPU 通过存储器总线读取数据的过程为：发送首地址和读命令需 1 个时钟周期，存储器准备第一个数据需 8 个时钟周期，随后每个时钟周期总线上传送 1 个数据，可连续传送 8 个数据（即突发长度为 8 ）。若主存和 Cache 之间交换的主存块大小为 64B，存取宽度和总线宽度都为 8B，则 Cache 的一次缺失损失至少为（ ）个时钟周期。

```
A. 17
B. 20
C. 33
D. 80
```

```
同 14 题，建议看完总线事务再来回顾

一次缺失损失需要从主存读出一个主存块，即 64B，每个突发传送总线事务可以读取 8K*8=64B，因此，只需要一个突发传送总线事务。

传送一个突发总线事务所用的时间为 1+8+8=17 个时钟周期。
```

✅17. 「2009真题」某计算机的 Cache 共有 16 块，采用二路组相联映射方式（即每组 2 块）。每个主存块大小为 32B，按字节编址，主存 129 号单元所在主存块应装入的 Cache 组号是（ ）

```
A. 0
B. 2
C. 4
D. 6
```

```
由于 Cache 共有 16 块，采用二路组相联方式，分为 16/2 = 8 组；
主存字块按 模 8 映射到 Cache 组的任意字块（eg: 0,8,16...=> 0）；
每主存块大小为 32B，129/32 = 4 ... 1 => 第 5 组 => 组号为 4

（唐朔飞老师版本《计组》解题思路）
```

❓18. 「2012真题」假设某计算机按字编址，Cache 和主存之间交换的块大小为 1 个字。若 Cache 的内容初始为空，采用二路组相联映射方式和 LRU 替换策略，则访问的主存地址以此为 0,4,8,2,0,6,8,6,4,8 时，命中 Cache 的次数是（ ）

```
A. 1
B. 2
C. 3
D. 4
```

```
采用二路组相联映射，主存地址为 0~1, 4~5, 8~9 可映射到第 0 组，2~3, 6~7 可映射到第 1 组。

再按照置换过程即可
```
| | | 0 | 4 | 8 | 2 | 0 | 6 | 8 | 6 | 4 | 8 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Union 0 | Block 0 | | 0 | 4 | 4 | 8 | 8 | 0 | 0 | 8 | 4 |
| | Block 1 | 0 | 4 | 8 | 8 | 0 | 0 | 8 | 8 | 4 | 8 |
| Union 1 | Block 2 | | | | | | 2 | 2 | 2 | 2 | 2 |
| | Block 3 | | | | 2 | 2 | 6 | 6 | 6 | 6 | 6 | 
```
（蒋本珊老师版本《计组》解题思路）
```

✅19.  「2014真题」采用指令 Cache 与数据 Cache 分离的主要目的是（ ）

```
A. 降低 Cache 的缺失损失
B. 提高 Cache 的命中率
C. 降低 CPU 的平均访存时间
D. 减少指令流水线资源冲突
```

```
将指令 Cache 和数据 Cache 分离后，取指令和取数据分别到不同的 Cache 中寻找，则指令流水线中取指令部分和去数据部分就可以很好地避免冲突，即减少了指令流水线的冲突
```

20. 「2016真题」有如下 C 语言程序段

```C
for(k=0; k<1000; k++) {
    a[k] = a[k]+32;
}
```

若数组 a 和变量 k 均为 int 型，int 型数据占 4B，数据 Cache 采用直接直接映射方式，数据区大小为 1KB，块大小为 16B，该程序段执行前 Cache 为空，则该程序段执行过程中访问数组 a 的 Cache 缺失率约为（ ）

```
A. 1.25%
B. 2.5%
C. 12.5%
D. 25%
```

```

```

✅22. 「2021真题」若计算机主存地址为 32 位，按字节编址，Cache 数据区大小为 32KB，主存块大小为 32B，采用直接映射方式和回写策略，则 Cache 行的位数至少是（ ）

```
A. 275
B. 274
C. 258
D. 257
```

```
Cache 数据区大小为 32KB，主存块的大小为 32B => Cache 中有 1K 个 Cache 行，且物理地址中偏移量部分为 5bits；

采用直接映射方式，将 1K 个 Cache 行映射到 1K 个分组 => 物理地址中的组号部分的长度为 10bit（1024=2^10）；

主存地址为 32bit，除去上述 15bit，还剩 17bit 的标志位；

又因为 Cache 采用回写法，所以 Cache 行的总位数应为 256bit(32B = 32*8bit) + 17bit(标志位) + 1bit(脏位) + 1bit(有效位) = 275bit
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 3.6.6 Virtual Storage | 虚拟存储器
✅02. 虚拟存储管理系统的基础是程序访问的局部性原理，此理论的基本含义是（ ）

```
A. 在程序的执行过程中，程序对主存的访问是不均匀的
B. 空间局部性
C. 时间局部性
D. 代码的顺序执行
```

```
局部性原理：分为时间局部性和空间局部性

在一个程序的执行过程中，其大部分情况下是顺序执行的，某条指令或数据使用后，在最近一段时间内有较大的可能再次被访问（时间局部性）
某条指令或数据使用后，其邻近的指令或数据可能在近期被使用（空间局部性）

在虚拟内容管理系统中，程序只能访问主存获得指令和数据。
```

✅03. 虚拟存储器的常用管理方式有段式、页式、段页式，对于对于它们在与主存交换信息时的单位，以下表述正确的是（ ）

```
A. 段式采用 “页”
B. 页式采用 “块”
C. 段页式采用 “段” 和 “块”
D. 页式和段页式均仅采用 “页”
```

```
本题存在干扰选项 C，段页式看似是采用 “段” 和 “页” 的组合，但本质上是在逻辑上采用结构分段，实际执行采用 “页”
```

✅07. 关于虚拟存储器，下列说法中正确的是（ ）

```
I.   虚拟存储器利用了局部性原理
II.  也是虚拟存储器的页面若很小，主存中存放的页面数较多，导致缺页频率较低，换页次数减少，最终可以提升操作速度
III. 也是虚拟存储器的页面若很大，主存中存放的页面数较少，导致页面调度频率较高，换页次数增加，降低操作速度
IV.  段式虚拟存储器中，段具有逻辑独立性，易于实现程序的编译、管理和保护，也便于多道程序共享

A. I,III,IV 
B. I,II,III
C. I,II,IV
D. II,III,IV
```

```
I.   => CPU 访问存储器，无论是存取指令还是存取数据，所访问的存储单元都是趋于聚集在一个较小的连续区域中，这就是虚拟存储器运行的原理
II.  => 页式虚拟存储器中，页面若很小，虚拟存储器中包含的页面数就会过多，使得页表的体积过大，导致页表本身占据的存储空间过大，使操作速度变慢
III. => 当页面很大时，虚拟存储器中包含的页面数会变少，由于主存的容量比虚拟存储器的容量小，主存中的页面数会更少，每次页面装入的时间会变长，每当需要装入新的页面时，速度会变慢
IV.  => 段式虚拟存储器是按照程序的逻辑性来设计的，具有易于实现程序的编译、管理和保护，也便于多道程序共享的优点
```

❓09. 「2010真题」下列命令组合的一次访存过程中，不可能发生的是（ ）

```
A. TLB 未命中，Cache 未命中，Page 未命中
B. TLB 未命中，Cache 命中，Page 命中
C. TLB 命中，Cache 未命中， Page 命中
D. TLB 命中，Cache 命中，Page 未命中
```

```
命中顺序：
TLB >> Page >> Cache

另外，TLB 存在于 Cache 中，Page 存在于主存中

基于此，有：

命中    命中    命中/缺失    =>  TLB 命中则 Page 一定命中，信息存放在主存中，可能存放在或不在 Cache 中

缺失    命中    命中/缺失    =>  TLB 缺失 但 Page 可能命中，信息存放在主存中，可能存放或不在 Cache 中

缺失    缺失    缺失    =>  TLB 缺失 且 Page 也可能缺失，信息不在主存中，也不在 Cache 中

（根据以上对照表可以解题，但具体原因还需进一步分析）
```

❓10. 「2013真题」某计算机主存地址空间大小为 256MB，按字节编址。虚拟地址空间大小为 4GB，采用页式存储管理，页面大小为 4KB，TLB 采用全相联映射，有 4 个页表项，内容如下表所示。

| 有效位 | 标记 | 页框号 | ... |
| --- | --- | --- | ---|
| 0 | FF180H | 0002H | ... |
| 1 | 3FFF1H | 0035H | ... |
| 0 | 02FF3H | 0351H | ... |
| 1 | 03FFFH | 0153H | ... |

则对虚拟地址 03FF F180H 进行虚实地址变换的结果是（ ）

```
A. 015 3180H
B. 003 5180H
C. TLB 缺失
D. 缺页
```

```
按字节编址，页面大小为 4KB，页内地址共 12 位。地址空间大小为 4GB，虚拟地址共 32 位，前 20 位为页号。

虚拟地址为 03FF F180H，因此页号为 03 FFFH，页内地址为 180H。

查找页标记 03FFFH 所对应的页表项，页框号为 0153H，页框号与页内地址拼装即为物理地址 015 3180H。
```

❓11. 「2015真题」假定编译器将赋值语句 “x=x+3;” 转换为指令 “add xaddr,3”，其中 xaddr 是 x 对应的存储单元地址。若执行该指令的计算机采用页式虚拟存储管理方式，并配有相应的 TLB，且 Cache 使用直写方式，则完成该指令功能需要访问主存的次数至少是（ ）

```
A. 0
B. 1
C. 2
D. 3
```

```
上述执行过程可划分为：取数、运算和写回的过程。

取数时读取 xaddr 可能不需要访问主存而直接访问 Cache，而谢智通方式需要把数据同时写入 Cache 和主存，因此至少访问 1 次
```

✅12. 「2015真题」假定主存地址为 32 位，按字节编址，主存和 Cache 之间采用直接映射方式，主存块大小为 4 个字，每字 32 位，采用回写方式，则能存放 4K 字数据的 Cache 总容量的位数至少是（ ）

```
A. 146K
B. 147K
C. 148K
D. 158K
```

```
直接映射的地址结构为
| 主存字块标记 | Cache 字块标记 | 字块内地址 |

按字节编址，块大小为 4*32bit = 16B = 2^4B => 字块内地址占 4 位；

能存放 4K 字数据的 Cache => Cache 的存储容量为 4K 字（此时 1 字 => 32 位），则 Cache 共有 1K = 2^10 个 Cache 行，Cache 字块标记占 10 位；

主存字块标记占 32-10-4 = 18 位；


Cache 的总容量包括：
存储容量和标记阵列容量（=有效位+标记位+一致性维护位（又称脏位）+替换算法控制位）
                       ｜    ｜         ｜                  ｜
                    一定存在 一定存在  回写法包含           题目未提及

综上，每个 Cache 行标记项包含 18+1+1=20bit；标记阵列容量为 2^10*20bit =20Kbit；存储容量为 4K*32bit= 128Kbit，总容量为 128K+20K=148Kbit
```

❓13. 「2019真题」下列关于缺页处理的叙述中，错误的是（ ）

```
A. 缺页是在地址转换时 CPU 检测到的一种异常
B. 缺页处理由操作系统提供的却也处理程序来完成
C. 缺页处理程序根据页故障地址从外存读入所缺失的页
D. 缺页处理完成后回到发生缺页的指令的下一条指令执行
```

```
在请求分页系统中，每当要访问的页面不在内存中时，CPU 检测到异常，便会产生缺页中断，请求操作系统将所缺的页调入内存。缺页处理有缺页中断处理程序完成，根据发生缺页故障的地址从外存读入所缺失的页，缺页处理完成后回到发生缺页的指令继续执行。

（*注：记得看完《计组》和《操作系统》的中断部分再来回顾）
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

# Chapter 4: Order

## 4.1.5 Formate of Orders | 指令的格式
✅02. 在 CPU 执行指令的过程中，指令的地址由（ ）给出

```
A. 程序计数器（PC）
B. 指令的地址码字段
C. 操作系统
D. 程序员
```

```
PC 存放当前执行指令的地址，而指令的地址码字段则保存操作数地址
```

✅05. 下列指令中不属于程序控制指令的是（ ）

```
A. 无条件转移指令
B. 条件转移指令
C. 中断隐指令
D. 循环指令
```

```
程序控制类指令主要包括无条件转移、有条件转移、子程序调用、返回指令、循环指令等。

中断隐指令是由硬件实现的，并不是指令系统中存在的指令，更不能属于程序控制类指令
```

✅06.  下列指令中应用程序不准使用的指令是（ ）

```
A. 循环指令
B. 转换指令
C. 特权指令
D. 条件转移指令
```

```
特权指令是指仅用于操作系统或其他系统软件的指令。为确保系统与数据安全起见，这类指令不提供给用户使用。
```

✅13. 一个计算机系统采用 32 位单字长指令，地址码为 12 位，若定义了 250 条二地址指令，则还可以有（ ）条单地址指令

```
A. 4K
B. 8K
C. 16K
D. 24K
```

```
地址码为 12 位，操作码长度为 32-12-12 = 8bit（二地址指令）

已定义了 250 条二地址指令，2^8-250 = 6，故可以设计出 6*2^12 = 24K 条
```

✅14. 「2017真题」某计算机按字节编址，指令字长固定且只有两种指令格式，其中三地址指令 29 条，二地址指令 107 条，每个地址字段为 6 位，则指令字长至少应该为（ ）

```
A. 24 位
B. 26 位
C. 28 位
D. 32 位
```

```
假设法，三地址指令 29 = 1 1101 => 至少有 5 位的操作码
2^5-29 = 3

以 5 位计算，二地址多给了 6 位操作码，因此最大数量可以达到 3*2^6 = 192 > 107

=> 最少为 23 位

但计算机按字节编址，因此指令字长应为 8 的整数倍 => 24
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 4.2.3 Method of Find Address | 寻址方式
✅01. 指令系统中采用不同寻址方式的目的是（ ）

```
A. 提供扩展操作码的可能并降低指令译码难度
B. 可缩短指令字长，扩大寻址空间，提高编程的灵活性
C. 实现程序控制
D. 三者都正确
```

```
采用不同的寻址方式目的是为了缩短指令字长，扩大寻址空间，提高编程的灵活性，但因此也提高了指令译码的复杂度。
程序控制则是靠转移指令而非寻址方式实现。
```

✅02. 直接寻址的无条件转移指令的功能是将指令中的地址码送入（ ）

```
A. 程序计数器（PC）
B. 累加器（ACC）
C. 指令寄存器（IR）
D. 地址寄存器（MAR）
```

```
无条件转移指令是指程序转移到新的地址后继续执行，因此必须给出下一条指令的执行地址，并送入程序计数器（PC）

在后面的数据通路部分，可以了解到，无条件指令只有寻址周期和执行周期，其中寻址周期也要将地址码送入 PC 自加 1 来得到下一个地址码
```

✅03. 为了缩短指令中某个地址段的位数，有效的方法是采取（ ）

```
A. 立即寻址
B. 变址寻址
C. 基址寻址
D. 寄存器寻址
```

```
寄存器寻址：需要的地址段位数为 log2(通用寄存器个数)，因此能有效缩短地址段位数

立即寻址：操作数直接保存在指令中，若地址段位数太小，则操作数表示的范围会很小

变址寻址：逻辑表达式为 EA(有效地址)=IX(变址寄存器内容)+A(形式地址) ，A 与主存寻址空间有关

间接寻址：存放的是主存地址
```

✅04. 简化地址结构的基本方法是尽量采用（ ）

```
A. 寄存器寻址
B. 隐地址
C. 直接寻址
D. 间接寻址
```

```
隐地址不给出明显的操作数地址，而在指令中隐含操作数的地址，因此可以简化地址结构（如零地址指令）
```

✅07. 设指令中的地址码为 A，变址寄存器为 X，程序计数器为 PC，则变址间址寻址方式的操作数的有效地址 EA 是（ ）

```
A. ((PC)+A)
B. ((X)+A)
C. (X)+(A)
D. (X)+A
```

```
变址寻址的有效地址为 (X)+A ，再进行间址寻址，即把 (X)+A 中取出的内容作为真实地址 EA => EA=((X)+A)
```

✅09. 堆栈寻址方式中，设 A 为累加器，SP 为堆栈指示器，Msp 为 SP 指示的栈顶单元。若进栈操作的动作是 (A)->Msp, (SP)-1->SP，则出栈操作的动作应为（ ）

```
A. (Msp)->A, (SP)+1->SP
B. (SP)+1->SP, (Msp)->A
C. (SP)-1->SP, (Msp)->A
D. (Msp)->A, (SP)-1->SP
```

```
（结合数据结构中的堆栈以及寻址方式去理解）

进、出堆栈时对栈顶指针的操作顺序是不同的，
进栈时是先压入数据 (A)->Msp, 后修改指针 (SP)-1->SP 
出栈时是先修改指针 (SP)+1->SP, 后弹出数据 (Msp)->A
```

✅10. 相对寻址方式中，指令所提供的相对地址实质上是一种（ ）

```
A. 立即数
B. 内存地址
C. 以本条指令在内存中首地址为基准位置的偏移量
D. 以下条指令在内存中首地址为基准位置的偏移量
```

```
相对寻址的逻辑表达式：EA=(PC)+A => 即从 PC 中取出地址码加上形式地址形成有效地址

执行本条指令时，PC 已完成自加的操作，因此 PC 中保存的是下一条指令的地址，因此以下一条指令的地址为基准位置的偏移量
```

✅12. 指令寻址方式有顺序和跳跃两种，采用跳跃寻址方式可以实现（ ）

```
A. 程序浮动
B. 程序的无条件浮动和条件浮动
C. 程序的无条件转移和条件转移
D. 程序的调用
```

```
跳跃寻址通过转移类指令（如相对寻址）来实现，可用来实现程序的条件或无条件转移
```

✅13. 某机器指令字长为 16 位，主存按字节编址，取指令时，每取一字节，PC 自动加 1，当前指令地址为 2000H，指令内容为相对寻址的无条件转移指令，指令中的形式地址为 40H，则取指令后及执行后 PC 的内容为（ ）

```
A. 2000H, 2042H
B. 2002H, 2040H
C. 2002H, 2042H
D. 2000H, 2040H
```

```
指令字长 16 位，即 2 字节，因此取指令后 PC 的内容为 (PC)+2=2002H;
无条件转移指令将下一条指令地址送至 PC，因此执行后 (PC)+A->PC => 2002H+40H=2042H
```

✅14. 对按字寻址的机器，程序计数器和指令寄存器的位数各取决于（ ）

```
A. 机器字长，存储器的字数
B. 存储器的字数，指令字长
C. 指令字长，机器字长
D. 地址总线宽度，存储器的字数
```

```
机器按字寻址，程序计数器（PC）给出下一条指令字的访存地址（即指令在内存中的地址），因此其取决于存储器的字数；

指令寄存器（IR）用于接收取得的指令，因此取决于指令字长。
```

✅17. 设相对寻址的转移指令占 3B，第一字节为操作码，第二、三字节为相对位移量（补码表示），而且数据在存储器中采用以低字节为字地址的存放方式。每当 CPU 从存储器取出一字节时，即自动完成 (PC)+1->PC。若 PC 的当前值为 240（十进制），要求转移到 290（十进制），则转移指令的第二、三字节的机器代码是（ ）；若 PC 的当前值是 240（十进制），要求转移到 200（十进制），则转移指令的第二、三字节的机器代码是（ ）

```
A. 2FH, FFH
B. D5H, 00H
C. D5H, FFH
D. 2FH, 00H
```

```
使用补码扩充，只需使用符号位补足即可 => 正数补 0，负数补 1

1. 240 -> 243 -> 290 => 相对位移量为 47 = 2FH；因为采用低字节的存放方式，所以 2FH 存放在 第二字节；47 为正数，多余位数补 0，因此第三字节为 00H；

2. 240 -> 243 -> 200 => 相对位移量为 -43 = D5H；因为采用低字节存放方式，所以 D5H 存放在 第二字节；-43 为负数，多余位数补 1，因此第三字节为 FFH；
```

✅19. 「2009真题」某机器字长为 16 位，主存按字节编址，转移指令采用相对寻址，由 2 字节组成，第一字节为操作码字段，第二字节为相对位移量字段。假定取指令时，每取一字节 PC 自动加 1。若某转移指令所在主存地址为 2000H，相对位移量字段的内容为 06H，则该转移指令成功转移后的目标地址是（ ）

```
A. 2006H
B. 2007H
C. 2008H
D. 2009H
```

```
机器字长为 16 位，为 2 字节；转移指令为 2 字节，因此在取指周期时先 +2；
相对寻址，因此 EA=(PC)+A => 2000H+2H=2002H, 2002H+06H=2008H.
```

❓21. 「2011真题」某机器有一个标志寄存器，其中有进位/借位标志 CF，零标志 ZF，符号标志 SF 和溢出标志 OF，条件转移指令 bgt（无符号整数比较大于时转移）的转移条件是（ ）

```
A. CF+OF=1
   __
B. SF+ZF=1
   _____
C. CF+ZF=1
   _____
D. CF+SF=1
```

```
假设两个无符号整数 A、B，bgt 指令会讲 A、B 进行比较，即 A-B；
若 A>B，则 A-B 无进位/借位，同时也不为 0，因此此时 CF、ZF 均为 0；溢出符号 OF 与 标志符号在此均未使用。
```

❓22. 「2013真题」假设变址寄存器 R 的内容为 1000H，指令中的形式地址为 2000H；地址 1000H 中的内容为 2000H，地址 2000H，地址 2000H 中的内容为 3000H，地址 3000H 中的内容为 4000H，则变址寻址方式下访问到的操作数是（ ）

```
A. 1000H
B. 2000H
C. 3000H
D. 4000H
```

```
变址寻址：EA=((IX)+A)=(1000H+2000H)=(3000H)=4000H
```

✅23. 「2014真题」某计算机有 16 个通用寄存器，采用 32 位定长指令字，操作码字段（含寻址方式位）为 8 位，Store 指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址方式。若基址寄存器可使用任意通用寄存器，且偏移量用补码表示，则 Store 指令中偏移量的取值范围是（ ）

```
A. -32768~+32767
B. -32767~+32768
C. -65536~+65535
D. -65535~+65536
```

```
采用 32 位定长指令字，即 4 字节；操作码为 8 位，两个地址码共占用 32-8=24 位；

Store 指令的原操作数和目的操作数分别采用寄存器直接寻址和基址寻址，共有 16 个通用寄存器，因此寻址一个寄存器需要 log2 16=4 位；
其中原操作数使用寄存器直接寻址用掉 4 位，目的操作数采用基址寻址也会用掉 4 位；
留给偏移量的位数还剩 24-4-4=16 位；

偏移量采用补码表示，因此偏移量的取值范围为 -2^(16-1)~2^(16-1)-1 => -32768~+32767
```

✅25. 「2017真题」下列寻址方式中，最适合按下标顺序访问一维数组元素的是（ ）

```
A. 相对寻址
B. 寄存器寻址
C. 直接寻址
D. 变址寻址
```

```
相对寻址：以 PC 为基地址，以指令中的地址为偏移量确定有效地址；

寄存器寻址：在指令中指出需要使用的寄存器；

直接寻址：在指令的地址字段直接指出操作数的有效地址；

变址寻址：将计算机指令中的地址与变址寄存器中的地址相加得到有效地址，指令提供数组首地址，由变址寄存器来定位数据中的各元素
```

✅26. 「2018真题」按字节编址的计算机中，某 double 型数组 A 的首地址为 2000H，使用变址寻址和循环结构访问数组 A，保存数组下标的变址寄存器的初值为 0，每次循环取一个数组元素，其偏移地址为变址值乘以 `sizeof(double)`，取完后变址寄存器的内容自动加 1。若某次循环所取元素的地址为 2100H，则进入该次循环时变址寄存器的内容是（ ）

```
A. 25
B. 32
C. 64 
D. 100
```

```
变址寻址的逻辑表达式：EA=(IX)+A

(IX)=2100H-2000H=100H=256

sizeof(double)=8（双精度浮点数用 8 位字节表示）

数组下标为 256/8=32
```

27. 「2019真题」某计算机采用大端方式，按字节编址。某指令中操作数的机器数为 1234 FF00H，该操作数采用基址寻址方式，形式地址（用补码表示）为 FF12H，基址寄存器的内容为 F000 0000H，则该操作数的 LSB（最低有效字节）所在的地址是（ ）

```
A. F000 FF12H
B. F000 FF15H
C. EFFF FF12H
D. EFFF FF15H
```

```

```

✅28. 「2020真题」某计算机采用 16 位定长指令字格式，操作码位数和寻址方式位数固定，指令系统有 48 条指令，支持直接、间接、立即、相对四种寻址方式。在单地址指令中，直接寻址方式的可寻址范围是（ ）。

```
A. 0~255
B. 0~1023
C. -128~127
D. -512~511
```

```
2^5=32 < 48 < 2^6=48 => 因此 48 位指令需要 6 位操作码字段

4 种寻址方式需要 2 位寻址特征位 <=> 4=2^2

剩下的位数为 16-6-2=8 位 作为地址码，因此寻址方式为 0～255（*主存地址为非负数）
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 4.3.5 Assembly Order | 机器级指令入门
✅01. 假设 R[ax] = FFE8H, R[bx] = 7FE6H，执行指令 "addw %bx, %ax" 后，寄存器的内容和各标志的变化为（ ）

```
A. R[ax] = 7FCEH, OF = 1, SF = 0, CF = 0, ZF = 0
B. R[bx] = 7FCEH, OF = 1, SF = 0, CF = 0, ZF = 0
C. R[ax] = 7FCEF, OF = 0, SF = 0, CF = 1, ZF = 0
D. R[bx] = 7FCEH, OF = 0, SF = 0, CF = 1, ZF = 0
```

```
该指令格式为 AT&T 格式，add 指令的目的寄存器为 ax。add 指令的补码加法过程为：
1111 1111 1110 1000 + 0111 1111 1110 0110 = (1) 0111 1111 1100 1110 = 7FCEH

OF = 0 => 符号不同，因此不会溢出
CF = 1 => 有进位
SF = 0 => 结果符号位为 0
ZF = 0 => 非 0
```

❓02. 假设 R[ax] = 7FE6H, R[bx] = FFE8H，执行指令 "sub bx, ax" 后，寄存器的内容和各标志的变化为（ ）

```
A. R[ax] = 8002H, OF = 0, SF = 1, CF = 0, ZF = 0
B. R[bx] = 8002H, OF = 0, SF = 1, CF = 0, ZF = 0
C. R[ax] = 8002H, OF = 1, SF = 1, CF = 0, ZF = 0
D. R[bx] = 8002H, OF = 1, SF = 1, CF = 0, ZF = 0
```

```
该指令格式为 Intel 格式，sub 指令的寄存器为 bx，sub 指令的补码减法过程为：
                       ___________________
1111 1111 1110 1000 + (0111 1111 1110 0110) = 
1111 1111 1110 1000 + 1000 0000 0001 1011 = (1) 1000 0000 0000 0011 = 8003H

OF = 
CF = 
SF = 1
ZF = 0
```

✅03. 假设 P 为调用过程，Q 为被调用过程，程序在 32 位 x86 处理器上执行，以下是 C 语言过程调用所涉及的操作：
    1. 过程 Q 保存 P 的现场，并为非静态局部变量分配空间
    2. 过程 P 将实参放到 Q 能访问到的地方
    3. 过程 P 将返回地址存放到特定处，并转跳到 Q 执行
    4. 过程 Q 取出返回地址，并转跳回过程 P 执行
    5. 过程 Q 恢复 P 的现场，并释放局部变量所占空间
    6. 执行过程 Q 的函数体

过程调用的正确执行步骤是（ ）

```
A. 2->3->4->1->5->6
B. 2->3->1->4->6->5
C. 2->3->1->6->5->4
D. 2->3->1->5->6->4
```

```
上述的调用过程如下：
1. P 将实参放到 Q 能访问到的地方
2. P 将返回地址存到特定地方，然后将控制转移到 Q
3. Q 保存 P 的现场（即通用寄存器的内容），并为自己的非晶态局部变量分配空间
4. 执行 Q
5. Q 恢复 P 的现场，将返回结果放到 P 能访问到的地方，并释放局部变量所占空间
6. Q 取出返回地址，将控制转移到 P

因此为 2->3->1->6->5->4
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

# Chapter 5: CPU
## 5.1.3 Conception of CPU | 中央处理器概览
✅02. 通用寄存器是（ ）

```
A. 可存放指令的寄存器
B. 可存放程序状态字的寄存器
C. 本身具有技术逻辑与移位逻辑的寄存器
D. 可编程指定多种功能的寄存器
```

```
存放指令的寄存器是指令寄存器；
存放程序状态字寄存器的是程序状态字寄存器；
通用寄存器不一定具有技术逻辑与移位逻辑；
```

✅04. 在 CPU 中，跟踪后继指令的寄存器是（ ）

```
A. 指令寄存器
B. 程序计数器
C. 地址寄存器
D. 状态寄存器
```

```
程序计数器（PC）用于存放下一条指令在主存中的地址
```

✅06. 在所谓的 n 位 CPU 中，n 是指（ ）

```
A. 地址总线线数
B. 数据总线线数
C. 控制总线线数
D. I/O 线数
```

```
数据总线的位数与处理器的位数相同（即机器字长），表示 CPU 一次能处理的数据的位数，即 CPU 的位数
（*注：看完总线再来回顾）
```

✅11. 程序计数器的位数取决于（ ）

```
A. 存储器的容量
B. 机器字长
C. 指令字长
D. 都不对
```

```
程序计数器的内容为指令在主存中的地址，因此程序计数器的位数等于主存地址数，即存储器地址位数，即存储器容量
```

✅13. CPU 中通用寄存器的位数取决于（ ）

```
A. 存储器的容量
B. 指令的长度
C. 机器字长
D. 存储字长
```

```
通用寄存器在主要集成在 CPU 内部，因此和 CPU 位数即机器字长有关
```

✅18. 指令译码是对（ ）进行译码

```
A. 整条指令
B. 指令的操作码字段
C. 指令的地址码字段
D. 指令的地址
```

```
指令包括操作码字段和地址码字段，其中，指令译码器在译码阶段（decode）仅对操作码进行译码，借以确定指令的操作功能
```

❓21. 间址周期结束时，CPU 内寄存器 MDR 中的内容为（ ）

```
A. 指令
B. 操作数地址
C. 操作数
D. 无法确定
```

```
间址周期：(PC)->MAR; 1->R; M(MAR)->MDR, (MDR)->IR; (PC)+1->PC

间址周期的作用是取操作数的有效地址，因此结束后，MDR 内的内容是操作数地址
（*注：结合后面一节内容一起理解）
```

✅22. 「2010真题」下列寄存器中，汇编语言程序员可见的是（ ）

```
A. 存储器地址寄存器（MAR）
B. 程序计数器（PC）
C. 存储器数据寄存器（MDR）
D. 指令寄存器（IR）
```

```
汇编语言程序员可见程序计数器（PC） => 汇编语言可以指定 PC 去改变下一个指令的执行地址

IR,MAR,MDR 是 CPU 的内部工作寄存器
（*注：看完指令执行过程以及数据通路可以回顾）
```

23. 「2016真题」某计算机的主存空间为 4GB，字长为 32 位，按字节编址，采用 32 位字长指令字格式。若指令按字边界对齐存放，则程序计数器（PC）和指令寄存器（IR）的位数至少分别是（ ）

```
A. 30,30
B. 30,32
C. 32,30
D. 32,32
```

```

```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 5.2.4 Execution of Order | 指令的执行过程
✅02. 采用 DMA 方式传递数据时，每传送一个数据就要占用（ ）

```
A. 指令周期
B. 时钟周期
C. 机器周期
D. 存取周期
```

```
指令周期 > 机器周期 > 时钟周期（基本单位）

CPU 从主存中每取出并执行一条指令所需的全部时间称为指令周期；
时钟周期又被称为节拍，是 CPU 操作的最基本单位；
CPU 周期又被称为机器周期，一个机器周期包含若干时钟周期;
存取周期是指存储器进行两次独立的存储器操作（连续两次读/写操作）所需的最小间隔周期

因此传送数据占用一个存取周期
（*注：DMA 在看完中断结构回来回顾）
```

✅04. 指令（ ）从主存中读出

```
A. 总是根据程序计数器
B. 有时根据程序计数器，有时根据转移指令
C. 根据地址寄存器
D. 有时根据程序计数器，有时根据地址寄存器
```

```
CPU 根据程序计数器（PC）的内容从主存取指令。

而转移指令（包括条件和无条件转移指令）也有取指周期和执行周期，因此在取指周期内，数据流向也同样为：
(PC)->MAR;
1->R;
M(MAR)->MDR, (MDR)->IR;
(PC)+1->PC;

因此同样有从 PC 中取指令的情况
```

❓05. 在一条无条件跳转指令的指令周期内，程序计数器（PC）的值被修改了（ ）次

```
A. 1
B. 2
C. 3
D. 不能确定
```

```
一条无条件跳转指令的指令周期只包括「取指周期」和「执行周期」；
而在「取指周期」内，数据流向为：(PC)->MAR; 1->R; M(MAR)->MDR, (MDR)->IR; (PC)+1->PC
PC 的值被修改两次；

而在「执行周期」内，PC 的值不被修改因此为 2 次。
（似乎执行周期内有些问题）

首先在取指周期结束后，PC 的值自动加 1；
在执行周期中，PC 的值被修改到了要跳转的地址。
综上，一条无条件转移指令指令周期内，PC 的值被修改了 2 次
```

✅07. 以下叙述中，错误的是（ ）

```
A. 指令周期的第一个操作是取指令
B. 为例进行取指操作，控制器需要得到相应的指令
C. 取指操作是控制器自动进行的
D. 指令执行是有些操作是相同或相似的
```

```
指令周期的第一个操作是取指周期，即取指令；
取指操作是自动进行的，因此控制器不需要得到相应的指令；
指令执行的有些操作是相同或相似的，详见后面的硬布线控制器设计以及微程序控制器设计。
```

✅12. 以下关于间址周期的描述中，正确的是（ ）

```
A. 所有指令的间址操作都是相同
B. 凡是存储器间接寻址的指令，他们的操作都是相同的
C. 对于存储器间接寻址和寄存器间接寻址，他们的操作是不同的
D. 都不对
```

```
指令的间址分为一次间址、两次间址和多次间址，因此操作是不同的；
存储器间址通过形式地址访存，而寄存器间址内容通过寄存器内容访存，因此不同
```

✅14. 以下叙述中，错误的是（ ）

```
A. 取指操作是控制器固有的功能，不需要在操作码控制下完成
B. 所有指令的取值操作是相同的
C. 在指令长度相同的情况下，所有指令的取值操作是相同的
D. 中断周期是在指令完成后出现的
```

```
不同长度的指令，其取指操作可能不同，如：双字指令、三字指令和单字指令的取指操作不同
```

✅15. （ ）可区分存储单元中存放的是指令还是数据

```
A. 控制器
B. 运算器
C. 存储器
D. 数据通路
```

```
从数据的流向角度来看，在取指阶段（周期），从主存中取出数据到 MAR，再从 MAR 中取出数据到 MDR，在此过程中，用来区分存储单元指令还是数据；
而 MAR、MDR、IR、PC 均属于控制器，因此控制器可区分存储单元中的二进制代码类型。

另外，在取指周期取出的是指令，执行周期可能为数据
（结合下面的 17 题）
```

✅16. 下列说法中，正确的是（ ）

```
I.   指令字长等于机器字长的前提下，取指周期等于机器周期
II.  指令字长等于存储字长的前提下，取指周期等于机器周期
III. 指令字长和机器字长的长度没有任何关系
IV.  为了硬件设计方便，指令字长都和存储字长一样大

A. II,III
B. II,III,IV
C. I,III,IV
D. I,IV
```

```
I. II.   => 指令字长一般取存储字长的整数倍，若指令字长等于存储字长的 2 倍，则需要两次访存，取指周期等于机器周期的 2 倍；
            若指令字长等于存储字长，则取指周期等于机器周期；
III. IV. => 指令字长取决于操作码的长度、操作数地址的长度和操作数地址的个数，而与机器字长无必然联系；
            但为了硬件设计的方便，指令字长一般取字节或存储字长的整数倍，因此不一定和存储字长一样大
```

✅17. 「2009真题」冯·诺伊曼计算机中指令和数据均以二进制形式存放在存储器中，CPU 区分他们的依据是（ ）

```
A. 指令操作码的译码结果
B. 指令和数据的寻址方式
C. 指令周期的不同阶段
D. 指令和数据所在的存储单元
```

```
冯·诺依曼机根据指令周期的不同阶段来区分从存储器中取出的是指令还是数据，取指周期取出的是指令，执行周期取出的是数据
```

✅18. 「2011真题」假定不采用 Cache 和指令预取技术，且机器处于 “开中断” 状态，则在下列有关指令执行的叙述中，错误的是（ ）

```
A. 每个指令周期中 CPU 都至少访问内存一次
B. 每个指令周期一定大于等于一个 CPU 时钟周期
C. 空操作指令的指令周期中任何寄存器的内容都不会被改变
D. 当前程序在每条指令执行结束时都可能被外部中断打断
```

```
由于不采用指令预取技术，因此每个指令周期都去要去指令；
因为不采用 Cache 技术，因此每次去指令都至少访存一次（当指令字长与存储字长相等且按边界对齐时）；

时钟周期是 CPU 最基本的操作单位，而指令周期一般包含数个机器周期，一个机器周期一般包含数个时钟周期，因此每个指令周期必定大于一个时钟周期；

即使是空操作指令，在取指操作结束后，PC 仍会自加 1，因此 PC 程序计数器相关的寄存器的内容会被改变；

由于机器处于 “开中断” 状态，因此在每条指令执行结束时都可能被外部中断打断；
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 5.3.3 数据通路
02. 在单总线的 CPU 中，（ ）

```
A. ALU 的两个输入端及输出端都可与总线相联
B. ALU 的两个输入端可与总线相连，但输出端需通过暂存器与总线相连
C. ALU 的一个输入端可与总线相连，其输出端也可与总线相连
D. ALU 只能有一个输入端可与总线相连，另一输入端需通过暂存器与总线相连
```

05. 「2016真题」单周期处理器中所有指令的指令周期为一个时钟周期。下列关于单周期处理器的叙述中，错误的是（ ）

```
A. 可以采用单总线结构数据通络
B. 处理器时钟频率较低
C. 在指令执行过程中控制信号不变
D. 每条指令的 CPI 为 1
```

06. 「2021真题」下列关于数据通路的叙述中，错误的是（ ）

```
A. 数据通路包含 ALU 等组合逻辑（操作）元件
B. 数据通路包含寄存器等时序逻辑（状态）元件
C. 数据通路不包含用于异常事件检测及响应的电路
D. 数据通路中的数据流动路径由控制信号进行控制
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)
