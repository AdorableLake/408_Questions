# Catalog | 目录
## [Chapter 1 Conception | 概论](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#chapter-1-conception)
[1.2.6](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#126-level-structure--层次结构简述)

[1.3.3 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#133-performance--性能指标)

## [Chapter 2 Data | 数据](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#chapter-2-data)
[2.1.5 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#215-code--numeral-system-编码与数制)

[2.2.7 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#227-calculation--运算方法)

[2.3.3 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#233-calculation-of-float--浮点数的计算)

## [Chapter 3 Storage | 存储器](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#chapter-3-storage)
[3.1.4 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#314-storage-level--存储结构)

[3.2.5 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#325-main-storage--主存储器)

[3.3.5 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#335-link-between-main-storage-and-cpu--主存储器和-cpu-的连接)

[3.4.3 解析已看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#343-external-storage--外部存储)

[3.5.6 解析未看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#356-cache--高速缓冲器)

[3.6.6 解析未看完](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#366-virtual-storage--虚拟存储器)

## [Chapter 4 Order | 指令](url)
[4.1.5](url)

[4.2.3](url)

[4.3.5](url)


# Chapter 1: Conception
## 1.2.6 Level Structure | 层次结构简述
02.  冯·诺依曼机的基本工作方式是（ ）

```
A. 控制流驱动方式
B. 多指令多数据流方式
C. 微程序控制方式
D. 数据流驱动方式
```

03. 下列（ ）是冯·诺依曼机工作方式的基本特点。

```
A. 多指令流单数据流
B. 按地址访问并顺序执行指令
C. 堆栈操作
D. 存储器按内容选择地址
```

04. 以下说法错误的是（ ）

```
A. 硬盘是外部设备
B. 软件的功能与硬件的功能在逻辑上是等效的
C. 硬件实现的功能一般比软件实现具有更高的执行速度
D. 软件的功能不能用硬件取代
```

05. 存放欲执行指令的寄存器是（ ）

```
A. MAR  // 地址寄存器
B. PC   // 程序计数器
C. MDR  // 数据寄存器
D. IR   // 指令寄存器
```

09. 在运算器中，不包含（ ）

```
A. 状态寄存器
B. 数据总线
C. ALU
D. 地址寄存器
```

10. 下列关于 CPU 存取速度的比较中，正确的是（ ）

```
A. Cache > 内存 > 寄存器
B. Cache > 寄存器 > 内存
C. 寄存器 > Cache > 内存
D. 寄存器 > 内存 > Cache
```

14. 关于编译程序和解释程序，下列说法中错误的是（ ）

```
// 解释语言：翻译一条语句立即执行一条语句 ==> 效率低
// 编译语言：翻译完全部语句再执行全部语句 ==> 效率高

A. 编译程序和解释程序的作用都是高级语言转换成机器语言程序
B. 编译程序编译时间较长，运行速度较快
C. 解释程序方法较简单，运行速度也快
D. 解释程序将源程序翻译成机器语言，并且翻译一条以后，立即执行这条语句
```

17. 下列叙述中，正确的是（ ）

```
I.   实际应用程序的测试结果能够全面代表计算机的性能
II.  系列机的基本特性是指令系统向后兼容
III. 软件和硬件在逻辑功能上是等价的

// I.   ==> 很显然错误
// II.  ==> 系列机：具有相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列
// III. ==> 根据冯·诺依曼机的原理，软件和硬件在逻辑上是等效的

A. II
B. III
C. II,III
D. I,II,III
```

20. 关于相联存储器，下列说法中正确的是（ ）

```
A. 只可以按地址寻址
B. 只可以按内容寻址
C. 即可按地址寻址又可按内容寻址
D. 以上说法均不完善
```

22. 「2009真题」冯·诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU 区分它们的依据是（ ）

```
A. 指令操作码的译码结果
B. 指令和数据的寻址方式
C. 指令周期的不同阶段
D. 指令和数据所在的存储单元
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 1.3.3 Performance | 性能指标
❓02. 存储字长是指（ ）

```
A. 存放在一个存储单元中的二进制代码组合
B. 存放在一个存储单元中的二进制代码位数
C. 存储单元的个数
D. 机器指令的位数
```

```
机器字长：计算机位数，即计算机一次能处理的二进制数的长度，为处理整数运算的部件的部件
指令字长：一个指令字中包含的二进制代码位数
存储字长：等于MDR位数
```

❓04. 下列关于机器字长、指令字长和存储字长的说法中，正确的是（ ）

```
I.   三者在数值上总是相等的
II.  三者在数值上可能不等
III. 存储字长是存放在一个存储单元中的二进制代码位数
IV.  数据字长是 MDR 的位数

A. I,III 
B. I,IV
C. II,III
D. II,IV
```

✅05. 32 位微机是指该计算机所用 CPU（ ）

```
A. 具有 32 位寄存器
B. 能同时处理 32 位的二进制数
C. 具有 32 个寄存器
D. 能处理 32 个字符
```

```
机器字长等于32位 => 能同时处理 32 位的二进制数
```

❓10. 计算机中，CPU 的 CPI 与下列（ ）因素无关

```
A. 时钟频率
B. 系统结构
C. 指令集
D. 计算机组织
```

```
CPI 与系统结构、指令集、计算机组织有关，但与时钟频率无关
```

✅14. 下列说法中，正确的是（ ）

```
I.   在微型计算机的广泛应用中，会计电算化属于科学计算方面的应用
II.  决定计算机计算精度的主要技术是计算机字长
III. 计算机 “运算速度” 指标的含义是每秒能执行多少条操作系统的命令
IV.  利用大规模集成电路技术把计算机的运算部件和控制部件做在一块集成电路芯片上，这样的一块芯片称为单片机

A. I,III
B. II,IV
C. II
D. I,III,IV
```

```
I.   => 属于数据处理方面，即应用方面
II.  => 对的
III. => 运算速度是每秒能执行多少条指令
IV.  => 这玩意被称为 CPU（运算部件和控制部件）
```

✅20. 「2017真题」假定计算机 M1 和 M2 具有相同的指令集体系结构（ISA），主频分别为 1.5Ghz 和 1.2GHz。在 M1 和 M2 上运行某基准程序 P，平均 CPI 分别为 2 和 1，则程序 P 在 M1 和 M2 上运行时间的比值是（ ）

```
A. 0.4
B. 0.625
C. 1.6
D. 2.5
```

```
运行时间 = 指令数 * CPI / 主频

比值 = （M1 时间=指令数*2/1.5）/（指令数*1/1.2）=（2/1.5）/（1/1.2） = 1.6
```

✅21. 「2020真题」下列给出的部件中，其位数（宽度）一定与机器字长相同的是（ ）

```
I.   ALU
II.  指令寄存器
III. 通用寄存器
IV.  浮点寄存器

A. I,II
B. I,III
C. II,III
D. II,III,IV
```

```
机器字长：CPU 内部用于整数运算的数据通路的宽度

用于整数运算的部件：ALU，通用寄存器
```

✅22. 「2021真题」2017年公布的全球超级计算机 TOP 500 排名中，我国 “神威·太湖之光” 超级计算机蝉联第一，其浮点运算速度为 93.0146 PFLOPS，说明该计算机每秒钟内完成的浮点操作次数约为（ ）

```
A. 9.3*10^13
B. 9.3*10^15
C. 9.3 千万亿次
D. 9.3 亿亿次
```

```
这题就离谱，为啥前面用幂后面用汉字

10^13 == 十万亿
10^15 == 千万亿
10^16 == 亿亿
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

# Chapter 2: Data
## 2.1.5 Code & Numeral System| 编码与数制
✅01. 下列各种数制的数中，最小的数是（ ）

```
A. (101001)2
B. (101001)BCD
C. (52)8
D. (233)16
```

```
A. (101001)2 = 29H
B. (101001)BCD = 29D
C. (52)8 = 2AH

*BCD 码现在不考了
```

❓14. 对于关于补码和移码关系的叙述中，（ ）是不正确的

```
A. 相同位数的补码和移码表示具有相同的数据表示范围
B. 零的补码和移码表示相同
C. 同一个数的补码和移码表示，其数值部分相同，而符号相反
D. 一般用移码表示浮点数的阶，而补码表示定点整数
```

```
以5位机器字长为例：
[0]补 = 00000 != [0]移 = 2^4 + 0 = 10000
```

❓15. 若[x]补 = 1, x1 x2 x3 x4 x5 x6，其中 xi 取 0 或 1，若要 x > -32，应当满足（ ）

```
A. x1 为 0，其他各位任意
B. x1 为 1，其他各位任意
C. x1 为 1，x2～x6 中至少有一位为 1
D. x1 为 0，x2～x6 中至少有一位为 1
```

```
补码转原码（负数）：符号位不变，数值位全部取反，末位加1
故 x1 一定为 1（取反后是0）
（那么如果 [x]原 = 10000000 呢？）
使用补码表示时，符号位相同的情况下，数值位越大，码值也越大
```

❓16. 设 x 为整数，[x]补 = 1, x1 x2 x3 x4 x5，若要 x < -16，x1～x5 应满足（ ）

```
// 同15

A. x1~x5 至少有一个为 1
B. x1 必须为 0，x2~x5 至少有一个为 1
C. x1 必须为 0，x2～x5 任意
D. x1 必须为 1，x2～x5 任意
```

✅17. 设 x 为真值，x* 为其绝对值，满足 [-x*]补 = [-x]补，当且仅当（ ）

```
// 冷知识：0 不是正数，也不是负数

A. x 任意 
B. x 为正数
C. x 为负数
D. 以上说法都不对
```

❓23. 若寄存器内容为 00000000，若它等于 -128，则为（ ）

```
A. 原码
B. 补码
C. 反码
D. 移码
```

```
寄存器长度为 8，[-128]移 = 2^7+(10000000) = 00000000
```

❓25. 下列为 8 位移码机器数 [x]移，求 [-x]移时，（ ）会发生溢出

```
A. 11111111
B. 00000000
C. 10000000
D. 01111111
```

```
B => -128, -(-128)=128 => 溢出
```

✅27. 在计算机中，通常用来表示主存地址的是（ ）

```
A. 移码
B. 补码
C. 原码
D. 无符号数
```

```
主存地址均为正数，因此采用无符号整数即可
```

✅30. 「2021真题」已知带符号整数用补码表示，变量 x,y,z 的机器数分别为 FFFDH,FFDFH,7FFCH，下列结论中，正确的是（ ）

```
A. 若 x,y,z 为无符号整数，则 z<x<y
B. 若 x,y,z 为无符号整数，则 x<y<z
C. 若 x,y,z 为带符号整数，则 x<y<z
D. 若 x,y,z 为带符号整数，则 y<x<z
```

```
若 x,y,z 为无符号整数，则 x>y>z （因为均是正数）
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 2.2.7 Calculation | 运算方法
✅04. 加法器中每位的进位生成信号 g 为（ ）

```
A. Xi xor Yi 
B. Xi*Yi
C. Xi*Yi*Ci
D. Xi+Yi+Ci
```

```
多位加法器为了加快运算速度而采用了快速进位链，其中包含两个信号：
1. 进位信号 g = Xi*Yi 
2. 进位传递信号 p = Xi xor Yi
```

❓10. 一个 8 位寄存器内的数值为 11001010，进位标志寄存器 C 为 0，若将此 8 位寄存器循环左移（不带进位位）1 位，则该 8 位寄存器和标志寄存器内的数值分别为（ ）

```
A. 1001 0100, 1
B. 1001 0101, 0
C. 1001 0101, 1
D. 1001 0100, 0
```

```
不带进位位的循环左移将最高位进入最低位和标志寄存器 CF 位

*还是不太明白
```

✅13. 16 位补码 0x8FA0 扩展为 32 位应该是（ ）

```
A. 0x0000 8FA0
B. 0xFFFF 8FA0
C. 0xFFFF FFA0
D. 0x8000 8FA0
```

```
16 位扩展为32位，符号位不变，附加位是符号位的扩展。
8FA0 是一个负数，因此附加位均用 1 填补附加位。
```

❓15. 关于模 4 补码，下列说法正确的是（ ）

```
A. 模 4 补码和模 2 补码不同，它更容易检查乘除运算中的溢出问题
B. 每个模 4 补码存储时只需一个符号位
C. 存储每个模 4 补码需要两个符号位
D. 模 4 补码，在算数与逻辑部件中为一个符号位
```

```
1. 模 4 补码
2. 模 2 补码

A：❌ 模 4 补码拥有模 2 补码的全部优点，并且更易检查加减运算中的溢出问题
B：✅ 存储模 4 补码仅需一个符号位，任意正确的数值，其模 4 补码的两个符号位都相同
C：❌ 理由同上
D：❌ 只有在 ALU 中进行运算中才会采用双符号位
```

✅17. 判断加减法溢出时，可采用判断进位的方式，若符号位的进位为 C0，最高位的进位为 C1，则产生溢出的条件是（ ）

```
I.   C0 产生进
II.  C1 产生进位
III. C0、C1 都产生进位
IV.  C0、C1 都不产生进位
V.   C0 产生进位，C1 不产生进位
VI.  C0 不产生进位，C1 产生进位

A. I,II
B. III
C. IV
D. V,VI
```

```
采用进位位来判断溢出时，当最高有效位进位和符号位进位的值不同的时候才产生溢出
1. 正溢出：两个正数相加，当最高有效位产生进位（即：C1 = 1），而符号位不产生进位（即：C0 = 0）
2. 负溢出：两个负数相加，最高有效位不产生进位（即：C1 = 0），而符号位产生进位（即：C0 = 1）
```

✅19. 若 [X]补 = X0.X1X2...Xn，其中 X0 为符号位，X1 为最高数位。若（ ），则当补码左移时，将会发生溢出

```
A. X0 = X1
B. X0 != X1
C. X1 = 0
D. X1 = 1
```

```
溢出判别法适用此种情况：
1. 符号位：由单符号位变成双符号位，然后左移，若两符号位不同则溢出，即 X0 != X1 时溢出；
2. 数值位：最高位进位和符号位进位不同导致溢出，此时 X1 != X0；
综上可知：X1 != X0 会在左移后导致溢出
```

❓22. 在原码一位乘法中，（ ）

```
A. 符号位参加运算
B. 符号位不参加运算
C. 符号位参加运算，并根据运算结果改变结果中的符号位
D. 符号位不参加运算，并根据运算结果确定结果中的符号·
```

```
在原码一位乘法中，符号位不参与运算，且单独处理，同号为正，异号为负
（那为啥 D 不对？）
```

✅24. 实现 N 位（不包括符号位）补码一位乘时，乘积为（ ）位

```
A. N
B. N+1
C. 2N
D. 2N+1
```

```
补码一位乘法运算过程中，一共向右移位 N 次，加上原先的 N 位，一共是 2N 位的数值位，又乘积结果需加上一位符号位，因此为 2N+1 位
```

✅25. 在原码不恢复余数法（又称原码加减交替法）的算法中，（ ）

```
A. 每步操作后，若不够减，则需恢复余数
B. 若为负商，则恢复余数
C. 整个算法过程中，从不恢复余数
D. 仅当最后一不够减时，才恢复一次余数
```

```
原码不恢复余数法中，只在最终余数为负时，才需要恢复余数
```

✅26. 下列关于补码除法的说法中，正确的是（ ）

```
A. 补码不恢复除法中，够减商 0，不够减商 1
B. 补码不恢复余数除法中，异号相除时，够减商 0，不够减商 1
C. 补码不恢复除法中，够减商 1，不够减商 0
D. 以上都不对
```

```
补码不恢复余数法中，异号相除时看够不够减，够减商0，不够减商1
```

❓27. 下列关于各种移位的说法正确的是（ ）

```
I.   假设机器数采用反码表示，当机器数为负时，左移时最高数位丢 0，结果出错；右移时最低数位丢 0，影响精度
II.  在算数移位的情况下，补码左移的前提条件是其原最高有效位与原符号位要相同
III. 在算数移位的情况下，双符号位的移位操作只有低符号位需要参加移位操作

A. I,III
B. II
C. III
D. I,II,III
```

```
I.   => 负数的反码的数值位与其原码相反
II.  => 补码表示时，正数符号位为 0，左移最高位为 0时，数据不会丢失；负数符号位为 1，左移最高位为 1时，数据不会丢失
III. => 双符号位表示时，只有最高符号位表示真正的符号，低符号位用于参与移位操作以判断是否发生溢出，如 01 表示正溢出，10 表示负溢出
```

✅29. 某计算机字长为 8 位，CPU 中有一个 8 位加法器。已知无符号数 x = 69，y = 38，如果在该加法器中计算 x-y，则加法器的两个输入端信息和输入的低位进位信息分别为（ ）

```
A. 0100 0101, 0010 0110, 0
B. 0100 0101, 1101 1001, 1
C. 0100 0101, 1101 1010, 0
D. 0100 0101, 1101 1010, 1
```

```
[x]补 = 0100 0101, [y]补 = 0010 0110, [-y]补 = 1101 1010 [-y]原 = 1010 0110, [-y]补 = 1101 1010

[x-y]补 = 0100 0101 + 1101 1001 + 1 = 0001 1111;
```

✅31. 某 8 位计算机中，x 和 y 是两个带符号整数，用补码表示，[x]补 = 44H，[y]补 = DCH，则 x/2 + 2y 的机器数及相应的溢出标志 OF 分别是（ ）

```
A. CAH,0
B. CAH,1
C. DAH,0
D. DAH,1
```

```
[x/2 + 2y]补 = [x]补 >> 1 + [y]补 << 1 = 0100 0100 >> 1 + 1101 1100 << 1 = 0010 0010 1011 1000 = 1101 1010 = DAH（这都是啥？ => 哦懂了）

[x]补 = 44H = 0100 0100 => [x]原 = 0100 0100 = 68 => [x/2] = 34 => [x/2]原/补 = 0010 0010 

[y]补 = DCH = 1101 1100 => [y]原 = 1010 0100 = -38 => [2y] = -76 => [2y]原 = 1100 1000 => [2y]补 = 1011 1000

[x/2 + 2y]补 = 0010 0010 + 1011 1000 = 1101 1010 => DAH
并且真值为 -42，未溢出，OF 为 0
```

34. 「2012真题」某计算机存储器按字节编址，采用小端方式存放数据。假定编译器规定 int 和 short 型长度分别为 32 位和 16 位，并且数据按边界对齐存储。某 C 语言程序段如下：

```C
struct {
    int a;
    char b;
    short c;
} record;
record.a = 273;
```

若 record 变量的首地址为 0xC008，地址 0xC008 中的内容及 record.c 的地址分别为（ ）。

```
A. 0x00,0xC00D
B. 0x00,0xC00E
C. 0x11,0xC00D
D. 0x11,0xC00E
```

```

```

✅35. 「2012真题」假定编译器规定 int 和 short 类型长度分别为 32 位和 16 位，执行下列 C 语言语句（ ）

```C
unsigned short x=65530;
unsigned int y=x;
```

```
A. 0000 7FFAH
B. 0000 FFFAH
C. FFFF 7FFAH
D. FFFF FFFAH
```

```
16 位 unsigned short 转换为 32 位 unsigned int，unsigned = 无符号数 => 新形式的高位用 0 填充

unsigned short max = 65535 = FFFFH => x = 65530 = FFFFH - 5H = FFFAH => y = 0000 FFFAH
```

❓36. 「2013真题」某字长为 8 位的计算机中，已知整型变量 x、y 的机器数分别为 [x]补 = 1 1110100, [y]补 = 1 0110000。若整型变量 z = 2x + y/2，则 z 的机器数为（ ）

```
A. 1 1000000
B. 0 0100100
C. 1 0101010
D. 溢出
```

```
[x]补 = 1 1110100, [y]补 = 1 0110000
[2x]补 = 1 1101000（算数左移）；[y/2]补 = 1 1011000（算数右移） => 均未损失精度或溢出
[2x + y/2] = 1 110 1000 + 1 101 1000 = 1 100 0000（怎么就没溢出呢）
```

❓38. 「2016真题」有如下 C 语言程序段

```C
short si = -32767;
unsigned short usi = si;
```

执行上述两条语句后，usi 的值为

```
A. -32767
B. 32767
C. 32768
D. 32769
```

```
C 语言中的数据在内存中使用补码表示，si 对应的数值的补码表示为 1000 0000 0000 0001；
而由 signed 型转化为等长的 unsigned 型数据时，符号位为数据的一部分，即将负数转化为无符号数，数值会发生变化。
因此二进制码一致，但符号位默认为零，此时 1000 0000 0000 0001 = 2^15 + 1
```

✅41. 「2018真题」某 32 位计算机按字节编址，采用小端方式。若语句 “int i=0;” 对应指令的机器代码为 “C7 45 FC 00 00 00”，则语句 “int i=-64;” 对应指令的机器代码是（ ）

```
A. C7 45 FC C0 FF FF FF
B. C7 45 FC 0C FF FF FF
C. C7 45 FC FF FF FF C0
D. C7 45 FC FF FF FF 0C
```

```
按字节编址，采用小端方式，低位的数据存储在低地址位，高位的数据存储在高地址位，并且按照一字节相对不变的顺序存储。
存储 0 的位数是后 32 位，则只需将 -64 的补码按字节存储在其中即可。 
-64 = FFFF FFC0H
按照小端方式则为：C0 FF FF FF => A
```

✅42. 「2018真题」整数 x 的机器数为 1101 1000，分别对 x 进行逻辑右移 1 位和算数右移 1 位操作，得到的机器数各是（ ）

```
A. 1110 1100, 1110 1100
B. 0110 1100, 1110 1100
C. 1110 1100, 0110 1100
D. 0110 1100, 0110 1100
```

```
逻辑移位：
无论左移还是右移，空位均补 0，且所有数字参与移动（包括符号位）；

算数移位：
符号位不参与移动，右移空位补符号位，左移空位补 0.
```

❓43. 「2018真题」减法指令 "sub R1,R2,R3" 的功能为 "(R1)-(R2)->(R3)"，该指令执行后将生成错位/借位标志 CF 和溢出标志 OF。若 (R1) = FFFF FFFFH， (R2) = FFFF FFF0H，则该减法指令执行后，CF 与 OF 分别为（ ）

```
A. CF=0,OF=0
B. CF=1,OF=0
C. CF=0,OF=1
D. CF=1,OF=1
```

```
[x]补 - [y]补 = [x]补 + [-y]补
[R1]补 - [R2]补 = [R1]补 + [-R2]补 
[-R2]补 = 0000 0010H => [R1]补 + [-R2]补 最高位进位和符号位进位均为 1

溢出位：当最高位进位和符号位进位的值不相同才会产生溢出 => OF = 0
R1 > R2 => CF = 0 （为啥？）
```

✅44. 「2019真题」考虑以下 C 语言代码

```C
unsigned short usi = 65535;
short si = usi;
```
执行上述程序段后，si 的值是（ ）

```
A. -1
B. -32767
C. -32768
D. -65535
```

```
unsigned short => 无符号整数
short => 带符号整数

65535 = 2^16 - 1 = 1111 1111 1111 1111 （无符号整数最大值）
short si = 1111 1111 1111 1111 => 带符号补码 => 1000 0000 0000 0001 = -1
```

✅45. 「2020真题」在按字节编址，采用小端方式的 32 位计算机中，按边界对齐方式为以下 C 语言结构型变量 a 分配存储空间

```C
struct record {
    short x1;
    int x2;
} a;
```

若 a 的首地址位为 2020 FE00H，a 的成员变量 x2 的机器数为 1234 0000H，则其中 34H 所在存储单元的地址是（ ）

```
A. 2020 FE03H
B. 2020 FE04H
C. 2020 FE05H
D. 2020 FE06H
```

```
short => 2B, int => 4B

| 2020 FE00H | 2020 FE01H | 2020 FE02H | 2020 FE03H |
    x1(LSB)      x1(MSB)

| 2020 FE04H | 2020 FE05H | 2020 FE06H | 2020 FE07H |
    x2(LSB)                                 x2(MSB)

34H => 2020 FE06H                
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 2.3.3 Calculation of Float | 浮点数的计算
✅03. 长度相同但格式不同的两种浮点数，假设前者基数大，后者基数小，其他规定均相同，则它们可表示的数的范围和精度为（ ）

```
A. 两者可表示的数的范围和精度相同
B. 前者可表示的数的范围大但精度低
C. 后者可表示的数的范围大且精度高
D. 前者可表示的数的范围大且精度高
```

```
基数越大，范围越大，但精度越低
```

✅05. 在规格化浮点运算中，若某浮点数为 2^5 * 1.10101，其中尾数为补码表示，则该数（ ）

```
A. 不需规格化
B. 需右移规格化
C. 需将尾数左移一位规格化
D. 需将尾数左移两位规格化
```

```
浮点数的规格化：尾数为补码表示，且为 1.0xxxx 形式时为规格化数。

本题中，尾数为 1.10101，需左移一位成为 1.0101，同时阶码减一变成 4
```

✅10. 按照 IEEE 754 标准规定的 32 位单精度浮点数 41A4C000H 对应的十进制数是（ ）

```
A. 4.59375
B. -20.59375
C. -4.59375
D. 20.59375
```

```
41A4 C000H = 0 10000011 01001001100000000000000 = 10100.10011 = 16+4+(2^-1)+(2^-4)+(2^-5)=20+0.5+0.0625+0.03125=20.59375
             |    ||                ||
           符号位  阶码（移码表示）    1.010010011
             +    ｜
                  2^7 + 3 - 127 = 4（？我算的 3；没事了）
```

✅12. 如果某单精度浮点数、某原码、某补码、某移码的 32 位机器数为 0xF0000000，这些数从大到小的顺序是（ ）

```
A. 浮原补移
B. 浮移补原
C. 移原补浮
D. 移补原浮
```

```
F000 0000 = 1111 0000 0000 0000 0000 0000 0000 0000
移 => 正数
原、补、浮 => 负数

补：-2^28
原：-(2^30+2^29+2^28)
浮：-1.0*2*97
```

✅16. 假定采用 IEEE 754 标准中的单精度浮点数格式表示一个数为 45100000H，则该数的值为（ ）

```
A. (+1.125)10 * 2^10
B. (+1.125)10 * 2^11
C. (+0.125)10 * 2^11
D. (+0.125)10 * 2^10
```

```
4510 0000H = 0100 0101 0001 0000 0000 0000 0000 0000 = 0 10001010 00100000000000000000000 = 1.001 * 2^11 = (+1.125)10 * 2^11 => B
                                                       |    ||              ||
                                                       +    11              1.001
```

✅19. 若浮点数的尾数用补码表示，则下列（ ）中的尾数是规格化数形式

```
A. 1.11000
B. 0.01110
C. 0.01010
D. 1.00010
```

```
补码规格化表示时小数点后一位与符号位不同 => D
```

✅21. 下列关于舍入的说法，正确的是（ ）

```
I.   不仅仅只有浮点数需要舍入，定点数在运算时也可能要舍入
II.  在浮点数舍入中，只有左规格化时可能要舍入
III. 在浮点数舍入中，只有右规格化时可能要舍入
IV.  在浮点数舍入中，左、右规格化均可能要舍入
V.   舍入不一定产生误差

A. I,III,V
B. I,II,V
C. V
D. I,IV
```

```
I.              => 舍入只属于浮点数
II./III./IV.    => 舍入有两种情况：对阶，右规格化
V.              => 舍入不一定产生误差，例：11.00 -> 11.0 => 无误差
```

✅22. 「2009真题」浮点数加减运算过程一般包括对阶、尾数运算、规格化、舍入和判断溢出等步骤。设浮点数的阶码和尾数均采用补码表示，且位数分别为 5 和 7 （均含两位符号位）。若有两个数 X = 2^7 * 29/32 和 Y = 2^5 * 5/8，则用浮点数加法计算 X+Y 的最终结果是（ ）

```
A. 00111 1100010
B. 00111 0100010
C. 01000 0010001
D. 发生溢出
```

```
X = 2^7 * 29/32 = 2^2 * 29 = 00111 0011101; Y = 2^5 * 5/8 = 2^2 * 5 = 00101 0010100; 
                               |     |                                  |      |
                              阶码   尾数                               阶码    尾数

X + Y = 2^2 * 34 = 2^2 * (2^5 + 2^1) = 2^8 * 0.10001 = 01000 0010001 => 溢出  
```

✅24. 「2011真题」float 型数据通常用 IEEE 754 单精度格式表示，若编译器将 float 型变量 x 分配在一个 32 位浮点寄存器 FR1 中，且 x = -8.25，则 FR1 中的内容是（ ）

```
A. C104 0000H
B. C242 0000H
C. C184 0000H
D. C1C2 0000H
```

```
x = -8.25 = -(2^3 + 2^-2) = -1000.01 = -0.10001 * 2^3 = 1 10000010 00001000100000000000000 => C104 0000H
```

✅26. 「2013真题」某数采用 IEEE 754 单精度浮点数格式表示为 C640 0000H，则该数的值是（ ）

```
A. -1.5 * 2^13
B. -1.5 * 2^12
C. -0.5 * 2^13
D. -0.5 * 2^12
```

```
C640 0000H = 1100 0110 0100 0000 0000 0000 0000 0000 = 1 10001100 10000000000000000000000 = - 2^13 * 1.1 = -1.5 * 2^13
```

✅30. 「2020真题」已知带符号整数用补码表示，float 型数据用 IEEE 754 标准表示，假定变量 x 的类型只可能是 int 或 float，当 x 的机器数为 C800 0000H 时，x 的值可能是（ ）

```
A. -7 * 2^27
B. -2^16
C. 2^17
D. 25 * 2^27
```

```
C800 0000H = 1100 1000 0000 0000 0000 0000 0000 0000 = 1 10010000 000000000000000000000 = - 2^17 * 1.0 => float

C800 0000H = 1100 1000 0000 0000 0000 0000 0000 0000 = 1 100 1000 0000 0000 0000 0000 0000 0000 = 1 011 1000 0000 0000 0000 0000 0000 0000 = - (2^29 + 2^28 + 2^27) = - 2^27 * (2^2 + 2^1 + 2^1) = - 2^27 * 7 => A 
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

# Chapter 3: Storage
## 3.1.4 Storage Level | 存储结构
✅03. 设机器字长为 32 位，一个容量为 16MB 的存储器，CPU 按半字寻址，其可寻址的单元数是（ ）

```
A. 2^24
B. 2^23
C. 2^22
D. 2^21
```

```
16MB = 2^24B => N = (2^24B) / (2B) = 2^23 = 16M
```

✅04. 相联存储器是按（ ）进行寻址的存储器

```
A. 地址指定方式
B. 堆栈存储方式
C. 内容指定方式和堆栈存储方式相结合
D. 内容指定方式和地址指定方式相结合
```

```
相联存储器：将存储单元所存内容的某一部分作为检索项去检索该存储器，并将存储器中与该检索项符合的存储单元内容进行读出或写入。因此是按照内容指定和地址指定方式相结合的方式进行寻址的存储器
```

✅06. 若某存储器存储周期为 250ns，每次读出 16 位，该存储器的数据传输率是（ ）

```
A. 4 * 10^6 B/s
B. 4 MB/s
C. 8 * 10^6 B/s
D. 8 * 2^20 B/s
```

```
传输速率即带宽，每个存储周期读出 16bit = 2B

BandWidth=(2B)/[250*10^(-9) s]=(8*10^6 B/s)=(8MB/s)

注意区分数据传输中的单位和容量的二进位单位不一样
```

✅07. 设机器字长为 64 位，存储容量为 128MB，若按字编址，它可寻址的单元个数是（ ）

```
A. 16MB
B. 16M
C. 32M
D. 32MB
```

```
64bit = 8B => N = (128MB)/(8B) = (16M) 
128MB = 2^27 * 8bit

N = 2^27 * 8 / 64 = 2^24 = 16M 
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 3.2.5 Main Storage | 主存储器
✅09. 某一 DRAM 芯片，采用地址复用技术，其容量为 1024*8 位，除电源和接地端外，该芯片的引脚数最少是（ ）（读写控制线为两根）

```
A. 16
B. 17
C. 19
D. 21
```

```
1024*8 = 2^10 * 2^3 => N(data) = 10/2 = 5（地址复用技术）; N(address) = 8; N(W/R) = 2; N(S) = 2（行通选+列通选，其中行通选代替片选线）;

N = 5+8+2+2 = 17
```

✅16. 一个四体并行低位交叉存储器，每个模块的容量是 64K*32 位，存取周期为 200ns，总线周期为 50ns，在下属说法中，（ ）是正确的

```
A. 在 200ns 内，存储器能向 CPU 提供 256 位二进制信息
B. 在 200ns 内，存储器能向 CPU 提供 128 位二进制信息
C. 在 50ns 内，每个模块能向 CPU 提供 32 位二进制信息
D. 以上都不对
```

```
低位交叉存储器采用流水线技术，因此该存储器可在一个读写周期内访问 4 个存储模块，因此 32 * 4 = 128 bit

*注：若从第一个字出发，到第四个字读写完成，应为 350ns（200+200-50）
```

✅17. 某机器采用四体低位交叉存储器，现分别执行下述操作：
    1. 读取 6 个连续地址单元存放的存储字，重复 80 次；
    2. 读取 8 个连续地址单元存放的存储字，重复 60 次。

    则 1,2花费时间之比为（ ）

```
A. 1:1
B. 2:1
C. 4:3
D. 3:4
``` 

```
第一种情况：前 79 轮每一轮均需花费 2T 进入下一轮；直到最后一轮，需要花费 1T + 1.25T = 2.25T；总计 79*2T + 2.25T = 160.25T

第二种情况：前 59 轮均需花费 2T 进入下一轮；直到最后一轮，需要等到第 8 个字存取完毕，需：2T + 0.75T = 2.75T；总计：59*2T + 2.75T = 120.75T

160.25/120.75 ～ 4/3 => C
```

✅18. 下列说法中，正确的是（ ）

```
I.   高位多体交叉存储器能很好地满足程序的局部性原理
II.  高位四体交叉存储器可能在一个存储周期内连续访问 4 个模块
III. 双端口存储器可以同时访问同一区间、同一单元
IV.  双端口存储器当两个端口的地址码相同时，必然会发生冲突

A. I,III
B. II,III
C. II,III,IV
D. III,IV
```

```
I.   => 高位多体交叉存储器在单个存储器中的字是连续存储，因此不满足程序的局部性原理
II.  => 高位多体交叉存储器可以在一个周期内访问连续的彼此地址相差一个存储体容量的 4 个字
III. => 双端口存储器可以同时访问同一区间、同一单元
IV.  => 访问时不会发生冲突
```

✅22. 「2014真题」某容量为 256MB 的存储器由若干 4M * 8bit 的 DRAM 芯片构成，该 DRAM 芯片的地址引脚和数据引脚总数是（ ）

```
A. 19
B. 22
C. 30
D. 36
```

```
4M * 8bit => N(data) = 8; N1(address) = log2(4M) = 22; 
DRAM 采用地址复用技术 => N(address) = N1/2 = 11

N = N(data)+N(address)=19
```

25. 「2017真题」某计算机主存按字节编址，由 4 个 64M * 8bit 的 DRAM 芯片采用交叉编址方式构成，并与宽度为 32 位的存储器总线相连，主存每次最多读写 32 位数据，若 double 型 变量 x 的主存地址为 804 001AH，则读取 x 需要的存储周期数是（ ）

```
A. 1
B. 2
C. 3
D. 4
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 3.3.5 Link between Main Storage and CPU | 主存储器和 CPU 的连接
✅02. 80386DX 是 32 位系统，以 4B 为编址单位，当在该系统中用 8KB（8K * 8 位）的存储芯片构造 32KB 的存储体时，应完成存储器的（ ）设计

```
A. 位扩展
B. 字扩展
C. 字位扩展
D. 字位均不扩展
```

```
以 4B 为编制地址，要扩展到 32 KB = 8K*32bit => 8KB*8bit 位扩展即可
```

❓07. 地址总线 A0（高位）～ A15（低位），用 4K * 4 位的存储芯片组成 16KB 存储器，则产生片选信号的译码器的输入地址线应该是（ ）

```
A. A2A3
B. A0A1
C. A12A13
D. A14A15
```

```
4K*4bit = 2^12 * 2^2 => A4-A15 = dataline, A2-A3 = addressline; 16KB = 4K*4bit * 4 * 2; 
```

✅09. 内存按字节编址，地址从 90000H 到 CFFFFH，若用存储容量为 16K * 8 位芯片构成该内存，至少需要的芯片数是（ ）

```
A. 2
B. 4
C. 8
D. 16
```

```
CFFFFH - 90000H + 1 = 40000H = 4*16^4 = 256K （*注意，这里已经按照字节编址了，因此每一单元实际为 1B）

256K/16K = 16
```

✅11. 如下图所示，若低位地址（A0～A11）接在内存芯片地址引脚上，高位地址（A12～A19）进行片选译码（其中 A14 和 A16 未参加译码），且片选信号低电平有效，则对图中所示的译码电路，不属于此译码空间的地址是（ ）

```
A19----------| & |
A18--|>=1|---|   |
A17--|   |---|   |
                  o--译码输出
A15----------|   |
A13----------|   |
A12----------|   |

A. AB000H ~ ABFFFH
B. BB000H ~ BBFFFH
C. EF000H ~ EFFFFH
D. FE000H ~ FEFFFH
```

```
A0~A11 = 2^12 
__   _____________________
CS = A19(A18+A17)A15A13A12

     18 16 1412
      | |  | |
AB = 1010 1011 => 101 111 => 11 111
     | |  | |
    19 17 1513

BB = 1011 1011 => 101 111 => 11 111

EF = 1110 1111 => 111 111 => 11 111

FE = 1111 1110 => 111 110 => 11 110
```

✅13. 「2010真题」假定用若干 2K * 4 位的芯片组成一个 8K * 8 位的存储器，则地址 0B1FH 所在芯片的最小地址是（ ）

```
A. 0000H
B. 0600H
C. 0800H
D. 0800H
```

```
8K*8bit = 2K*4bit * 4 * 2 => 2 位扩展 + 4 字扩展 => 每行需要 2 枚芯片，每列需要 4 枚芯片

地址排列如下：
0000H~07FFH
0800H~0FFFH
1000H~17FFH
1800H~1FFFH
```

✅14. 「2011真题」某计算机存储器按字节编址，主存地址空间大小为 64MB，现用 4M * 8 位的 RAM 芯片组成 32MB 的主存储器，则存储器地址寄存器 MAR 的位数至少是（ ）

```
A. 22 位
B. 23
C. 25 位
D. 26
```

```
主存按字节编址 1B = 8bit；主存地址空间大小为 64MB = 2^6 * 2^20 * 2^3 => MAR = 64M = 2^26 => 26bit;

❌：32MB = 2^25 * 2^3 => MAR = 25
```

16. 「2018真题」假定 DRAM芯片中存储阵列的行数为 r、列数为 c，对于一个 2K * 1 位的 DRAM 芯片，为保证其地址引脚最少，并尽量减少刷新开销，则 r、c 的取值分别是（ ）

```
A. 2048,1
B. 64,32
C. 32,64
D. 1,2048
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 3.4.3 External Storage | 外部存储
✅01. 一个磁盘的转速为 7200 r/min，每个磁道有 160 个扇区，每个扇区有 512 字节，则在理想情况下，其数据传输率为（ ）

```
A. 7200 * 160KB/s
B. 7200KB/s
C. 9600KB/s
D. 19200KB/s
```

```
V = rN = (7200/60)r/s * 160r * 0.5KB = 9600KB/s
```

✅04. 「2013真题」某磁盘的转速为 10000r/min，平均寻道时间为 6ms，磁盘传输速率是 20MB/s，磁盘控制器延迟为 0.2ms，读取一个 4KB 的扇区所需的平均时间约为（ ）

```
A. 9ms
B. 9.4ms
C. 12ms
D. 12.4ms
```

```
10000r/min => 60s/10000r => 60000ms/10000r => 6ms/r => T(search)= 6ms/2 = 3ms;

T(read) = 4KB/(20MB/s) = 4KB/(20*10^3KB/1000ms) = 0.2ms;

T = T(read) + T(Search) + T(search) + T(ping) = 0.2ms + 6ms + 3ms + 0.2ms = 9.4ms
```

✅06. 「2015真题」若磁盘转速 7200r/min，平均寻道时间为 8ms，每个磁道包含 1000 个扇区，则访问一个扇区的平均存取时间大约是（ ）

```
A. 8.1ms
B. 12.2ms
C. 16.3ms
D. 20.5ms
```

```
7200r/min => 120r/s => 60*1000/7200 ms/r => 4.17ms/half-r 
(60*1000/7200)/1000 = 0.01ms/block
T=4.17+0.01+8=12.18~12.2ms
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 3.5.6 Cache | 高速缓冲器
✅01. 在高速缓存系统中，主存容量为 12MB，Cache 容量为 400KB，则该存储系统的容量为（ ）

```
A. 12MB + 400KB
B. 12MB
C. 12MB-12MB+400KB
D. 12MB-400KB
```

```
各层次存储系统并非孤立工作，三级存储系统是围绕着主存来组织、管理和调度的。
Cache 里存放的是主存中一部分信息的副本，因此不能认为总容量是两个的加和
```

✅05. 某 32 位计算机的 Cache 容量为 16KB，Cache 行的大小为 16B，若主存与 Cache 地址映像采用直接映像方式，则主存地址为 0x1234E8F8 的单元装入 Cache 的地址是（ ）

```
A. 0001 0001 0011 01
B. 0100 0100 0110 10
C. 1010 0011 1110 00
D. 1101 0011 1010 00
```

```
16KB = 2^14 * 8bit => Cache address line = 14 => 按字节编址

直接映像方式：1234E8F8 = 0001 0010 0011 0100 1110 1000 1111 1000 
                                             |               |
                                             -----------------
                                                    | |
                                             1010 0011 1110 00 => 所求
```

❓07. 某存储系统中，主存容量是 Cache 容量的 4096 倍，Cache 被分为 64 个块，当主存地址和 Cache 地址采用直接映射方式时，地址映射表的大小为（ ）。（假设不考虑一致维护和替换算法位）

```
A. 6*4097bit
B. 64*12bit
C. 6*4096bit
D. 64*13bit
```

```
Cache 被分为 64 块 即拥有 64 行，采用直接映射方式，每一行相当于一组；
标记阵列每行存储 1 个标记项，又主存容量是 Cache 的 4096 = 2^12 倍，即地址长度比 Cache 长 12 位 => 主存标记项为 12 位；
再加上 1 位有效位，因此为 64*13bit
```

❓08. 有效容量为 128KB 的 Cache，每块 16B，采用 8 路组相联。字节地址为 1234567H 的单元调入该 Cache，则其 Tag 应为（ ）

```
A. 1234H
B. 2468H
C. 048DH
D. 12345H
```

```
组相联标记项结构

| 有效位 | 脏位 | 替换控制位 |

Cache 行的存储容量结构

| 有效位 | 标记位 | 每行存储的数据 |

块大小 16B = 2^4 B => 块内地址字段为 4 位；
Cache 容量为 128KB，采用 8 路组相联结构，共有 128KB/(16B*8) = 1024 = 2^10 组，组号字段为 10 位；
剩下位数为标记字段。

1234567H = 0001 0010 0011 0100 0101 0110 0111 
标记字段对应高 14 位 => 0001 0010 0011 01 => 00 0100 1000 1101 = 048DH
```

❓09. 有一主存-Cache 层次的存储器，其主存容量为 1MB，Cache 容量为 16KB，每块有 8 个字，每字 32 位，采用直接地址映像方式，Cache 起始字块为第 0 块，若主存地址为 35301H，且 CPU 访问 Cache 命中，则在 Cache 的第（ ）（十进制表示）字块中。

```
A. 152
B. 153
C. 154
D. 151
```

```
1MB/16KB = 2^6 => 主存字块标记为高 6 位

32B = 2^5B => 字块内地址映射为低 5 位


35301H = 0011 0101 0011 0000 0001 

=> 0011 01 | 01 0011 000 | 0 0001
       |           |          |
    主存字块  Cache 字块地址  字块内映射地址
             8+16+128=152       
```

✅10. 对于由高速缓存、主存、硬盘构成的三级存储体系，CPU 访问该存储系统时发送的地址为（ ）

```
A. 高速缓存地址
B. 虚拟地址
C. 主存物理地址
D. 硬盘地址
```

```
CPU 访存时，先需要查看的是主存地址是否在 Cache 中，因此发送的是主存物理地址；
只有在虚拟存储器中才会发送虚拟地址；
CPU 无法直接访问磁盘地址。
```

11. 设有 8 页的逻辑空间，每页有 1024B，他们被映射到 32 块的物理存储区中，则按字节编址逻辑地址的有效位是（ ），物理地址至少是（ ）位

```
A. 10,12
B. 10,15
C. 13,15
D. 13,12
```

```

```

12. 假设主存地址位数为 32 位，按字节编址，主存和 Cache 之间采用全相联映射方式，主存块大小为 1 个字，每字 32 位，采用回血方式和随机替换策略，则能存放 32K 字数据的 Cache 的总容量至少应有（）位。

```
A. 1536K
B. 1568K
C. 2016K
D. 2048K
```

13. 假设主存地址按字节编址，Cache 共有 64 行，采用四路组相联映射方式，主存块大小为 32 字节，所有编号都从 0 开始，则第 2593 号存储单元所在主存块的 Cache 组号是（ ）

```
A. 1
B. 17
C. 34
D. 81
```

14. 假定 CPU 通过存储器总线读取数据的过程为：发送地址和读命令需 1 个时钟周期，存储器准备一个数据需 8 个时钟周期，总线上每传送 1 个数据需 1 个时钟周期。若主存和 Cache 之间交换的主存块大小为 64B，存取宽度和总线宽度都为 8B，则 Cache 的一次确实损失至少为（ ）个时钟周期。

```
A. 64
B. 72
C. 80
D. 160
```

15. 假定采用多模块交叉存储器组织方式，存储器芯片和总线支持突发传送，CPU 通过存储器总线读取数据的过程为：发送首地址和读命令需 1 个时钟周期，存储器准备第一个数据需 8 个时钟周期，随后每个时钟周期总线上传送 1 个数据，可连续传送 8 个数据（即突发长度为 8 ）。若主存和 Cache 之间交换的主存块大小为 64B，存取宽度和总线宽度都为 8B，则 Cache 的一次缺失损失至少为（ ）个时钟周期。

```
A. 17
B. 20
C. 33
D. 80
```

17. 「2009真题」某计算机的 Cache 共有 16 块，采用二路组相联映射方式（即每组 2 块）。每个主存块大小为 32B，按字节编址，主存 129 号单元所在主存块应装入的 Cache 组号是（ ）

```
A. 0
B. 2
C. 4
D. 6
```

18. 「2012真题」假设某计算机按字编址，Cache 和主存之间交换的块大小为 1 个字。若 Cache 的内容初始为空，采用二路组相联映射方式和 LRU 替换策略，则访问的主存地址以此为 0,4,8,2,0,6,8,6,4,8 时，命中 Cache 的次数是（ ）

```
A. 1
B. 2
C. 3
D. 4
```

19. 「2014真题」采用指令 Cache 与数据 Cache 分离的主要目的是（ ）

```
A. 降低 Cache 的缺失损失
B. 提高 Cache 的命中率
C. 降低 CPU 的平均访存时间
D. 减少指令流水线资源冲突
```

20. 「2016真题」有如下 C 语言程序段

```C
for(k=0; k<1000; k++) {
    a[k] = a[k]+32;
}
```

若数组 a 和变量 k 均为 int 型，int 型数据占 4B，数据 Cache 采用直接直接映射方式，数据区大小为 1KB，块大小为 16B，该程序段执行前 Cache 为空，则该程序段执行过程中访问数组 a 的 Cache 缺失率约为（ ）

```
A. 1.25%
B. 2.5%
C. 12.5%
D. 25%
```

22. 「2021真题」若计算机主存地址为 32 位，按字节编址，Cache 数据区大小为 32KB，主存块大小为 32B，采用直接映射方式和回写策略，则 Cache 行的位数至少是（ ）

```
A. 275
B. 274
C. 258
D. 257
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)

## 3.6.6 Virtual Storage | 虚拟存储器
02. 虚拟存储管理系统的基础是程序访问的局部性原理，此理论的基本含义是（ ）

```
A. 在程序的执行过程中，程序对主存的访问是不均匀的
B. 空间局部性
C. 时间局部性
D. 代码的顺序执行
```

✅03. 虚拟存储器的常用管理方式有段式、页式、段页式，对于对于它们在与主存交换信息时的单位，以下表述正确的是（ ）

```
A. 段式采用 “页”
B. 页式采用 “块”
C. 段页式采用 “段” 和 “块”
D. 页式和段页式均仅采用 “页”
```

```
本题存在干扰选项 C，段页式看似是采用 “段” 和 “页” 的组合，但本质上是在逻辑上采用结构分段，实际执行采用 “页”
```

07. 关于虚拟存储器，下列说法中正确的是（ ）

```
I.   虚拟存储器利用了局部性原理
II.  也是虚拟存储器的页面若很小，主存中存放的页面数较多，导致缺页频率较低，换页次数减少，最终可以提升操作速度
III. 也是虚拟存储器的页面若很大，主存中存放的页面数较少，导致页面调度频率较高，换页次数增加，降低操作速度
IV.  段式虚拟存储器中，段具有逻辑独立性，易于实现程序的编译、管理和保护，也便于多道程序共享

A. I,III,IV 
B. I,II,III
C. I,II,IV
D. II,III,IV
```

❓09. 「2010真题」下列命令组合的一次访存过程中，不可能发生的是（ ）

```
A. TLB 未命中，Cache 未命中，Page 未命中
B. TLB 未命中，Cache 命中，Page 命中
C. TLB 命中，Cache 未命中， Page 命中
D. TLB 命中，Cache 命中，Page 未命中
```

```
命中顺序：
TLB >> Page >> Cache

另外，TLB 存在于 Cache 中，Page 存在于主存中

基于此，有：

命中    命中    命中/缺失    =>  TLB 命中则 Page 一定命中，信息存放在主存中，可能存放在或不在 Cache 中

缺失    命中    命中/缺失    =>  TLB 缺失 但 Page 可能命中，信息存放在主存中，可能存放或不在 Cache 中

缺失    缺失    缺失    =>  TLB 缺失 且 Page 也可能缺失，信息不在主存中，也不在 Cache 中

（根据以上对照表可以解题，但具体原因还需进一步分析）
```

10. 「2013真题」某计算机主存地址空间大小为 256MB，按字节编址。虚拟地址空间大小为 4GB，采用页式存储管理，页面大小为 4KB，TLB 采用全相联映射，有 4 个页表项，内容如下表所示。

| 有效位 | 标记 | 页框号 | ... |
| --- | --- | --- | ---|
| 0 | FF180H | 0002H | ... |
| 1 | 3FFF1H | 0035H | ... |
| 0 | 02FF3H | 0351H | ... |
| 1 | 03FFFH | 0153H | ... |

则对虚拟地址 03FF F180H 进行虚实地址变换的结果是（ ）

```
A. 015 3180H
B. 003 5180H
C. TLB 缺失
D. 缺页
```

11. 「2015真题」假定编译器将赋值语句 “x=x+3;” 转换为指令 “add xaddr,3”，其中 xaddr 是 x 对应的存储单元地址。若执行该指令的计算机采用页式虚拟存储管理方式，并配有相应的 TLB，且 Cache 使用直写方式，则完成该指令功能需要访问主存的次数至少是（ ）

```
A. 0
B. 1
C. 2
D. 3
```

12. 「2015真题」假定主存地址为 32 位，按字节编址，主存和 Cache 之间采用直接映射方式，主存块大小为 4 个字，每字 32 位，采用回写方式，则能存放 4K 字数据的 Cache 总容量的位数至少是（ ）

```
A. 146K
B. 147K
C. 148K
D. 158K
```

13. 「2019真题」下列关于缺页处理的叙述中，错误的是（ ）

```
A. 缺页是在地址转换时 CPU 检测到的一种异常
B. 缺页处理由操作系统提供的却也处理程序来完成
C. 缺页处理程序根据页故障地址从外存读入所缺失的页
D. 缺页处理完成后回到发生缺页的指令的下一条指令执行
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Computer_Organization/Wangdao_Correction.md#catalog--目录)
