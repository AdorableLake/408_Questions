# Catalog | 目录
## [Chapter 1](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#chapter-1-conception)
### [1.1.4](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#114-conception-of-operating-system--操作系统简述)
### [1.2.7](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#127-kinds-of-os--操作系统的分类)
### [1.3.4](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#134-operation-enviroment--操作系统的运行环境)
### [1.6.2](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#162-structurebootvm--结构引导虚拟机)

## [Chapter 2](url)
### [2.1.8](url)
### [2.2.7](url)
# Chapter 1: Conception
## 1.1.4 Conception of Operating System | 操作系统简述
✅03. 下列选项中，（ ）不是操作系统关心的问题。

```
A. 管理计算机裸机
B. 设计、提供用户程序与硬件系统的界面
C. 管理计算机系统资源
D. 高级程序设计语言的编译器
```

```
审题仔细！
前三项均是操作系统的功能职责
```

✅08. 系统调用是有操作系统提供给用户的，它（ ）

```
A. 直接通过键盘交互方式使用
B. 只能通过用户程序间接使用
C. 是命令接口中的命令
D. 与系统的命令一样
```

```
系统调用是操作系统为应用程序使用内核功能所提供的接口
```

✅13. 操作系统与用户通信接口通常不包括（ ）

```
A. shell
B. 命令解释器
C. 广义指令
D. 缓存管理指令
```

```
shell：命令解析器，也属于命令接口；
命令解释器：属于命令接口
广义指令：即系统调用命令；
缓存管理指令：系统中的缓存全部由操作系统管理，对用户是透明的，操作系统不提供管理系统缓存的系统调用。（即不提供缓存的用户通信接口）
```

✅14. 下列选项中，不属于多道程序设计的基本特征是（ ）

```
A. 制约性
B. 间断性
C. 顺序性
D. 共享性
```

```
引入多道程序设计后，程序的执行就失去了封闭性和顺序性（多道程序：宏观上并行，微观上串行）；
程序执行因为共享资源和相互协同的原因产生了竞争，相互制约，即共享性和制约性；
因为竞争产生的制约性，导致了程序的执行是断续的，即间断性；

顺序性属于淡道程序设计的基本特征
```

16. 「2009真题」单处理机系统中，可并行的是（ ）

```
I.   进程与进程
II.  处理机与设备
III. 处理机与通道
IV.  设备与设备

A. I,II,III
B. I,II,IV
C. I,III,IV
D. II,III,IV
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#114)

## 1.2.7 Kinds of OS | 操作系统的分类
✅01. 提高单机资源利用率的关键技术是（ ）

```
A. 脱机技术
B. 虚拟技术
C. 交换技术
D. 多道程序设计技术
```

```
脱机技术：用于解决独占设备问题；
虚拟技术与交换技术：以多道程序设计技术为前置条件；
多道程序设计技术：在主存中同时运行多个程序，在一个程序等待时，可执行其他程序，因此提高了系统资源的利用率；
```

✅03. 下列选项中，不属于多道程序设计的基本特征的是（ ）

```
A. 制约性
B. 间断性
C. 顺序性
D. 共享性
```

```
参考 1.1.4 14 题
```

✅05. 实时操作系统必须在（ ）内处理来自外部的事件

```
A. 一个机器周期
B. 被控制对象规定时间
C. 周转时间
D. 时间片
```

```
实时操作要求能够实时处理外部事件，即在规定的时间内完成对外部事件的处理
```

✅09. 分时系统的一个重要性能是系统的响应时间，对操作系统的（ ）因素进行改进有利于改善系统的响应时间

```
A. 加大时间片
B. 采用静态页式管理
C. 优先级+非抢占式调度算法
D. 代码可重入
```

```
加大时间片：会延迟系统响应时间；
采用静态页式管理与代码可重入：与系统响应时间无关；
优先级+非抢占式调度算法：即可让重要的作业/进程通过高优先级尽快获得系统响应，又可保证次要的作业/进程在非抢占式调度下不会迟迟得到不到响应，有效改善系统的响应时间。
```

✅16. 「2018真题」下列关于多任务操作系统的叙述中，正确的是（ ）

```
I.   具有并发和并行的特点
II.  需要实现对共享资源的保护
III. 需要运行在多 CPU 的硬件平台上

A. I
B. II
C. I,II
D. I,II,III
```

```
I.   => 多任务操作系统可在同一时间内运行多个应用程序，但在同一时刻单一核心是单一程序（并行和并发）
II.  => 多个任务必须互斥地访问共享资源，为达到这一目的必须对共享资源进行必要的保护；
III. => 现代操作系统基本采用多任务操作系统，但不一定需要多 CPU 的硬件平台
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#127)

## 1.3.4 Operation Enviroment | 操作系统的运行环境
✅04. （ ）是操作系统必须提供的功能

```
A. 图形用户界面（GUI）
B. 为进程提供系统调用命令
C. 中断处理
D. 编译源程序
```

```
中断是操作系统的基础特征之一，因此中断处理是操作系统必须提供的功能
```

✅05. 用户程序在用户态下要使用特权指令引起的中断属于（ ）

```
A. 硬件故障中断
B. 程序中断
C. 外部中断
D. 访管中断
```

```
访管中断的定义

用户态下使用特权指令会从用户态转移至核心态，其中调用的是访管指令（Trap 指令），属于访管中断
```

✅07. 下列操作系统的各个功能组成部分中，（ ）可不需要硬件的支持

```
A. 进程调度
B. 时钟管理
C. 地址映射
D. 中断系统
```

```
进程调度：由调度算法决定 CPU 的使用权，由操作系统决定，不需要硬件支持（参见第二章进程与线程）
时钟管理：需要硬件计数器保持时钟的运行；
地址映射：需要基地址（或页表）寄存器和地址加法器的支持；
中断系统：中断处理的前三步需要中断隐指令完成，这一部分由硬件自动完成。
```

❓09. 计算机区分核心态和用户态指令后，从核心态到用户态的转换是由操作系统程序执行后完成的，而用户态到核心态的转换则是由（ ）完成的

```
A. 硬件
B. 核心态程序
C. 用户程序
D. 中断处理程序
```

```
计算机通过硬件完成操作系统从用户态转移至核心态，这是基于中断机制实现的。
发生中断事件时，触发中断，硬件中断机制将计算机状态置为核心态。
（详细参考《计组》第五、七章以及《操作系统》后续章节）
```

✅13. 在操作系统中，只能在核心态下执行的指令是（ ）

```
A. 读时钟
B. 取数
C. 广义指令
D. 寄存器清 “0”
```

```
广义指令：即系统调用指令，必然工作在核心态；
```

❓18. 「2012真题」下列选项中，不可能在用户态发生的事件是（ ）

```
A. 系统调用
B. 外部中断
C. 进程切换
D. 缺页
```

```
参考后续第二章进程与线程
```

✅20. 「2013真题」下列选项中，会导致用户进程从用户态切换到内核态的操作是（ ）

```
I.   整数除以零
II.  sin() 函数调用
III. read 系统调用

A. I,II
B. I,III
C. II,III
D. I,II,III
```

```
I.   => 属于机器零，内中断
II.  => sin() 函数调用在用户态进行（运算类指令）
III. => read 系统调用属于系统调用的一种，会导致访管中断
```

✅22. 「2015真题」处理外部中断时，应该有操作系统保存的是（ ）

```
A. 程序计数器（PC）的内容
B. 通用寄存器的内容
C. 块表（TLB）中的内容
D. Cache 中的内容
```

```
外部中断处理过程中，PC 值由中断隐指令保存，属于硬件自动完成；
通用寄存器的内容由中断处理程序保存，即操作系统；

块表和 Cache 内容在外部中断中不受影响。
```

✅23. 「2015真题」假定下列指令已装入指令寄存器，则执行时不可能导致 CPU 从用户态变为内核态（系统态）的是（ ）

```
A. DIV R0, R1; (R0)/(R1)->R0
B. INT n; 产生软中断
C. NOT R0; 寄存器 R0 的内容取非
D. MOV R0, addr; 把地址 addr 处的内存数据放入寄存器 R0
```

```
A：除零异常 => 内中断；
B：软中断 => 程序性中断；
C：逻辑取非，无异常；
D：缺页故障 => 外中断。
```

✅25. 「2017真题」执行系统调用的过程包括如下主要操作：

```
1. 返回用户态
2. 执行陷入（trap）指令
3. 传递系统调用参数
4. 执行相应的服务程序

A. 2->3->1->4
B. 2->4->3->1
C. 3->2->4->1
D. 3->4->2->1
```

```
执行系统调用的过程：
正在运行的进程先传递系统调用参数；

由陷入指令负责将用户态转换为内核态，并将返回地址压入堆栈以备后用（即中断处理的保存现场）；

CPU 执行相应的服务程序；

返回用户态；
```

✅26. 「2018真题」定时器产生时钟中断后，由时钟中断服务程序更新的部分内容是（ ）

```
I.   内核中时钟变量的值
II.  当前进程占用 CPU 的时间
III. 当前进程在时间片内的剩余执行时间

A. I,II
B. II,III
C. I,III
D. I,II,III
```

```
时钟中断的重要工作是处理和时间有关的信息及决定是否执行调度程序；

和时间有关的所有信息包括系统时间、进程的时间片、延时、使用 CPU 的时间、各种定时器。
```

🌟27. 「2019真题」下列关于系统调用的叙述中，正确的是（ ）

```
I.   在执行系统调用服务程序的过程中，CPU 处于内核态
II.  操作系统通过提供系统调用避免用户程序直接访问
III. 不同的操作系统为应用程序提供了统一的系统调用接口
IV.  系统调用是操作系统内核内核为应用程序提供服务的接口

A. I,IV
B. I,II,IV
C. III,IV
D. II,III,IV
```

```
I.   => 用户可以在用户态调用操作系统的服务，但执行具体的系统调用服务程序是出于内核态的；
II.  => 设备管理属于操作系统的职责之一，包括但不限于对输入/输出设备的分配、初始化、维护等，用户程序需要通过系统调用使用操作系统的设备管理服务；
III. => 操作系统不同，底层逻辑、实现方式均不相同，为应用程序提供的系统调用接口也不相同；
IV.  => 系统调用是用户在程序中调用操作系统提供的子功能。
```

✅28. 「2020真题」下列与中断相关的操作中，由操作系统完成的是（ ）

```
I.   保存被中断程序的中断点
II.  提供中断服务
III. 初始化中断向量表
IV.  保存中断屏蔽字

A. I,II
B. I,II,IV
C. III,IV
D. II,III,IV
```

```
I => 由中断隐指令完成

其余均由中断服务程序/操作系统完成
```

✅29. 「2021真题」下列指令中，只能在内核态执行的是（ ）

```
A. trap 指令
B. I/O 指令
C. 数据传送指令
D. 设置断点指令
```

```
内核态下，CPU 可执行任何指令（指特权指令和非特权指令都可以）；用户态下，只能执行非特权指令。

A、C、D 均是非特权指令，不能在内核态执行
（相关指令参考后续章节内容）
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#134)

## 1.6.2 Structure/Boot/VM | 结构/引导/虚拟机
✅04. 下列说法中，（ ）不适合描述微内核操作系统

```
A. 内核足够小
B. 功能分层设计
C. 基于 C/S 模式
D. 策略与机制分离
```

```
功能分层设计是分层式 OS 的特点；

通常从四个方面来描述微内核 OS：
1. 内核足够小；
2. 基于客户/服务器模式（即：Customer/Server short as C/S）；
3. 应用 “机制与策略分离” 原理；
4. 采用面向对象技术。
```

✅05. 对于以下五种服务，在采用微内核结构的操作系统中，（ ）不宜放在微内核中

```
I.   进程间通信机制
II.  低级 I/O
III. 低级进程管理和调度
IV.  中断和陷入处理
V.   文件系统服务

A. I,II,III
B. II,V
C. V
D. IV,V
```

```
I.   => 进程/线程间通信功能是微内核最频繁使用的功能，因此几乎所有微内核 OS 都将其放入微内核之中；
II.  => 低级 I/O 与硬件调度紧密相关，需要放入微内核中；
III. => 低级进程管理和调度属于调度功能的机制部分，需要放入微内核之中；
IV.  => 中断和陷入处理是属于操作系统的四大基本特征之一的中断，应放入微内核之中；
V.   => 文件系统服务是微内核之外的文件服务器来实现的，不宜放入微内核中。
```

✅06. 相对于传统操作系统结构，采用微内核结构设计和实现操作系统有诸多好处，下列（ ）是微内核结构的特点

```
I.   使系统更高效
II.  添加系统服务时，不必修改内核
III. 微内核结构没有单一内核稳定
IV.  使系统更可靠

A. I,III,IV
B. I,II,IV
C. II,Iv
D. I,IV
```

```
I.   => 微内核结构 OS 需要频繁地在管态和目态之间切换，OS 的执行开销相对偏大，影响系统效率；
II.  => 是微内核 OS 的优点；
III. => 微内核 OS 由于内核的服务变少，一般来说内核服务越少越稳定；
IV.  => 是微内核 OS 的优点（不会像宏内核/大内核 OS 一样，“牵一发而动全身”）
```

✅07. 下列关于操作系统结构的说法中，正确的是（ ）

```
I.   当前广泛使用的 Windows XP 操作系统，采用的是分层式 OS 结构
II.  模块化的 OS 结构设计的基本原则是，每一层都仅使用其底层所提供的功能和服务，这样就使系统的调试和验证都变得容易
III. 由于微内核结构能有效支持多处理机运行，故非常适合于分布式系统环境
IV.  采用微内核结构设计和实现操作系统句有诸多好处，如添加系统服务时，不必修改内核、使系统更高效

A. I,II
B. I,III
C. III
D. III,IV
```

```
I.   => Windows 及常用 OS 都属于宏内核结构 OS；
II.  => 层次化架构的原则
III. => 微内核结构中，客户与服务器之间、服务器和服务器之间的通信采用消息传递机制，使得微内核系统能很好地支持分布式系统；
IV.  => 添加系统服务时，微内核 OS 确实不需要修改内核，直接放入核外就可以；但微内核 OS 因为频繁通信机制，使得不如宏内核 OS 高效；
```

✅09. 计算机操作系统的引导程序位于（ ）中

```
A. 主板 BIOS
B. 片外 Cache
C. 主存 ROM 区
D. 硬盘
```

```
OS 的引导程序位于磁盘活动分区的引导扇区（即MBR）中。

一般分为两种：
一种位于 ROM 中的 自举程序（BIOS 的组成部分），用于启动具体的设备；
另一种位于装有 OS 硬盘的活动分区的引导扇区中的引导程序（被称为启动管理器），用于引导操作系统；
```

✅10. 计算机的启动过程是（ ）

```
1. CPU 加电，CS:IP 指向 FFFF0H；
2. 进行操作系统引导；
3. 执行 JMP 指令跳转到 BIOS；
4. 登记 BIOS 中断例程入口地址；
5. 硬件自检

A. 1 2 3 4 5
B. 1 3 5 4 2
C. 1 3 4 5 2
D. 1 5 3 4 2
```

```
常见的启动过程：
1. 激活 CPU：
CPU 加电，读取 ROM 中的 boot 程序，将指令寄存器置为 BIOS（Basic Input Output System/基本输入输出系统）的第一条指令，开始执行 BIOS 指令；

2. 硬件自检：
启动 BIOS 后，首先进行硬件自检，检查是否有硬件故障；

3. 加载带有操作系统的硬盘：
硬件自检完成后，BIOS 开始读取 Boot Sequence（通过 CMOS 里保存的启动顺序，或通过与用户的交互），把控制权交给启动顺序排在第一位的存储设备，然后 CPU 将该存储设备引导扇区的内容加载到内存中；

4. 加载主引导记录 MBR：
硬盘以特定的标识符区分引导硬盘和非引导硬盘。若发现一个存储设备不是可引导盘，就检查下一个存储设备；若无其他启动设备，会死机；主引导记录 MBR 的作用是告诉 CPU 操作系统在硬盘的位置；

5. 扫描硬盘分区表，并加载硬盘活动分区

6. 加载分区引导记录 PBR

7. 加载启动管理器

8. 加载操作系统
```

✅12. 下列关于虚拟机的说法中，正确的是（ ）

```
I.   虚拟机可以用软件实现
II.  虚拟机可以用硬件实现
III. 多台虚拟机可同时运行同一物理机器上，它实现了真正的并行

A. I,II
B. I,III
C. I
D. I,II,III
```

```
I. II. => 能用软件实现的，一定能用硬件实现

III.   => 实现真正并行的是多核处理机，多台虚拟机同时运行在同一物理机器上，实现了类似于多个程序运行在同一个系统中
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#162)

## 2.1.8 Process & Thread | 进程和线程
✅02. 下列关于线程的叙述中，正确的是（ ）

```
A. 线程包含 CPU 现场，可以独立执行程序
B. 每个线程有自己独立的地址空间
C. 进程只能包含一个线程
D. 线程之间的通信必须使用系统调用函数
```

```
线程是处理机调度的基本单位，可以独立执行程序；
线程没有自己独立的地址空间，它共享其所属进程的空间；
进程可以创建多个线程；
与进程之间线程的通信可以直接通过他们共享的存储空间；
```

❓04. 进程和程序的根本区别是（ ）

```
A. 静态和动态特点
B. 是不是被调入内存
C. 是不是具有就绪、运行和等待三种状态
D. 是不是占有处理器
```

```
动态性是进程最重要的特性，以此来区分文件形式的静态程序。
操作系统引入进程的概念主要是为了从变化的角度，动态地来分析和研究程序的执行。
（*注：进程的四个特性；动态性（最基本的特征）、并发性、独立性、异步性）
```

✅05. 下面的叙述中，正确的是（ ）

```
A. 进程获得处理运行时通过调度得到的
B. 优先级是进程调度的重要依据，一旦确定不能改动
C. 在单处理器系统中，任何时刻都只有一个进程处于运行态
D. 进程申请处理器而得不到满足时，其状态会变为阻塞态
```

```
B：优先级分为静态优先级和动态优先级；
C：系统发生死锁时，有可能进程全部都处于阻塞态，或无进程任务，即 CPU 空闲；
D：进程申请处理器得不到满足时就处于就绪态，等待处理器的调度
```

✅10. 系统进程所请求的一次 I/O 操作完成后，将使进程状态从（ ）

```
A. 运行态变为就绪态
B. 运行态变为阻塞态
C. 就绪态变为运行态
D. 阻塞态变为就绪态
```

```
可查阅 “进程的阻塞与唤醒” 这一对原语，完成所请求的一次 I/O 操作之后，操作系统会发出唤醒原语，使得进程状态从阻塞态转变为就绪态
```

❓12. 并发进程失去封闭性，是指（ ）

```
A. 多个相对独立的进程以各自的速度向前推进 
B. 并发进程的执行结果与速度无关
C. 并发进程执行时，在不同时刻发生的错误
D. 并发进程共享变量，其执行结果与速度有关
```

```
程序封闭性：指进程执行的结果只取决于进程本身，不受外界影响；
失去封闭性后，不同速度下的执行结果不同；
```

✅14. 进程在处理器上执行时，（ ）

```
A. 进程之间是无关的，具有封闭特性
B. 进程之间都有交互性，相互依赖、相互制约，具有并发性
C. 具有并发性，即同时执行的特性
D. 进程之间可能是无关的，但可能是有交互性的
```

```
进程间有可能具有相关性，也有可能具有独立性；
并发性并不是是指 “同时”；
（进程的四个特征：动态性、并发性、独立性、异步性）
```

🌟19. 支持多道程序设计的操作系统在运行过程中，不端的选择新进程运行来实现 CPU 的共享，但其中（ ）不是引起操作系统选择新进程的直接原因

```
A. 运行的时间片用完
B. 运行进程出错
C. 运行进程要等待某一事件发生
D. 有新进程被创建进入就绪态
```

```
不能进行进程调度与切换的情况：处理中断的过程、访问临界区、原子操作；
应当进行进程调度与切换的情况：时间片用完、运行结束、需要等待事件的发生（如等待键盘响应）、出错、自我阻塞等；

新进程加入就绪队列不是引起调度的直接原因，即使是最高优先级的进程进入就绪队列，也需要考虑是否允许被抢占。
```

🌟20. 若一个进程实体由 PCB、共享正文段、数据堆段和数据栈段组成，请指出下列 C 语言程序中的内容及相关数据结构各位于哪一段中。

```
（ ）I.   全局赋值变量
（ ）II.  为负值的局部变量
（ ）III. 函数调用实参传递值
（ ）IV.  用 malloc() 要求动态分配的存储区
（ ）V.   常量值（如 1995、"string"）
（ ）VI.  进程的优先级

A. PCB
B. 正文段
C. 堆段
D. 栈段
```

```
C 语言编写程序在使用内存是一般分为三个段：正文段（包含代码和赋值数据段）、数据堆段、数据栈段；

正文段：二进制代码和常量（全局赋值变量、常量）；
数据堆段：动态分配的存储区（即 malloc()）；
数据栈段：临时使用的变量（未赋值的局部变量和实参）；
PCB：进程的优先级；
```

✅21. 同一程序经过多次创建，运行在不同的数据集上，形成了（ ）的进程

```
A. 不同
B. 相同
C. 同步
D. 互斥
```

```
一个进程是程序在一个数据集上的一次运行过程。
运行于不同的数据集，将会形成不同的进程。
```

✅22. 系统动态 DLL 库中的唯一标志，下列（ ）不属于 PCB

```
A. 不同
B. 相同
C. 可能不同，有可能相同
D. 不能被调用
```

```
进程是暂时的，程序是永久的（进程是程序的一次执行过程）；
进程是动态的，程序是静态的（动态性是进程的特征之一）；
进程至少由代码、数据、PCB 组成，程序仅需代码和数据即可；
程序代码经过多次创建可对应不同进程，而同一个系统的进程或线程可以由系统调用的方法被不同的进程或线程多次使用。
```

✅23. PCB 是进程存在的唯一标志，下列（ ）不属于 PCB

```
A. 进程 ID
B. CPU 状态
C. 堆栈指针
D. 全局变量
```

```
PCB 包含内容分为四大类：进程标志信息、进程控制信息、进程资源信息、CPU 现场信息；

进程 ID 属于进程标志信息；
CPU 状态属于 CPU 现场信息；
堆栈指针进程资源信息（资源分配清单）；

全局变量属于 C 语言的程序正文段（赋值数据段）
```

✅26. 在一个多道系统中，若就绪队列不空，就绪的进程数目越多，处理器的效率（ ）

```
A. 越高
B. 越低
C. 不变
D. 不确定
```

```
进程就绪数目越多，争夺 CPU 的进程就越多，但只要就绪队列不为空，CPU 总能调度进程运行，保持 CPU 处于繁忙状态；

这与就绪进程的数目没有关系，除非就绪队列为空，此时 CPU 进入等待态，导致 CPU 效率下降。
```

✅33. 在以下描述中，（ ）并不是多线程系统的特长

```
A. 利用线程并行地执行矩阵乘法运算
B. Web 服务器利用线程响应 HTTP 请求
C. 键盘驱动程序为每个正在运行的应用配备一个线程，用以响应该应用的键盘输入
D. 基于 GUI 的调试程序用不同的线程分别处理用户输入、计算和跟踪等操作
```

```
一般而言，整个系统中只有一个键盘，而键盘输入是用户行为，操作较慢（相较于计算机内部硬件而言），完全可以使用一个进程来处理整个系统的键盘输入。
```

✅38. （ ）必会引起进程切换

```
A. 一个进程创建后，进入就绪态
B. 一个进程从运行态变为就绪态
C. 一个进程从阻塞态变成就绪态
D. 以上都不对
```

```
进程切换是指 CPU 调度不同的进程执行，当一个进程从运行态变为就绪态时，CPU 会调度另一个进程执行，引起进程切换
```

✅41. 进程创建时，不需要做的是（ ）

```
A. 填写一个该进程的进程表相
B. 分配该进程适当的内存
C. 将该进程插入就绪队列
D. 为该进程分配 CPU
```

```
进程创建原语完成的工作是：
1. 为进程分配一个唯一的进程标识号，并申请一个空白 PCB；
2. 为进程分配其运行所需的资源；
3. 初始化 PCB；
4. 若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行；

此过程中，创建原语不会包含分配 CPU 的过程（分配资源不包含分配 CPU，因为被分配了 CPU 资源意味着该进程已处于运行态之中）分配 CPU 将由调度程序完成
```

44. 下面关于用户级线程和内核级线程的描述中，错误的是（ ）

```
A. 采用轮转调度算法，进程中设置内核级线程和用户级线程的效果完全不同
B. 跨进程的用户级线程调度也不需要内核参与，控制简单
C. 用户级线程可以在任何操作系统中运行
D. 则处理机的调度对象是进程
```

```

```

❓45. 在内核级线程相对于用户级线程的优点的如下描述中，错误的是（ ）

```
A. 同一进程内的线程切换，系统开销小
B. 当内核线程阻塞时，CPU 将会调度同一进程中的其他内核线程执行
C. 内核级线程的程序实体可以在内核态运行
D. 对多处理器系统，核心可以同时调度同一进程的多个线程并行运行
```

```
内核级线程中，同一进程中的线程切换，需要从用户态转到核心态进行，系统开销较大；

CPU 调度是在内核进行的，在内核级线程中，调度是在线程这一级进行，因此内核可以同时调度同一进程的多个线程在多 CPU 上并行运行（但用户级线程不支持）；

进程中的内核级线程运行在内核态，说明该进程也运行在内核态。
```

✅47. 「2010真题」下列选项中，导致创建新进程的操作是（ ）

```
I.   用户登录成功
II.  设备分配
III. 启动程序运行

A. I,II
B. II,III
C. I,III
D. I,II,III
```

```
I.   => 用户登录成功后，系统要为此创建一个用户管理的进程，包括但不限于用户桌面、环境；所有的用户进程都会在该进程下创建和管理（即用户管理为父进程，其他用户进程属于该进程的子进程）
II.  => 设备分配是通过系统中设置相应的数据结构实现的，不需要创建进程；
III. => 启动程序执行时引起创建进程的典型事件
```

✅48. 「2010真题」下列选项中，降低进程优先级的合理时机是（ ）

```
A. 进程时间片用完
B. 进程刚完成 I/O 操作，进入就绪队列
C. 进程长期处于就绪队列
D. 进程从就绪态转为运行态
```

```
时间片用完，可降低该进程的优先级已让其他进程进入运行态；

进程刚完成 I/O 操作，进入就绪队列等待被处理机（CPU）调度，为尽快让其处理 I/O 结果，应提高优先级；

进程长期处于就绪队列，若不提高该进程的优先级，该进程可能会被 “饿死”；

进程从就绪态转为运行态，此时至少等时间片用完再降低优先级。
```

✅50. 「2012真题」下列关于进程和线程的叙述中，正确的是（ ）

```
A. 不管系统是否支持线程，进程都是资源分配的基本单位
B. 线程是资源分配的基本单位，进程是调度的基本单位
C. 系统级线程和用户级线程的切换都需要内核的支持
D. 同一进程中的更线程拥有各自不同的地址空间
```

```
引入线程后，进程仍然是资源分配的基本单位；
线程是调度的基本单位；
用户级线程中，有关线程管理的所有工作均由应用程序完成，无需内核的干预，内核意识不到该线程的存在，因此不需要内核的支持；
同一进程中的各个线程共享进程的地址空间。
```

⭕️52. 「2014真题」下列关于管道（Pipe）通信的叙述中，正确的是（ ）

```
A. 一个管道可实现双向数据传输
B. 管道的容量仅受磁盘容量大小限制
C. 进程对管道进行毒草做和谐操作都可能被阻塞
D. 一个管道只能一个读进程或一个写进程
```

```

```

✅54. 「2018真题」下列选项中，可能导致当前进程 P 阻塞的事件是（ ）

```
I.   进程 P 申请临界资源
II.  进程 P 从磁盘读数据
III. 系统将 CPU 分配给高优先权的进程

A. I
B. II
C. I,II
D. I,II,III
```

```
进程等待某资源（不包括处理机/CPU）或等待输入/输出完成时，均会进入阻塞态；
系统将 CPU 分配给了高优先权的进程时，当前进程（即进程 P）会进入就绪态。
```

✅55. 「2019真题」下列选项中，可能会将进程唤醒的事件是（ ）

```
I.   I/O 结束
II.  某进程退出临界区
III. 当前进程的时间片用完

A. I
B. III
C. I,II
D. I,II,III
```

```
I.   => 当被阻塞的进程等待的某资源（不包括处理机/CPU）可用时，进程从阻塞态被唤醒；I/O 结束后，等待该 I/O 结束而被阻塞的有关进程会被唤醒；
II.  => 某进程退出临界区后，之前因需要进入该临界区而被阻塞的有关进程会被唤醒；
III. => 当前进程的时间片用后进入就绪队列等待重新调度，优先级最高的进程获得处理机资源从就绪态变成执行态，而不是从阻塞态被唤醒。

*唤醒：指将进程从阻塞态转为就绪态，而不是运行态
```

🌟56. 「2019真题」下列关于线程的描述中，错误的是（ ）

```
A. 内核级线程的调度由操作系统完成
B. 操作系统为每个用户级线程建立一个线程控制块
C. 用户级线程间的切换比内核级线程间的切换效率高
D. 用户级线程可以在不支持内核级线程的操作系统上实现
```

```
应用程序没有进行内核级线程管理的代码，只有一个到内核级线程的编程接口，内核为进程及其内部的每个线程维护上下文信息，调度也是在内核中由操作系统完成的；

当且仅当处于一对一模型时，操作系统才会为每个用户级线程建立一个线程控制块；

用户级线程切换在用户态（用户空间内）完成，而内核级线程的切换依赖操作系统的调度进行完成，因此用户级线程切换效率高；

用户级线程的管理工作可一直在用户空间中进行，因此可以在不支持内核级线程的操作系统上实现（如微内核）
```

✅57. 「2020真题」下列关于父进程与子进程的叙述中，错误的是（ ）

```
A. 父进程与子进程可以并发执行
B. 父进程与子进程共享虚拟地址空间
C. 父进程与子进程有不同的进程控制块
D. 父进程与子进程不能同时使用同一临界资源
```

```
父进程可以与子进程并发执行（最典型的是用户登录成功的案例，创建用户管理进程后，其余的用户进程都基于该用户管理这个父进程并发执行）；

父进程可与子进程共享一部分资源，但不能共享虚拟地址空间（但某进程内的所有线程可以共享该进程的地址空间），在创建子进程时，操作系统会为子进程分配资源，如虚拟地址空间；

PCB 是进程存在的唯一标志，因此即使是父子进程，也拥有各自独立的 PCB；

临界区资源一次只能为一个进程所用；
```
