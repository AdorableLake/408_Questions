# Catalog | 目录
## [Chapter 1](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#chapter-1-conception)
### [1.1.4](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#114-conception-of-operating-system--操作系统简述)
### [1.2.7](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#127-kinds-of-os--操作系统的分类)
### [1.3.4](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#134-operation-enviroment--操作系统的运行环境)
### [1.6.2](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#162-structurebootvm--结构引导虚拟机)

## [Chapter 2](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#chapter-2-process--thread)
### [2.1.8](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#218-process--thread--进程和线程)
### [2.2.7](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#227-dispatch-of-process-and-thread--进程与线程的切换)
### [2.3.8](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#238-synchronization--mutual-exclusion--同步与互斥)
### [2.4.6](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#246-deadlock--死锁)

## [Chapter 3](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#chapter-3-menmory-management)
### [3.1.8](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#318-memory-management--内存管理)
### [3.2.10](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#3210-virtual-memory--虚拟内存)

## [Chapter 4](url)
### [4.1.8](url)

# Chapter 1: Conception
## 1.1.4 Conception of Operating System | 操作系统简述
✅03. 下列选项中，（ ）不是操作系统关心的问题。

```
A. 管理计算机裸机
B. 设计、提供用户程序与硬件系统的界面
C. 管理计算机系统资源
D. 高级程序设计语言的编译器
```

```
审题仔细！
前三项均是操作系统的功能职责
```

✅08. 系统调用是有操作系统提供给用户的，它（ ）

```
A. 直接通过键盘交互方式使用
B. 只能通过用户程序间接使用
C. 是命令接口中的命令
D. 与系统的命令一样
```

```
系统调用是操作系统为应用程序使用内核功能所提供的接口
```

✅13. 操作系统与用户通信接口通常不包括（ ）

```
A. shell
B. 命令解释器
C. 广义指令
D. 缓存管理指令
```

```
shell：命令解析器，也属于命令接口；
命令解释器：属于命令接口
广义指令：即系统调用命令；
缓存管理指令：系统中的缓存全部由操作系统管理，对用户是透明的，操作系统不提供管理系统缓存的系统调用。（即不提供缓存的用户通信接口）
```

✅14. 下列选项中，不属于多道程序设计的基本特征是（ ）

```
A. 制约性
B. 间断性
C. 顺序性
D. 共享性
```

```
引入多道程序设计后，程序的执行就失去了封闭性和顺序性（多道程序：宏观上并行，微观上串行）；
程序执行因为共享资源和相互协同的原因产生了竞争，相互制约，即共享性和制约性；
因为竞争产生的制约性，导致了程序的执行是断续的，即间断性；

顺序性属于淡道程序设计的基本特征
```

16. 「2009真题」单处理机系统中，可并行的是（ ）

```
I.   进程与进程
II.  处理机与设备
III. 处理机与通道
IV.  设备与设备

A. I,II,III
B. I,II,IV
C. I,III,IV
D. II,III,IV
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#114)

## 1.2.7 Kinds of OS | 操作系统的分类
✅01. 提高单机资源利用率的关键技术是（ ）

```
A. 脱机技术
B. 虚拟技术
C. 交换技术
D. 多道程序设计技术
```

```
脱机技术：用于解决独占设备问题；
虚拟技术与交换技术：以多道程序设计技术为前置条件；
多道程序设计技术：在主存中同时运行多个程序，在一个程序等待时，可执行其他程序，因此提高了系统资源的利用率；
```

✅03. 下列选项中，不属于多道程序设计的基本特征的是（ ）

```
A. 制约性
B. 间断性
C. 顺序性
D. 共享性
```

```
参考 1.1.4 14 题
```

✅05. 实时操作系统必须在（ ）内处理来自外部的事件

```
A. 一个机器周期
B. 被控制对象规定时间
C. 周转时间
D. 时间片
```

```
实时操作要求能够实时处理外部事件，即在规定的时间内完成对外部事件的处理
```

✅09. 分时系统的一个重要性能是系统的响应时间，对操作系统的（ ）因素进行改进有利于改善系统的响应时间

```
A. 加大时间片
B. 采用静态页式管理
C. 优先级+非抢占式调度算法
D. 代码可重入
```

```
加大时间片：会延迟系统响应时间；
采用静态页式管理与代码可重入：与系统响应时间无关；
优先级+非抢占式调度算法：即可让重要的作业/进程通过高优先级尽快获得系统响应，又可保证次要的作业/进程在非抢占式调度下不会迟迟得到不到响应，有效改善系统的响应时间。
```

✅16. 「2018真题」下列关于多任务操作系统的叙述中，正确的是（ ）

```
I.   具有并发和并行的特点
II.  需要实现对共享资源的保护
III. 需要运行在多 CPU 的硬件平台上

A. I
B. II
C. I,II
D. I,II,III
```

```
I.   => 多任务操作系统可在同一时间内运行多个应用程序，但在同一时刻单一核心是单一程序（并行和并发）
II.  => 多个任务必须互斥地访问共享资源，为达到这一目的必须对共享资源进行必要的保护；
III. => 现代操作系统基本采用多任务操作系统，但不一定需要多 CPU 的硬件平台
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#127)

## 1.3.4 Operation Enviroment | 操作系统的运行环境
✅04. （ ）是操作系统必须提供的功能

```
A. 图形用户界面（GUI）
B. 为进程提供系统调用命令
C. 中断处理
D. 编译源程序
```

```
中断是操作系统的基础特征之一，因此中断处理是操作系统必须提供的功能
```

✅05. 用户程序在用户态下要使用特权指令引起的中断属于（ ）

```
A. 硬件故障中断
B. 程序中断
C. 外部中断
D. 访管中断
```

```
访管中断的定义

用户态下使用特权指令会从用户态转移至核心态，其中调用的是访管指令（Trap 指令），属于访管中断
```

✅07. 下列操作系统的各个功能组成部分中，（ ）可不需要硬件的支持

```
A. 进程调度
B. 时钟管理
C. 地址映射
D. 中断系统
```

```
进程调度：由调度算法决定 CPU 的使用权，由操作系统决定，不需要硬件支持（参见第二章进程与线程）
时钟管理：需要硬件计数器保持时钟的运行；
地址映射：需要基地址（或页表）寄存器和地址加法器的支持；
中断系统：中断处理的前三步需要中断隐指令完成，这一部分由硬件自动完成。
```

❓09. 计算机区分核心态和用户态指令后，从核心态到用户态的转换是由操作系统程序执行后完成的，而用户态到核心态的转换则是由（ ）完成的

```
A. 硬件
B. 核心态程序
C. 用户程序
D. 中断处理程序
```

```
计算机通过硬件完成操作系统从用户态转移至核心态，这是基于中断机制实现的。
发生中断事件时，触发中断，硬件中断机制将计算机状态置为核心态。
（详细参考《计组》第五、七章以及《操作系统》后续章节）
```

✅13. 在操作系统中，只能在核心态下执行的指令是（ ）

```
A. 读时钟
B. 取数
C. 广义指令
D. 寄存器清 “0”
```

```
广义指令：即系统调用指令，必然工作在核心态；
```

❓18. 「2012真题」下列选项中，不可能在用户态发生的事件是（ ）

```
A. 系统调用
B. 外部中断
C. 进程切换
D. 缺页
```

```
参考后续第二章进程与线程
```

✅20. 「2013真题」下列选项中，会导致用户进程从用户态切换到内核态的操作是（ ）

```
I.   整数除以零
II.  sin() 函数调用
III. read 系统调用

A. I,II
B. I,III
C. II,III
D. I,II,III
```

```
I.   => 属于机器零，内中断
II.  => sin() 函数调用在用户态进行（运算类指令）
III. => read 系统调用属于系统调用的一种，会导致访管中断
```

✅22. 「2015真题」处理外部中断时，应该有操作系统保存的是（ ）

```
A. 程序计数器（PC）的内容
B. 通用寄存器的内容
C. 块表（TLB）中的内容
D. Cache 中的内容
```

```
外部中断处理过程中，PC 值由中断隐指令保存，属于硬件自动完成；
通用寄存器的内容由中断处理程序保存，即操作系统；

块表和 Cache 内容在外部中断中不受影响。
```

✅23. 「2015真题」假定下列指令已装入指令寄存器，则执行时不可能导致 CPU 从用户态变为内核态（系统态）的是（ ）

```
A. DIV R0, R1; (R0)/(R1)->R0
B. INT n; 产生软中断
C. NOT R0; 寄存器 R0 的内容取非
D. MOV R0, addr; 把地址 addr 处的内存数据放入寄存器 R0
```

```
A：除零异常 => 内中断；
B：软中断 => 程序性中断；
C：逻辑取非，无异常；
D：缺页故障 => 外中断。
```

✅25. 「2017真题」执行系统调用的过程包括如下主要操作：

```
1. 返回用户态
2. 执行陷入（trap）指令
3. 传递系统调用参数
4. 执行相应的服务程序

A. 2->3->1->4
B. 2->4->3->1
C. 3->2->4->1
D. 3->4->2->1
```

```
执行系统调用的过程：
正在运行的进程先传递系统调用参数；

由陷入指令负责将用户态转换为内核态，并将返回地址压入堆栈以备后用（即中断处理的保存现场）；

CPU 执行相应的服务程序；

返回用户态；
```

✅26. 「2018真题」定时器产生时钟中断后，由时钟中断服务程序更新的部分内容是（ ）

```
I.   内核中时钟变量的值
II.  当前进程占用 CPU 的时间
III. 当前进程在时间片内的剩余执行时间

A. I,II
B. II,III
C. I,III
D. I,II,III
```

```
时钟中断的重要工作是处理和时间有关的信息及决定是否执行调度程序；

和时间有关的所有信息包括系统时间、进程的时间片、延时、使用 CPU 的时间、各种定时器。
```

🌟27. 「2019真题」下列关于系统调用的叙述中，正确的是（ ）

```
I.   在执行系统调用服务程序的过程中，CPU 处于内核态
II.  操作系统通过提供系统调用避免用户程序直接访问
III. 不同的操作系统为应用程序提供了统一的系统调用接口
IV.  系统调用是操作系统内核内核为应用程序提供服务的接口

A. I,IV
B. I,II,IV
C. III,IV
D. II,III,IV
```

```
I.   => 用户可以在用户态调用操作系统的服务，但执行具体的系统调用服务程序是出于内核态的；
II.  => 设备管理属于操作系统的职责之一，包括但不限于对输入/输出设备的分配、初始化、维护等，用户程序需要通过系统调用使用操作系统的设备管理服务；
III. => 操作系统不同，底层逻辑、实现方式均不相同，为应用程序提供的系统调用接口也不相同；
IV.  => 系统调用是用户在程序中调用操作系统提供的子功能。
```

✅28. 「2020真题」下列与中断相关的操作中，由操作系统完成的是（ ）

```
I.   保存被中断程序的中断点
II.  提供中断服务
III. 初始化中断向量表
IV.  保存中断屏蔽字

A. I,II
B. I,II,IV
C. III,IV
D. II,III,IV
```

```
I => 由中断隐指令完成

其余均由中断服务程序/操作系统完成
```

✅29. 「2021真题」下列指令中，只能在内核态执行的是（ ）

```
A. trap 指令
B. I/O 指令
C. 数据传送指令
D. 设置断点指令
```

```
内核态下，CPU 可执行任何指令（指特权指令和非特权指令都可以）；用户态下，只能执行非特权指令。

A、C、D 均是非特权指令，不能在内核态执行
（相关指令参考后续章节内容）
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#134)

## 1.6.2 Structure/Boot/VM | 结构/引导/虚拟机
✅04. 下列说法中，（ ）不适合描述微内核操作系统

```
A. 内核足够小
B. 功能分层设计
C. 基于 C/S 模式
D. 策略与机制分离
```

```
功能分层设计是分层式 OS 的特点；

通常从四个方面来描述微内核 OS：
1. 内核足够小；
2. 基于客户/服务器模式（即：Customer/Server short as C/S）；
3. 应用 “机制与策略分离” 原理；
4. 采用面向对象技术。
```

✅05. 对于以下五种服务，在采用微内核结构的操作系统中，（ ）不宜放在微内核中

```
I.   进程间通信机制
II.  低级 I/O
III. 低级进程管理和调度
IV.  中断和陷入处理
V.   文件系统服务

A. I,II,III
B. II,V
C. V
D. IV,V
```

```
I.   => 进程/线程间通信功能是微内核最频繁使用的功能，因此几乎所有微内核 OS 都将其放入微内核之中；
II.  => 低级 I/O 与硬件调度紧密相关，需要放入微内核中；
III. => 低级进程管理和调度属于调度功能的机制部分，需要放入微内核之中；
IV.  => 中断和陷入处理是属于操作系统的四大基本特征之一的中断，应放入微内核之中；
V.   => 文件系统服务是微内核之外的文件服务器来实现的，不宜放入微内核中。
```

✅06. 相对于传统操作系统结构，采用微内核结构设计和实现操作系统有诸多好处，下列（ ）是微内核结构的特点

```
I.   使系统更高效
II.  添加系统服务时，不必修改内核
III. 微内核结构没有单一内核稳定
IV.  使系统更可靠

A. I,III,IV
B. I,II,IV
C. II,Iv
D. I,IV
```

```
I.   => 微内核结构 OS 需要频繁地在管态和目态之间切换，OS 的执行开销相对偏大，影响系统效率；
II.  => 是微内核 OS 的优点；
III. => 微内核 OS 由于内核的服务变少，一般来说内核服务越少越稳定；
IV.  => 是微内核 OS 的优点（不会像宏内核/大内核 OS 一样，“牵一发而动全身”）
```

✅07. 下列关于操作系统结构的说法中，正确的是（ ）

```
I.   当前广泛使用的 Windows XP 操作系统，采用的是分层式 OS 结构
II.  模块化的 OS 结构设计的基本原则是，每一层都仅使用其底层所提供的功能和服务，这样就使系统的调试和验证都变得容易
III. 由于微内核结构能有效支持多处理机运行，故非常适合于分布式系统环境
IV.  采用微内核结构设计和实现操作系统句有诸多好处，如添加系统服务时，不必修改内核、使系统更高效

A. I,II
B. I,III
C. III
D. III,IV
```

```
I.   => Windows 及常用 OS 都属于宏内核结构 OS；
II.  => 层次化架构的原则
III. => 微内核结构中，客户与服务器之间、服务器和服务器之间的通信采用消息传递机制，使得微内核系统能很好地支持分布式系统；
IV.  => 添加系统服务时，微内核 OS 确实不需要修改内核，直接放入核外就可以；但微内核 OS 因为频繁通信机制，使得不如宏内核 OS 高效；
```

✅09. 计算机操作系统的引导程序位于（ ）中

```
A. 主板 BIOS
B. 片外 Cache
C. 主存 ROM 区
D. 硬盘
```

```
OS 的引导程序位于磁盘活动分区的引导扇区（即MBR）中。

一般分为两种：
一种位于 ROM 中的 自举程序（BIOS 的组成部分），用于启动具体的设备；
另一种位于装有 OS 硬盘的活动分区的引导扇区中的引导程序（被称为启动管理器），用于引导操作系统；
```

✅10. 计算机的启动过程是（ ）

```
1. CPU 加电，CS:IP 指向 FFFF0H；
2. 进行操作系统引导；
3. 执行 JMP 指令跳转到 BIOS；
4. 登记 BIOS 中断例程入口地址；
5. 硬件自检

A. 1 2 3 4 5
B. 1 3 5 4 2
C. 1 3 4 5 2
D. 1 5 3 4 2
```

```
常见的启动过程：
1. 激活 CPU：
CPU 加电，读取 ROM 中的 boot 程序，将指令寄存器置为 BIOS（Basic Input Output System/基本输入输出系统）的第一条指令，开始执行 BIOS 指令；

2. 硬件自检：
启动 BIOS 后，首先进行硬件自检，检查是否有硬件故障；

3. 加载带有操作系统的硬盘：
硬件自检完成后，BIOS 开始读取 Boot Sequence（通过 CMOS 里保存的启动顺序，或通过与用户的交互），把控制权交给启动顺序排在第一位的存储设备，然后 CPU 将该存储设备引导扇区的内容加载到内存中；

4. 加载主引导记录 MBR：
硬盘以特定的标识符区分引导硬盘和非引导硬盘。若发现一个存储设备不是可引导盘，就检查下一个存储设备；若无其他启动设备，会死机；主引导记录 MBR 的作用是告诉 CPU 操作系统在硬盘的位置；

5. 扫描硬盘分区表，并加载硬盘活动分区

6. 加载分区引导记录 PBR

7. 加载启动管理器

8. 加载操作系统
```

✅12. 下列关于虚拟机的说法中，正确的是（ ）

```
I.   虚拟机可以用软件实现
II.  虚拟机可以用硬件实现
III. 多台虚拟机可同时运行同一物理机器上，它实现了真正的并行

A. I,II
B. I,III
C. I
D. I,II,III
```

```
I. II. => 能用软件实现的，一定能用硬件实现

III.   => 实现真正并行的是多核处理机，多台虚拟机同时运行在同一物理机器上，实现了类似于多个程序运行在同一个系统中
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#162)

# Chapter 2: Process & Thread
## 2.1.8 Process & Thread | 进程和线程
✅02. 下列关于线程的叙述中，正确的是（ ）

```
A. 线程包含 CPU 现场，可以独立执行程序
B. 每个线程有自己独立的地址空间
C. 进程只能包含一个线程
D. 线程之间的通信必须使用系统调用函数
```

```
线程是处理机调度的基本单位，可以独立执行程序；
线程没有自己独立的地址空间，它共享其所属进程的空间；
进程可以创建多个线程；
与进程之间线程的通信可以直接通过他们共享的存储空间；
```

❓04. 进程和程序的根本区别是（ ）

```
A. 静态和动态特点
B. 是不是被调入内存
C. 是不是具有就绪、运行和等待三种状态
D. 是不是占有处理器
```

```
动态性是进程最重要的特性，以此来区分文件形式的静态程序。
操作系统引入进程的概念主要是为了从变化的角度，动态地来分析和研究程序的执行。
（*注：进程的四个特性；动态性（最基本的特征）、并发性、独立性、异步性）
```

✅05. 下面的叙述中，正确的是（ ）

```
A. 进程获得处理运行时通过调度得到的
B. 优先级是进程调度的重要依据，一旦确定不能改动
C. 在单处理器系统中，任何时刻都只有一个进程处于运行态
D. 进程申请处理器而得不到满足时，其状态会变为阻塞态
```

```
B：优先级分为静态优先级和动态优先级；
C：系统发生死锁时，有可能进程全部都处于阻塞态，或无进程任务，即 CPU 空闲；
D：进程申请处理器得不到满足时就处于就绪态，等待处理器的调度
```

✅10. 系统进程所请求的一次 I/O 操作完成后，将使进程状态从（ ）

```
A. 运行态变为就绪态
B. 运行态变为阻塞态
C. 就绪态变为运行态
D. 阻塞态变为就绪态
```

```
可查阅 “进程的阻塞与唤醒” 这一对原语，完成所请求的一次 I/O 操作之后，操作系统会发出唤醒原语，使得进程状态从阻塞态转变为就绪态
```

❓12. 并发进程失去封闭性，是指（ ）

```
A. 多个相对独立的进程以各自的速度向前推进 
B. 并发进程的执行结果与速度无关
C. 并发进程执行时，在不同时刻发生的错误
D. 并发进程共享变量，其执行结果与速度有关
```

```
程序封闭性：指进程执行的结果只取决于进程本身，不受外界影响；
失去封闭性后，不同速度下的执行结果不同；
```

✅14. 进程在处理器上执行时，（ ）

```
A. 进程之间是无关的，具有封闭特性
B. 进程之间都有交互性，相互依赖、相互制约，具有并发性
C. 具有并发性，即同时执行的特性
D. 进程之间可能是无关的，但可能是有交互性的
```

```
进程间有可能具有相关性，也有可能具有独立性；
并发性并不是是指 “同时”；
（进程的四个特征：动态性、并发性、独立性、异步性）
```

🌟19. 支持多道程序设计的操作系统在运行过程中，不端的选择新进程运行来实现 CPU 的共享，但其中（ ）不是引起操作系统选择新进程的直接原因

```
A. 运行的时间片用完
B. 运行进程出错
C. 运行进程要等待某一事件发生
D. 有新进程被创建进入就绪态
```

```
不能进行进程调度与切换的情况：处理中断的过程、访问临界区、原子操作；
应当进行进程调度与切换的情况：时间片用完、运行结束、需要等待事件的发生（如等待键盘响应）、出错、自我阻塞等；

新进程加入就绪队列不是引起调度的直接原因，即使是最高优先级的进程进入就绪队列，也需要考虑是否允许被抢占。
```

🌟20. 若一个进程实体由 PCB、共享正文段、数据堆段和数据栈段组成，请指出下列 C 语言程序中的内容及相关数据结构各位于哪一段中。

```
（ ）I.   全局赋值变量
（ ）II.  为负值的局部变量
（ ）III. 函数调用实参传递值
（ ）IV.  用 malloc() 要求动态分配的存储区
（ ）V.   常量值（如 1995、"string"）
（ ）VI.  进程的优先级

A. PCB
B. 正文段
C. 堆段
D. 栈段
```

```
C 语言编写程序在使用内存是一般分为三个段：正文段（包含代码和赋值数据段）、数据堆段、数据栈段；

正文段：二进制代码和常量（全局赋值变量、常量）；
数据堆段：动态分配的存储区（即 malloc()）；
数据栈段：临时使用的变量（未赋值的局部变量和实参）；
PCB：进程的优先级；
```

✅21. 同一程序经过多次创建，运行在不同的数据集上，形成了（ ）的进程

```
A. 不同
B. 相同
C. 同步
D. 互斥
```

```
一个进程是程序在一个数据集上的一次运行过程。
运行于不同的数据集，将会形成不同的进程。
```

✅22. 系统动态 DLL 库中的唯一标志，下列（ ）不属于 PCB

```
A. 不同
B. 相同
C. 可能不同，有可能相同
D. 不能被调用
```

```
进程是暂时的，程序是永久的（进程是程序的一次执行过程）；
进程是动态的，程序是静态的（动态性是进程的特征之一）；
进程至少由代码、数据、PCB 组成，程序仅需代码和数据即可；
程序代码经过多次创建可对应不同进程，而同一个系统的进程或线程可以由系统调用的方法被不同的进程或线程多次使用。
```

✅23. PCB 是进程存在的唯一标志，下列（ ）不属于 PCB

```
A. 进程 ID
B. CPU 状态
C. 堆栈指针
D. 全局变量
```

```
PCB 包含内容分为四大类：进程标志信息、进程控制信息、进程资源信息、CPU 现场信息；

进程 ID 属于进程标志信息；
CPU 状态属于 CPU 现场信息；
堆栈指针进程资源信息（资源分配清单）；

全局变量属于 C 语言的程序正文段（赋值数据段）
```

✅26. 在一个多道系统中，若就绪队列不空，就绪的进程数目越多，处理器的效率（ ）

```
A. 越高
B. 越低
C. 不变
D. 不确定
```

```
进程就绪数目越多，争夺 CPU 的进程就越多，但只要就绪队列不为空，CPU 总能调度进程运行，保持 CPU 处于繁忙状态；

这与就绪进程的数目没有关系，除非就绪队列为空，此时 CPU 进入等待态，导致 CPU 效率下降。
```

✅33. 在以下描述中，（ ）并不是多线程系统的特长

```
A. 利用线程并行地执行矩阵乘法运算
B. Web 服务器利用线程响应 HTTP 请求
C. 键盘驱动程序为每个正在运行的应用配备一个线程，用以响应该应用的键盘输入
D. 基于 GUI 的调试程序用不同的线程分别处理用户输入、计算和跟踪等操作
```

```
一般而言，整个系统中只有一个键盘，而键盘输入是用户行为，操作较慢（相较于计算机内部硬件而言），完全可以使用一个进程来处理整个系统的键盘输入。
```

✅38. （ ）必会引起进程切换

```
A. 一个进程创建后，进入就绪态
B. 一个进程从运行态变为就绪态
C. 一个进程从阻塞态变成就绪态
D. 以上都不对
```

```
进程切换是指 CPU 调度不同的进程执行，当一个进程从运行态变为就绪态时，CPU 会调度另一个进程执行，引起进程切换
```

✅41. 进程创建时，不需要做的是（ ）

```
A. 填写一个该进程的进程表相
B. 分配该进程适当的内存
C. 将该进程插入就绪队列
D. 为该进程分配 CPU
```

```
进程创建原语完成的工作是：
1. 为进程分配一个唯一的进程标识号，并申请一个空白 PCB；
2. 为进程分配其运行所需的资源；
3. 初始化 PCB；
4. 若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行；

此过程中，创建原语不会包含分配 CPU 的过程（分配资源不包含分配 CPU，因为被分配了 CPU 资源意味着该进程已处于运行态之中）分配 CPU 将由调度程序完成
```

44. 下面关于用户级线程和内核级线程的描述中，错误的是（ ）

```
A. 采用轮转调度算法，进程中设置内核级线程和用户级线程的效果完全不同
B. 跨进程的用户级线程调度也不需要内核参与，控制简单
C. 用户级线程可以在任何操作系统中运行
D. 则处理机的调度对象是进程
```

```

```

❓45. 在内核级线程相对于用户级线程的优点的如下描述中，错误的是（ ）

```
A. 同一进程内的线程切换，系统开销小
B. 当内核线程阻塞时，CPU 将会调度同一进程中的其他内核线程执行
C. 内核级线程的程序实体可以在内核态运行
D. 对多处理器系统，核心可以同时调度同一进程的多个线程并行运行
```

```
内核级线程中，同一进程中的线程切换，需要从用户态转到核心态进行，系统开销较大；

CPU 调度是在内核进行的，在内核级线程中，调度是在线程这一级进行，因此内核可以同时调度同一进程的多个线程在多 CPU 上并行运行（但用户级线程不支持）；

进程中的内核级线程运行在内核态，说明该进程也运行在内核态。
```

✅47. 「2010真题」下列选项中，导致创建新进程的操作是（ ）

```
I.   用户登录成功
II.  设备分配
III. 启动程序运行

A. I,II
B. II,III
C. I,III
D. I,II,III
```

```
I.   => 用户登录成功后，系统要为此创建一个用户管理的进程，包括但不限于用户桌面、环境；所有的用户进程都会在该进程下创建和管理（即用户管理为父进程，其他用户进程属于该进程的子进程）
II.  => 设备分配是通过系统中设置相应的数据结构实现的，不需要创建进程；
III. => 启动程序执行时引起创建进程的典型事件
```

✅48. 「2010真题」下列选项中，降低进程优先级的合理时机是（ ）

```
A. 进程时间片用完
B. 进程刚完成 I/O 操作，进入就绪队列
C. 进程长期处于就绪队列
D. 进程从就绪态转为运行态
```

```
时间片用完，可降低该进程的优先级已让其他进程进入运行态；

进程刚完成 I/O 操作，进入就绪队列等待被处理机（CPU）调度，为尽快让其处理 I/O 结果，应提高优先级；

进程长期处于就绪队列，若不提高该进程的优先级，该进程可能会被 “饿死”；

进程从就绪态转为运行态，此时至少等时间片用完再降低优先级。
```

✅50. 「2012真题」下列关于进程和线程的叙述中，正确的是（ ）

```
A. 不管系统是否支持线程，进程都是资源分配的基本单位
B. 线程是资源分配的基本单位，进程是调度的基本单位
C. 系统级线程和用户级线程的切换都需要内核的支持
D. 同一进程中的更线程拥有各自不同的地址空间
```

```
引入线程后，进程仍然是资源分配的基本单位；
线程是调度的基本单位；
用户级线程中，有关线程管理的所有工作均由应用程序完成，无需内核的干预，内核意识不到该线程的存在，因此不需要内核的支持；
同一进程中的各个线程共享进程的地址空间。
```

⭕️52. 「2014真题」下列关于管道（Pipe）通信的叙述中，正确的是（ ）

```
A. 一个管道可实现双向数据传输
B. 管道的容量仅受磁盘容量大小限制
C. 进程对管道进行读操作和写操作都可能被阻塞
D. 一个管道只能一个读进程或一个写进程
```

```

```

✅54. 「2018真题」下列选项中，可能导致当前进程 P 阻塞的事件是（ ）

```
I.   进程 P 申请临界资源
II.  进程 P 从磁盘读数据
III. 系统将 CPU 分配给高优先权的进程

A. I
B. II
C. I,II
D. I,II,III
```

```
进程等待某资源（不包括处理机/CPU）或等待输入/输出完成时，均会进入阻塞态；
系统将 CPU 分配给了高优先权的进程时，当前进程（即进程 P）会进入就绪态。
```

✅55. 「2019真题」下列选项中，可能会将进程唤醒的事件是（ ）

```
I.   I/O 结束
II.  某进程退出临界区
III. 当前进程的时间片用完

A. I
B. III
C. I,II
D. I,II,III
```

```
I.   => 当被阻塞的进程等待的某资源（不包括处理机/CPU）可用时，进程从阻塞态被唤醒；I/O 结束后，等待该 I/O 结束而被阻塞的有关进程会被唤醒；
II.  => 某进程退出临界区后，之前因需要进入该临界区而被阻塞的有关进程会被唤醒；
III. => 当前进程的时间片用后进入就绪队列等待重新调度，优先级最高的进程获得处理机资源从就绪态变成执行态，而不是从阻塞态被唤醒。

*唤醒：指将进程从阻塞态转为就绪态，而不是运行态
```

🌟56. 「2019真题」下列关于线程的描述中，错误的是（ ）

```
A. 内核级线程的调度由操作系统完成
B. 操作系统为每个用户级线程建立一个线程控制块
C. 用户级线程间的切换比内核级线程间的切换效率高
D. 用户级线程可以在不支持内核级线程的操作系统上实现
```

```
应用程序没有进行内核级线程管理的代码，只有一个到内核级线程的编程接口，内核为进程及其内部的每个线程维护上下文信息，调度也是在内核中由操作系统完成的；

当且仅当处于一对一模型时，操作系统才会为每个用户级线程建立一个线程控制块；

用户级线程切换在用户态（用户空间内）完成，而内核级线程的切换依赖操作系统的调度进行完成，因此用户级线程切换效率高；

用户级线程的管理工作可一直在用户空间中进行，因此可以在不支持内核级线程的操作系统上实现（如微内核）
```

✅57. 「2020真题」下列关于父进程与子进程的叙述中，错误的是（ ）

```
A. 父进程与子进程可以并发执行
B. 父进程与子进程共享虚拟地址空间
C. 父进程与子进程有不同的进程控制块
D. 父进程与子进程不能同时使用同一临界资源
```

```
父进程可以与子进程并发执行（最典型的是用户登录成功的案例，创建用户管理进程后，其余的用户进程都基于该用户管理这个父进程并发执行）；

父进程可与子进程共享一部分资源，但不能共享虚拟地址空间（但某进程内的所有线程可以共享该进程的地址空间），在创建子进程时，操作系统会为子进程分配资源，如虚拟地址空间；

PCB 是进程存在的唯一标志，因此即使是父子进程，也拥有各自独立的 PCB；

临界区资源一次只能为一个进程所用；
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#218)

## 2.2.7 Dispatch of Process and Thread | 进程与线程的切换
✅03. （ ）有利于 CPU 繁忙型的作业，而不利于 I/O 繁忙型的作业。

```
A. 时间片轮转调度算法
B. 先来先服务调度算法
C. 短作业（进程）优先算法
D. 优先权调度算法
```

```
CPU 繁忙型作业：是指该类作业需要大量 CPU 时间进行计算，而很少请求 I/O 操作（可简单理解为长作业）；
I/O 繁忙型作业：是指该类作业需要频繁请求 I/O 操作，导致操作完成后还要重新排队等待调度（可简单理解为短作业密集型）；

时间片轮转调度对于长短作业均起到兼顾的作用；
先来先服务调度对于长作业较为友好，而不利于短作业；
短作业优先算法对于短作业更为友好；
优先权调度算法对于长短作业没有必然的联系；
```

🌟05. 进程（线程）调度的时机有（ ）

```
I.   运行的进程（线程）运行完毕
II.  运行的进程（线程）所需资源未准备好
III. 运行的进程（线程）的时间片用完
IV.  运行的进程（线程）自我阻塞
V.   运行的进程（线程）出现错误

A. II,III,IV,V
B. I,III
C. II,IV,V
D. 全部
```

```
非抢占式进程/线程的调度时机有：（调度：从就绪态转变为运行态）
1. 当前运行的进程/线程运行完毕；
2. 当前运行的进程/线程自我阻塞；
3. 当前运行的进程/线程的时间片用完；
4. 当前运行的进程/线程所需的资源没有准备好；
5. 当前运行的进程/线程出现错误。

抢占式进程/线程的调度时机有：
1. 就绪队列中某个进程比当前运行的进程优先级更高时，也会引发进程调度；
```

🌟07. 
若每个作业只能建立一个进程，为了照顾短作业用户，应采用（ ）；
为了照顾紧急作业用户，应采用（ ）；
为了能实现人机交互，应采用（ ）；
而能使短作业、长作业和交互作业用户都满意，应采用（ ）；

```
A. FCFS 调度算法 
B. 短作业优先调度算法
C. 时间片轮转调度算法
D. 多级反馈队列调度算法
E. 剥夺式优先级调度算法
```

```
照顾短作业用户，应采用短作业优先调度算法；

照顾紧急作业用户，应采用抢占式/剥夺式优先级调度算法；

实现人机交互，即要保证每个应用程序/作业能在一定时间内轮到，即时间片轮转调度算法；

满足多数用户请求，应采用多级反馈队列调度算法。
```

✅14. 下列调度算法中，（ ）调度算法是绝对可抢占的

```
A. 先来先服务
B. 时间片轮转
C. 优先级
D. 短进程优先
```

```
先来先服务算法只能是非抢占式；
时间片轮转调度算法无优先级之分，时间片一到，系统会自动启用调度程序，因此是绝对可抢占的；
优先级算法和短进程优先算法均可设置抢占式或非抢占式；
```

✅21. 假设系统中所有进程同时到达，则是进程平均周转时间最短的是（ ）调度算法

```
A. 先来先服务
B. 短进程优先
C. 时间片轮转
D. 优先级
```

```
短进程优先调度算法拥有最短的平均周转周期；
原因：因为平均周转时间 = 各进程周转时间之和/进程数；而进程的执行时间是固定的，只有等待时间是变化的，因此只有短进程优先调度算法的等待时间最少（但对长时间进程不够友好）
```

✅22. 下列说法中，正确的是（ ）

```
I.   分时操作系统的时间片固定，因此用户数越多，响应时间越长
II.  UNIX 是一个强大的多用户、多任务操作系统，支持多种处理器架构，按照操作系统分类，属于分时操作系统
III. 中断向量地址是中断服务例行程序的入口地址
IV.  中断发生时，由硬件保护并更新程序计数器（PC），而不是由软件完成，主要是为了提高处理速度

A. I,II
B. II,III
C. III,IV
D. IV
```

```
I.   => 分时系统中，响应时间与时间片和用户数成正比
II.  => UNIX 确实属于分时操作系统
III. => 中断向量本身适用于存放中断服务例行程序的入口地址（详见《计组》7.3），因此中断向量地址就应是该入口地址的地址（有点绕）
IV.  => 中断由硬件保护并完成，主要是为了保证系统运行可靠，提高处理速度不是主要目的；
```

✅25. 「2012真题」一个多道批处理系统中仅有 P1 和 P2 两个作业，P2 比 P1 晚 5ms 到达，它的计算和 I/O 操作顺序如下：

P1：计算 60ms，I/O 80ms，计算 20ms
P2：计算 120ms，I/O 40ms。计算 40ms

若不考虑调度和切换时间，则完成两个作业需要的时间最少是（ ）

```
A. 240ms
B. 260ms
C. 340ms
D. 360ms
```

```
  ^
  |
P2|       ________________________........_____
  |
P1|_______...............         ___
  |
  |_____________________________________________>

由上图（甘特图）可知，P1 先执行计算 60ms，然后进入 I/O 操作 80ms；
在 P1 进行 I/O 操作时，P2 开始进行计算 120ms，然后进行 I/O 操作 40ms；
在 P2 进行 I/O 操作时，P1 开始进行最后的计算任务 20ms，完成作业；
由于 P1 完成所有任务时，P2 仍在执行 I/O 操作，因此可以一直完成所有任务。
```

✅26. 「2012真题」若某单处理器多进程系统中有多个就绪态进程，则下列关于处理机调度的叙述中，错误的是（ ）

```
A. 在进程结束时能进程处理机调度
B. 创建新进程后能进行处理机调度
C. 在进程处于临界区时不能进行处理机调度
D. 在系统调用完成并返回用户态时能进行处理机调度
```

```
参考本章节 05 以及前一章节 48 题；

当进程处于临界区时，说明该进程正在占用处理机，因此只要不破坏临界资源的使用规则，就不会影响处理的调度。
```

✅34. 「2020真题」下列与调度有关的因素中，在设计多级反馈队列调度算法是需要考虑的是（ ）

```
I.   就绪队列的数量
II.  就绪队列的优先级
III. 各就绪队列的调度算法
IV.  进程在就绪队列间的迁移条件

A. I,II
B. III,IV
C. II,III,IV
D. I,II,III,IV
```

```
I.   => 多级反馈队列调度算法需要综合考虑优先级数量、优先级之间的转换规则等，就绪队列的数量会影响长进程的最终完成时间；
II.  => 就绪队列的优先级会影响进程执行的顺序；
III. => 个就绪队列的调度算法会影响个队列中进程的调度顺序；
IV.  => 进程在就绪队列中的迁移条件会影响各进程在各队列中的执行时间；
```

✅35. 「2021真题」在下列内核的数据结构或程序中，分时系统实现时间片轮转调度需要使用的是（ ）

```
I.   进程控制块
II.  时钟中断处理程序
III. 进程就绪队列
IV.  进程阻塞队列

A. II,III
B. I,IV
C. I,II,III
D. I,II,IV
```

```
I. II. III. => 在分时系统的时间片轮转调度中，当系统检测到时钟中断时，会引出时钟中断程序；
               调度程序从就绪队列中选择一个进程为其分配时间片，并且修改该进程的进程控制块中的进程状态等信息；
               同时将时间片用完的进程放入就绪队列或让其结束运行。

IV.         => 阻塞队列中的进程只有在被唤醒后并进入就绪队列后，才能参与调度，因此在该调度过程中不使用阻塞队列。
```

✅36. 「2021真题」下列事件中，可能引起进程调度程序执行的是（ ）

```
I.   中断处理结束
II.  进程阻塞
III. 进程执行结束
IV.  进程的时间片用完

A. I,III
B. II,IV
C. III,IV
D. I,II,III,IV
```

```
参考本章节 05、26 以及前一章节的 48
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#227)

## 2.3.8 Synchronization & Mutual Exclusion | 同步与互斥
🌟03. 若一个信号量的初值为 3，经过多次 PV 操作后当前值为 -1，这表示等待进入临界区的进程数是（ ）

```
A. 1
B. 2
C. 3
D. 4
```

```
信号量是一种特殊的整型变量，只有初始化和 PV 操作才能改变其值。
而通常，信号量分为互斥量和资源量：
互斥量的初值一般是 1，表示临界区只允许一个进程进入，从而实现互斥；
而当互斥量为 0 时，表示临界区已有一个进程进入，临界区外尚无进程等待；
互斥量小于 0 时，表示临界区已有一个进程进入，而互斥量的绝对值表示在临界区外等待进入的进程数；

资源量初值可以是任意整数，表示可用的资源数；
当资源量小于 0 时，表示所有资源已全部用完，而且还有进程正在等待使用该资源，等待的进程数就是资源量的绝对值。
```

❓05. 两个旅行社甲、乙为旅客到某航空公司订飞机票，形成互斥资源的是（ ）

```
A. 旅行社
B. 航空公司
C. 飞机票
D. 旅行社与航空公司
```

```
一张飞机票不能售给不同的旅客，因此飞机票是互斥资源，其他因素只是为完成订票的中间过程，与互斥资源无关
```

✅11. 进程 A 和进程 B 通过共享缓冲区协作完成数据处理，进程 A 负责产生数据并放入缓冲区，进程 B 从缓冲区读数据并输出。进程 A 和进程 B 之间的制约关系是（ ）

```
A. 互斥关系
B. 同步关系
C. 互斥和同步关系
D. 无制约关系
```

```
并发进程因为共享资源而产生相互之间的制约关系，可以分为 互斥 和 同步 两类。

进程 B 必须在进程 A 将数据放入缓冲区后才能从缓冲区中读出数据，因此是同步关系；

共享的缓冲区是一种临界资源，需要互斥访问，因此具有互斥关系。
```

✅18. 用 P、V 操作实现进程同步，信号量的初值为（ ）

```
A. -1
B. 0
C. 1
D. 由用户确定
```

```
与互斥信号量初值一般置 1 不同，用 P、V 操作实现进程同步时，信号量的初值应根据具体情况来确定。
（同步信号量初值一般表示可用资源数量）
若期望的消息尚未产生，则对应的初值应设为 0；
若期望的消息已存在，则信号量的初值应设为一个非 0 的正整数。
```

✅19. 可以被多个进程在任意时刻共享的代码必须是（ ）

```
A. 顺序代码
B. 机器语言代码
C. 不允许任何修改的代码
D. 无转移指令代码
```

```
弱代码可被多个进程在任一时刻共享，则要求任意一个进程在调用此段代码时都以同样的方式运行；

而进程在运行过程中被中断后再继续执行，其执行结果不受影响；

以上这些条件必然要求代码不能被任何进程修改（即只读不写），否则无法满足共享的要求。

这样的代码被称为可重入代码，即纯代码，即允许多个进程同时访问的代码。
```

✅24. 对于两个并发进程，设互斥信号量为 mutex（初值为1），若 mutex=-1，则（ ）

```
A. 表示没有进程进入临界区
B. 表示有一个进程进入临界区
C. 表示有一个进程进入临界区，另一个进程等待进入
D. 表示有两个进程进入临界区
```

```
当有一个进程进入临界区且有另一个进程等待进入临界区时，mutex = -1；
mutex 的值小于 0 时，其绝对值等于等待进入临界区的进程数。
```

✅25. 一个进程因在互斥信号量 mutex 上执行 V(mutex) 操作而导致唤醒另一个进程时，执行 V 操作后 mutex 的值为（ ）

```
A. 大于 0
B. 小于 0
C. 大于等于 0
D. 小于等于 0
```

```
系统原来存在等待进程临界区的进程，mutex <= -1；
在执行 V(mutex) 操作后，mutex <= 0.
```

🌟28. 以下关于管程的叙述中，错误的是（ ）

```
A. 管程是进程同步工具，解决信号量机制大量同步操作分散的问题
B. 管程每次只允许一个进程进入管程
C. 管程中 signal 操作的作用和信号量机制中的 V 操作相同
D. 管程是被进程调用的，管程是语法范围，无法创建和撤销
```

```
管程的 signal 操作与信号量机制中的 V 操作不同，信号量机制中的 V 操作一定会改变信号量的值，即 S=S+1；

而管程中的 signal 操作是针对某个条件变量的，若不存在因该条件而阻塞的进程，则 signal 操作不会产生任何影响。
```

✅29. 对信号量 S 执行 P 操作后，使该进程进入资源等待队列的条件是（ ）

```
A. S.value < 0
B. S.value <= 0
C. S.value > 0
D. S.value >= 0
```

```
S.value > 0，表示某类可用资源的数量，而每次 P 操作意味着请求分配一个单位的资源
S.value <= 0，表示某类资源已经没有可用，其中 S.value 此时的绝对值表示处于等待状态的进程数目
```

✅30. 若系统有 n 个进程，则就绪队列中进程的个数最多有（ 1 ）；阻塞队列中进程的个数最多有（ 2 ）个。

```
A. n+1
B. n
C. n-1
D. 1
```

```
系统中有 n 个进程，其中至少有一个进程正在执行（处理器至少有一个），因此就绪队列最多有 n-1 个进程在等待；

死锁发生时，所有的进程都处于阻塞态中，因此最多有 n 个进程处于阻塞态中。
```

✅36. 若有 4 个进程共享同一程序段，每次允许 3 个进程进入该程序段，若用 P、V 操作作为同步机制，则信号量的取值范围是（ ）

```
A. 4,3,2,1,-1
B. 2,1,0,-1,-2
C. 3,2,1,0,-1
D. 2,1,0,-2,-3
```

```
由于每次允许三个进程进入该程序段，因此可能出现的情况是：
没有进程进入 => 3
有一个进程进入 => 2
有两个进程进入 => 1
有三个进程进入 => 0
有三个进程进入并有一个进程在等待 => -1
（同步信号量的取值表示可用资源数）
```

✅37. 在 9 个生产者、6 个消费者共享容量为 8 的缓冲器的生产者-消费者问题中，互斥使用缓冲器的信号量初始值为（ ）

```
A. 1
B. 6
C. 8
D. 9
```

```
互斥态下信号量初始值表示可用资源数，但互斥只允许一个进程在工作，因此初始值是 1
```

✅38. 信箱通信是一种（ ）通信方式

```
A. 直接通信
B. 间接通信
C. 低级通信
D. 信号量
```

```
信箱通信是一种间接通信方式
```

41. 「2010真题」进程 P0 和进程 P1 的共享变量定义及其初值为

```C
boolean flag[2];
int turn=0;
flag[0]=false; flag[1]=false;

// 进程 P1 与 P1 访问临界资源的类 C 代码实现如下：
void P0()
{
    while(true) {
        flag[0]=true;
        turn=1;
        while(flag[1]&&(turn==1));

        临界区;
        flag[0]=false;
    }
}

void P1()
{
    while(true) {
        flag[1]=true;
        turn=0;
        while(flag[0]&&(turn==0));

        临界区;
        flag[1]=false;
    }
}
```
则并发执行进程 P0 和进程 P1 时产生的情况是（ ）

```
A. 不能保证进程互斥进入临界区，会出现 “饥饿” 现象
B. 不能保证进程互斥进入临界区，不会出现 “饥饿” 现象
C. 能保证进程互斥进入临界区，会出现 “饥饿” 现象
D. 能保证进程互斥进入临界区，不会出现 “饥饿” 现象
```

```

```

🌟42. 「2011真题」有两个并发执行的进程 P1 和进程 P2，共享初值为 1 的变量 x。P1 对 x 加 1，P2 对 x 减 1。

```C
// +1
load R1, x  // 取 x 到寄存器 R1
inc R1
store x, R1 // 将 R1 的内容存入 x

// -1
load R2, x  // 取 x 到寄存器 R2
dec R2
store x, R2 // 将 R2 的内容存入 x 
```

加减操作的指令序列分别如上所示。两个操作完成后，x 的值（ ）

```
A. 可能为 -1 或 3
B. 只能为 1
C. 可能为 0，1 或 2
D. 可能为 -1，0，1 或 2
```

```C
// P1
load R1, x  // 1
inc R1      // 2
store x, R1 // 3

// P2
load R2, x  // 4
dec R2      // 5
store x, R2 // 6
```

```
依次执行 1,2,3,4,5,6 => 1;
依次执行 1,2,4,5,6,3 => 2;
依次执行 4,5,1,2,3,6 => 0;
```

❓44. 「2016真题」使用 TSL（Text and Set Lock）指令实现进程互斥的伪代码如下所示

```C
do {
    ...
    while(TSL(&lock));
    critical section;
    lock=FALSE;
    ...
} while(TRUE);
```

下列与该实现机制相关的叙述中，正确的是（ ）

```
A. 退出临界区的进程负责唤醒阻塞态进程
B. 等待进入临界区的进程不会主动放弃 CPU
C. 上述伪代码满足 “让权等待” 的同步准则
D. while(TSL(&lock)) 语句应在关中断状态下执行
```

```
当进程退出临界区时，置 lock=FALSE，会负责唤醒处于就绪态的进程；

等待进入临界区的进程会一直停留在执行 while(TSL(&lock)) 的循环中，不会主动放弃 CPU；

让权等待：进程不能进入临界区时，会立即释放处理机，防止进程进入忙等待，但上述代码不满足让权等待；

while(TSL(&lock)) 在关中断状态下执行时，若 TSL(&lock) 一直为 true，不再开中断，则系统可能会终止。
```

✅45. 「2016真题」下列关于管程的叙述中，错误的是（ ）

```
A. 管程只能用于实现进程的互斥
B. 管程是由编程语言支持的进程同步机制
C. 任何时候只能有一个进程在管程中执行
D. 管程中定义的变量只能被管程内的过程访问
``` 

```
管程是由一组数据及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程。

管程不仅能实现进程间的互斥，还能实现进程间的同步；

管程有如下三个特性：
1. 局部于管程的数据只能被局部于管程内的过程所访问；
2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据；
3. 每次仅允许一个进程在管程内执行某个内部过程；
```

✅46. 「2018真题」属于同一进程的两个线程 thread1 和 thread2 并发执行，共享初值为 0 的全局变量 x。thread1 和 thread2 实现对全局变量 x 加一的机器及代码描述如下：

```C
// thread1
mov R1, x // (x)->R1
inc R1    // (R1)+1->R1
mov x, R1 // (R1)->x

// thread2
mov R2, x // (x)->R2
inc R2    // (R2)+1->R2
mov x, R2 // (R2)->x
```

在所有可能的指令执行序列中，使 x 的值为 2 的序列个数是（ ）

```
A. 1
B. 2
C. 3
D. 4
```

```
若要使 x=2，只能执行先 thread1 后 thread2 或先 thread1 后 thread2，因此仅两种可能
```

✅48. 「2018真题」在下列同步机制中，可以实现让权等待的是（ ）

```
A. Peterson 方法
B. swap 指令
C. 信号量方法
D. TestAndSet 指令
```

```
硬件方法实现进程同步时不能实现让权等待；

Peterson 算法满足优先等待但不满足让权等待；

记录行信号量由于引入阻塞机制，消除了不让权等待的情况。
```

❓49. 「2020真题」下列准则中，实现临界区互斥机制必须遵守的是（ ）

```
I.   两个进程不能同时进入临界区
II.  允许进程访问空闲的临界资源
III. 进程等待进入临界区的时间是有限的
IV.  不能进入临界区的执行态进程立即放弃 CPU

A. I,IV
B. II,III
C. I,II,III
D. I,III,IV
```

```
实现临界区互斥需满足多个准则：

忙则等待：两个进程不能同时访问临界区；

空闲让进：若临界区空，则允许其他进程访问；

有限等待：进程应该在有限时间内访问临界区；

让权等待：不一定非得实现，如 Peterson 算法（？）
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#238)

## 2.4.6 Deadlock | 死锁
✅04. 系统产生死锁的可能原因是（ ）

```
A. 独占资源分配不当
B. 系统资源不足
C. 进程运行太快
D. CPU 内核太多
```


```
死锁分为时间上和空间上。

时间上：由于进程运行中推进顺序不当，即调度时机不合适，不该切换进程时进行了切换，可能会造成死锁；

空间上：对独占资源分配不当，互斥资源部分分配又不可剥夺，极易造成死锁。

若系统资源不足，只会对进程造成 “饥饿”。
```

✅07. 某系统中有三个并发进程都需要四个同类资源，则该系统必然不会发生死锁的最少资源是（ ）

```
A. 9
B. 10
C. 11
D. 12
```

```
资源数为 9 时，存在三个进程都占有三个资源，发生死锁（因为都在申请第四个资源）；
因此当资源数给到 10 时，就会避免上述情况。
（该类题型需要掌握极限的思路，即发生死锁的极限情况）
```

✅08. 某系统中共有 11 台磁带机，X 个进程共享此磁带机设备，每个进程最多请求使用 3 台，则系统必然不会死锁的最大 X 值是（ ）

```
A. 4
B. 5
C. 6
D. 7
```

```
与上题所对应，并发执行时，若每个进程已分配 2 台磁带机，会出现死锁；此时再增加 1 台磁带机，便可解除死锁。
因此 2X+1=11 => X=5
```

✅13. 三个进程共享四个同类资源，这些资源的分配与释放只能一次一个，已知每个进程最多需要两个该类资源，则该系统（ ）

```
A. 有些进程可能永远得不到该类资源
B. 必然有死锁
C. 进程请求该类资源必然能得到
D. 必然是死锁
```

```
当每个进程都分得一个资源时（极限情况），仍有一个单位的资源可由任意进程申请，当它完成整个过程后，又可以释放出资源来满足其他进程
```

✅15. 死锁的四个必要条件中，无法破坏的是（ ）

```
A. 环路等待资源
B. 互斥使用资源
C. 占有且等待资源
D. 非抢夺式分配
```

```
所谓破坏互斥使用资源，是指允许多个进程同时访问资源，但有些资源无法同时访问，因此不太可行，且有些情况应当保护这种互斥性，因此无法破坏。
```

✅18. 某个系统采用下列资源分配策略：

若一个进程提出资源请求得不到满足，而此时没有犹豫等待资源而被阻塞的进程，则自己就被阻塞；而当此时已有等待资源而被阻塞的进程，则检查所有有等待资源而被阻塞的进程；若它们有申请进程所需要的资源，则将这些资源取出并分配给申请进程。

这种分配策略会导致（ ）

```
A. 死锁
B. 颠簸
C. 回退
D. 饥饿
```

```
某个进程主动释放资源不会导致死锁，因为破坏了 “请求并保持” 条件；

颠簸即抖动，是由请求分页系统中页面调度不当而导致的现象，参见后续第三章内存管理；

回退是指从此时此刻状态退回到之前某时刻的状态（如一分钟前），若一分钟之前拥有资源 X，而此时释放了 X，则无法回退到之前的状态；

由于进程总是会把自己已得到的资源分配给其他进程，因此会导致 “饥饿”
```

✅19. 系统的资源分配图在下列情况下，无法判断是否处于死锁状态的有（ ）

```
I.   出现了环路
II.  没有环路
III. 每种资源只有一个，并出现环路
IV.  每个进程结点至少有一条请求边

A. I,II,III,IV
B. I,III,IV
C. I,IV
D. 以上答案都不正确
```

```
I.   => 出现了环路，只是满足循环等待的必要条件，不一定会导致死锁
II.  => 没有环路，破坏了循环等待条件，一定不会发生死锁
III. => 每种资源只有一个，又出现了环路，满足死锁的充分条件，必然发生死锁
IV.  => 即使每个进程至少有一条请求边，若资源足够，则不会发生死锁；只有资源不够时，才会发生死锁
```

✅20. 下列关于死锁的说法中，正确的有（ ）

```
I.   死锁状态一定是不安全状态
II.  产生死锁的根本原因是系统资源分配不足和进程推进顺序非法
III. 资源的有序分配策略可以破坏死锁的循环等待条件
IV.  采用资源剥夺法可以解除死锁，还可以采用撤销进程方法解除死锁

A. I,III
B. II
C. IV
D. 四个说法都对
```

```
I.   => 死锁状态一定是不安全状态，但不安全状态不一定是死锁状态（注意包含关系）
II.  => 是产生死锁的两大原因
III. => 破环死锁的循环等待条件的方法是使用资源的有序分配策略
IV.  => 解除死锁的方法一般有三种：资源剥夺法（挂机）、进程中止法（强退）、撤销进程法（退档）
```

🌟21. 下面是一个并发进程的程序代码，正确的是（ ）

```C
Semaphore x1=x2=y=1;
int c1=c2=0;
P1() {
    while(1) {
        P(x1);
        if(++c1==1) P(y);
        V(x1);

        computer(A);
        P(x1);
        if(--c1==0) V(y);
        V(x1);
    }
}

P2() {
    while(1) {
        P(x2);
        if(++c2==1) P(y);
        V(x2);

        computer(B);
        P(x2);
        if(--c2==0) V(y);
        V(x2);
    }
}
```

```
A. 进程不会死锁，也不会 “饥饿”
B. 进程不会死锁，但会 “饥饿”
C. 进程会死锁，但不会 “饥饿”
D. 进程会死锁，也会 “饥饿”
```

```
上述代码逻辑：
可看作一个扩展的单行线问题。
即，某单行线只允许单方向的车辆通过，在单行线的入口设置信号量 y，并在告示牌上显示某一时刻个方向来车的数量 c1 和 c2，要修改告示牌上的车辆数必须互斥进行（即只能单进单出），为此设置信号量 x1 和 x2.

若某方向的车辆需要通过，首先要将该方向来车数量 c1/c2 + 1，并检查自身是否是第一个进入单行线的车辆；若是，获取单行线的信号量 y，并进入。通过并出单行线后，将 c1/c2 - 1（利用 x1/x2 来互斥修改），再检查自身是否是最后一辆车，若是，释放互斥量 y，否则保留，并让后续车辆继续通过；

因此若一侧（c1/c2）首先占据并后来者络绎不绝，则另一方向没有机会通过该单行线，因此会产生 “饥饿”；

但因为引入了信号量机制，因此不会产生死锁（即双方同时进入，并在中间相遇，双方无法通过）
```

✅25. 假设具有 5 个进程的进程集合 P = {P0,P1,P2,P3,P4}，系统中有三类资源 A、B、C，假设在某时刻有如下状态，见下表。

| | Aloocation | Max | Available |
| --- | --- |  ---  | --- |
|     | A B C | A B C | | 
| P0 | 0 0 3 | 0 0 4 | |
| P1 | 1 0 0 | 1 7 5 | A B C |
| P2 | 1 3 5 | 2 3 5 | x y z |
| P3 | 0 0 2 | 0 6 4 | |
| P4 | 0 0 1 | 0 6 5 | |

请问当 x y z 取下列哪些值时，系统是处于安全状态的？

```
I.   1,4,0
II.  0,6,2
III. 1,1,1
IV.  0,4,7

A. II,III
B. I,II
C. I
D. I,III
```

✅26. 「2009真题」某计算机系统中有 8 台打印机，由 K 个进程竞争使用，每个进程最多需要 3 台打印机。系统可能会发生死锁的 K 的最小值是（ ）

```
A. 2
B. 3
C. 4
D. 5
```

```
同上述 7、8
2K=8 => K=4
```

✅30. 「2014真题」某系统有 n 台互斥使用的同类设备，三个并发进程分别需要 3、4、5 台设备，可确保系统不发生死锁的设备数 n 最小为（ ）

```
A. 9
B. 10
C. 11
D. 12
```

```
2+3+4+1=10
```

✅31. 「2015真题」若系统 S1 采用死锁避免方法，S2 采用死锁检测方法。下列叙述中，正确的是（ ）

```
I.   S1 会限制用户申请资源，而 S2 不会
II.  S1 需要进程运行所需的资源总量信息，而 S2 不会
III. S1 不会给可能导致死锁的进程分配资源，而 S2 会

A. I,II
B. II,III
C. I,III
D. I,II,III
```

```
只有死锁预防会限制用户申请资源（即破坏死锁的条件）

死锁避免方法，其中最出名的是 “银行家算法”，其中的最大需求矩阵 MAX 定义了每个进程对于 m 类资源的最大需求量；
经过安全性算法检查此次资源分配是否会导致系统不安全，若不安全，则不执行此次分配；
在死锁的检测和解除中，系统为进程分配资源时不采用任何措施，但提供检测和解除手段；

```

❓32. 「2016真题」系统中有 3 个不同的临界资源 R1、R2 和 R3，被 4 个进程 P1、P2、P3、P4 共享。各进程对资源的需求为：P1 申请 R1 和 R2；P2 申请 R2 和 R3；P3 申请 R1 和 R3；P4 申请 R2。若系统出现死锁，则处于死锁状态的进程数至少是（ ）

```
A. 1
B. 2
C. 3
D. 4
```

```
利用穷举法
```

✅33. 「2018真题」假设系统中有 4 个同类资源，进程 P1、P2、P3 需要的资源数分别为 4、3、1，P1、P2、P3 已申请到的资源数分别为 2、1、0，则执行安全性检测算法的结果是（ ）

```
A. 不存在安全序列，系统仍处于不安全状态
B. 存在多个安全序列，系统处于安全状态
C. 存在唯一安全序列 P3、P1、P2，系统处于安全状态
D. 存在唯一安全序列 P3、P2、P1，系统处于安全状态
```

```
need: 2 2 1
此时还剩 1 个单位资源，因此不满足所有安全条件，故不存在安全序列
```

✅36. 「2021真题」若系统中有 n（n>=2）个进程，每个进程均需要使用某类临界资源 2 个，则系统不会发生死锁所需的该类资源总数至少是（ ）

```
A. 2
B. n
C. n+1
D. 2n
```

```
n*1+1=n+1
```

[返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#246)

# Chapter 3: Menmory Management
## 3.1.8 Memory Mangement | 内存管理
❓01. 下面关于存储管理的叙述中，正确的是（ ）

```
A. 存储保护的目的是限制内存的分配
B. 在内存为 M、有 N 个用户的分时系统中，每个用户占用 M/N 的内存空间
C. 在虚拟内存系统中，只要磁盘空间无限大，作业就能拥有任意大的编址空间
D. 实现虚拟内存管理必须有相应硬件的支持
```

```
A：
B：
C：编址空间的大小取决于硬件的访存能力
D：虚拟内存的管理需要有相关硬件和软件的支持，包括页表机制、缺页中断机构（硬件）、地址变换机构
```

✅02. 在使用交换技术时，若一个进程正在（ ），则不能交换出主存

```
A. 创建
B. I/O 操作
C. 处于临界段
D. 死锁
```

```
进程正在进行 I/O 操作时不能换出主存，否则其 I/O 数据区将被新换入的进程占用，导致错误；

但可以在操作系统中开辟 I/O 缓冲区，将数据从外设输入或将数据输出到外设的 I/O 活动在系统缓冲区中进行，此时系统缓冲区与外设进行输入/输出操作时，进程交换不受限制
```

✅10. 动态重定位是在作业的（ ）中进行的

```
A. 编译过程
B. 装入过程
C. 链接过程
D. 执行过程
```

```
静态装入是指在编程阶段就把物理地址计算好；

可重定位/静态重定位是指在装入过程中把逻辑地址转换为物理地址，但装入后不能改变；

动态重定位是指在执行时再决定装入的地址并装入，装入后可能会换出，因此同一个模块在内存中的物理地址也可能是改变的；

小结：
静态装入在编程阶段；
可重定位/静态重定位在装入阶段；
动态重定位在执行过程中
```

✅15. 多进程在主存中彼此互不干扰的环境下运行，操作系统是通过（ ）来实现的

```
A. 内存分配
B. 内存保护
C. 内存扩充
D. 地址映射
```

```
多进程的执行通过内存保护实现互不干扰，如页式管理中有页地址越界保护，段式管理中有段地址越界保护；
```

✅18. 采用分页或分段管理后，提供给用户的物理地址空间（ ）

```
A. 分页支持更大的物理地址空间
B. 分段支持更大的物理地址空间
C. 不能确定
D. 一样大
```

```
页表和段表同样存储在内存中，系统提供给用户的物理地址空间为总空间大小减去页表或段表的长度。

由于页表大小和段表大小暂时未知，因此无法判断二者提供给用户的物理地址空间大小
```

✅20. 页式存储管理中，页表的始地址存放在（ ）中

```
A. 内存
B. 存储页表
C. 快表
D. 寄存器
```

```
页表的功能由一组专门的寄存器来实现，其始地址存放在页表基址寄存器（PTBR）中，另外还有一个界地址寄存器用于检测是否越界
```

✅21. 对重定位存储管理方式，应（ ）

```
A. 在整个系统中设置一个重定位寄存器
B. 为每道程序设置一个重定位寄存器
C. 为每道程序设置两个重定位寄存器
D. 为每道程序和数据都设置一个重定位寄存器
```

```
重定位寄存器：使地址转换不影响到指令的执行速度的硬件变换结构；
            可用于存放程序在内存中的始地址；

在执行程序或访问数据时，真正访问的内存地址由相对地址与重定位寄存器中的地址相加而成，
此时将始地址存入重定位寄存器，之后的地址访问即可通过硬件变换实现。

因为系统处理器在同一时刻只能执行一条指令或访问数据，所以每道程序/数据设置一个寄存器没有必要且不现实，
而切换程序执行时重置寄存器内容即可
```

✅22. 采用段式存储管理时，一个程序如何分段是在（ ）时决定的

```
A. 分配主存
B. 用户编程
C. 装作业
D. 程序执行
```

```
分段是指在用户编程时，将程序按照逻辑划分为几个逻辑段
```

✅25. 可重入程序时通过（ ）方法来改善系统性能的

```
A. 改变时间片长度
B. 改变用户量
C. 提高对换速度
D. 减少对换数量
```

```
可重入程序主要是通过共享来使用同一块存储空间，或通过动态链接的方式将所需的程序段映射到相关进程中去，
最大优点是减少了对程序段的调入/调出，因此减少了对换数量
```

✅26. 操作系统实现（ ）存储管理时的代价最小

```
A. 分区
B. 分页
C. 分段
D. 段叶式
```

```
实现分页、分段和段页式存储需要特定的数据结构支持（分页：页表；分段：段表）为了提高性能，还需要硬件提供快存（快表、内存等）和地址加法器等，代价高（硬件开销大）；

分区存储管理是满足多道程序设计的最简单的存储管理方案，特别适合嵌入式等微型设备。
```

✅29. 下列关于虚拟存储器的论述中，正确的是（ ）

```
A. 作业在运行前，必须全部装入内存，且在运行过程中也一直驻留内存
B. 作业在运行前，不必全部装入内存，且在运行过程中也不必一直驻留内存
C. 作业在运行前，不必全部装入内存，但在运行过程中必须一直驻留内存
D. 作业在运行前，必须全部装入内存，但在运行过程中不必一直驻留内存
```

```
在非农虚拟存储器中，作业必须全部装入内存，切在运行过程中也一直驻留内存；

而对于虚拟内存而言，具有三个性质：多次性、对换性、虚拟性，
多次性：作业运行前，不必全部装入内存；
对换性：运行过程中仅在需要的时候使用对换技术将其调入内存中；
```

✅31. 某个操作系统对内存的管理采用页式存储管理方法，所划分的页面大小（ ）

```
A. 要根据内存大小确定
B. 必须相同
C. 要根据 CPU 的地址结构确定
D. 要依据外存和内存的大小确定
```

```
页式管理中很重要的一个问题是页面大小如何确定。
确定页面大小有很多因素，如进程的平均大小、页表占用的长度等。

一旦确定，所有的页面就是等长的，以便于系统管理（通常为 2 的整数幂倍）
```

✅34. 对主存储器的访问，（ ）

```
A. 以块（即页）或段为单位
B. 以字节或字为单位
C. 随存储器的管理方案不同而异
D. 以用户的逻辑记录为单位
```

```
对于主存的访问 != 对主存的分配

对主存的访问以字节或字为单位。
如：页式管理中，不仅要知道块号，还需要知道页内偏移量
```

❓39. 在段页式分配中，CPU 每次从内存中取一次数据需要（ ）次访问内存

```
A. 1
B. 3
C. 2
D. 4
```

```
在段页式分配中，取一次数据时先从内存查找段表，在访问内存查找相应的页表，最后拼成物理地址后访问内存，共需要 3 次访存
（页式分配：2 次）
```

🌟41. 操作系统采用分页存储管理方式，要求（ ）

```
A. 每个进程拥有一张页表，且进程的页表驻留在内存中
B. 每个进程拥有一张页表，但只有执行进程的页表驻留在内存中
C. 所有进程共享一张页表，以节约有限的内存空间，但页表必须驻留在内存中
D. 所有进程共享一张页表，只有页表中当前使用的页面必须驻留在内存中，以最大限度地节省有限的内存空间
```

```
在多个进程并发执行时，所有进程的页表大多数驻留在内存中，在系统中之设置一个页表寄存器（PTR），存放页表在内存中的始地址和长度（实际就是基址寄存器和界地址寄存器）；

一般情况下，当进程未执行时，页表的始地址和页表长度存放在本进程的 PCB 中，当调度到某进程时，才将这两个数据装入页表寄存器中。

每个进程都有一个单独的逻辑地址，有一张属于自己的页表
```

❓44. 以下存储管理方式中，会产生内部碎片的是（ ）

```
I.   分段虚拟存储管理
II.  分页虚拟存储管理
III. 段页式分区管理
IV.  固定式分区管理

A. I,II,III
B. III,IV
C. II
D. II,III,IV
```

```
页式分区管理，包括基本分页式以及请求分页式以及段页式，因为含有页式分区，因此不可避免会产生内部碎片，但是极小，大约会产生半个物理块的大小内部碎片；

```

🌟45. 下列关于页式存储的论述中，正确的是（ ）

```
I.   在页式存储管理中，若关闭 TLB，则每当访问一条指令或存取一个操作数时都要访问 2 次内存
II.  页式存储管理不会产生内部碎片
III. 页式存储管理中的页面是为用户所感知的
IV.  页式存储方式可以采用静态重定位

A. I,II,IV
B. I,IV
C. I
D. 全部正确
```

```
I.   => 关闭 TLB 后，每当访问一条指令或存取一个操作数时，都要先访问页表（即访存），得到物理地址（页号+页内偏移量）后，在访问一次内存进行相应操作
II.  => 凡是分区固定的都方式都会产生内部碎片，但无外部碎片
III. => 页式存储管理对用户来说是透明的
IV.  => 静态重定位在程序运行之前由装配程序（装入程序）完成，必须分配器要求的全部连续内存空间；而页式存储管理方案，是将程序离散地分成若干页/块，从而可以将程序装入不连续的内存空间，显然静态重定位不能满足其要求
```

✅47. 「2009真题」一个分段存储管理系统中，地址长度为 32 位，其中段号占 8 位，则最大段长是（ ）

```
A. 2^8 B
B. 2^16 B
C. 2^24 B
D. 2^32 B
```

```
分段存储管理的逻辑地址分为段号和位移量两部分，段内位移的最大值就是最大段长。

地址长度为 32 位，段号占 8 位，因此位移量占 32-8=24 位，因此最大段长为 2^24 B
```

❓49. 「2010真题」某计算机采用二级页表的分页存储管理方式，按字节编址，页大小为 2^10 B，页表项大小为 2B，逻辑地址结构为

| 页目录号 | 页号 | 页内偏移量 |
| --- | --- | --- |

逻辑地址空间大小为 2^16 页，则表示整个逻辑地址空间的页目录表中包含表项的个数至少是（ ）

```
A. 64
B. 128
C. 256
D. 512
```

```
页大小为 2^10 B，页表项大小为 2B，因此 1 页可存放 2^9 个页表项；
逻辑地址空间大小为 2^16 页，即共需 2^16 个页表项；
因此需要 2^16/2^9=2^7=128 个页面保存页表项，即页目录表中包含表项的个数至少是 128 
```

❓50. 「2011真题」在虚拟内存管理中，地址变换机构将逻辑地址变换为物理地址，形成该逻辑地址的阶段是（ ）

```
A. 编辑
B. 编译
C. 链接
D. 装载
```

```
在虚拟内存管理中，地址变换机构将逻辑地址变换为物理地址，形成该逻辑地址的阶段是链接。编译过后的程序需要经过链接才能装在，而链接后形成的目标程序中的地址就是逻辑地址。
```

✅51. 「2014真题」现有一个容量为 10GB 的磁盘分区，磁盘空间以簇为单位进行分配，簇的大小是 4KB，若采用位图法管理该分区的空闲空间，即用一位标识一个簇是否被分配，则存放该位图所需的簇为（ ）个

```
A. 80
B. 320
C. 80K
D. 320K
```

```
簇的总数为 10GB/4KB = 2.5M，
用一位标识一簇是否被分配，整个磁盘共需要 2.5Mb => 2.5M/8=320KB
320KB/4KB=80簇
```

✅58. 「2021真题」在采用二级页表的分页系统中，CPU 页表基址寄存器中的内容是（ ）

```
A. 当前进程的一级页表的起始虚拟地址
B. 当前进程的一级页表的起始物理地址
C. 当前进程的二级页表的起始虚拟地址
D. 当前进程的二级页表的起始物理地址
```

```
在多级页表中，页表基址寄存器存放的是顶级页表的起始物理地址，即一级页表的起始物理地址
```

 [返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#318)

## 3.2.10 Virtual Memory | 虚拟内存
✅01. 请求分页存储管理中，若把页面尺寸增大一倍而且可容纳的最大页数不变，则在程序顺序执行时却也中断次数会（ ）

```
A. 增加
B. 减少
C. 不变
D. 可能增加也可能减少
```

```
若请求分页存储器中，由于页面尺寸增大，存放程序需要的页帧数就会减少，因此缺页中断次数也会减少
```

❓08. 考虑页面置换算法，系统有 m 个物理块供调度，初始时全空，页面引用串长度为 p，包含了 n 个不同的页号，无论用什么算法，却也次数不会少于（ ）

```
A. m
B. p
C. n
D. min(m,n)
```

```
无论采用何种页面置换算法，每种页面第一次访问时不可能在内存中，因此第一次必然发生缺页，所以缺页次数大于 n
```

🌟13. 导致 LRU 算法实现起来耗费高的原因（ ）

```
A. 需要硬件的特殊支持
B. 需要特殊的中断处理程序
C. 需要在页表中标明特殊的页类型
D. 需要对所有的页进行排序
```

```
易错选为 A

探究 LRU 算法的本质：
LRU 算法需要对所有页最近一次被访问的时间进行记录，查找时间最久的进行替换，会涉及到排序算法，这对于置换算法而言，开销过大；
因此在页表项中增加 LRU 位。

因此 A 可视作是开销高的结果，而不是原因
```

✅14. 在虚拟存储器系统的页表项中，决定是否会发生页故障的是（ ）

```
A. 合法位
B. 修改位
C. 页类型
D. 保护码
```

```
页表项中的合法位信息显示本页面是否在内存中，即决定了是否会发生页面故障
```

✅15. 在页面置换策略中，（ ）策略可能引起抖动

```
A. FIFO
B. LRU
C. 没有一种
D. 所有
```

```
都懂是进程的页面置换过程，频繁的页面调度（缺页中断）行为，所有的页面调度策略都不可能完全避免抖动
```

✅17. 使用（ ）方法可以实现虚拟存储

```
A. 分区合并
B. 覆盖，交换
C. 快表
D. 段合并
```

```
虚拟存储扩充内存的基本方法是将一些页或段从内存中调入、调出。而调入、调出的基本手段是覆盖与交换
```

✅18. 请求分页存储管理的主要特点是（ ）

```
A. 消除了页内零头
B. 扩充了内存
C. 便于动态链接
D. 便于信息共享
```

```
请求分页存储管理就是为了解决内存容量不足而使用的方法，它基于局部性原理实现了以时间换取空间的目的。

主要特点是间接扩充了内存。
```

✅20. 产生内存都懂的主要原因是（ ）

```
A. 内存空间太小
B. CPU 运行速度太慢
C. CPU 调度算法不合理
D. 页面置换算法不合理
```

```
内存抖动是指频繁地引起主存页面淘汰后又立即调入，调入后又很快淘汰的现象。

这是由于页面置换算法不合理引起的（但同时又是不可避免的，因此当前技术下，人们无法预估下一个页面会是哪一项）
```

🌟26. 已知系统为 32 位实地址，采用 48 位虚拟地址，页面大小为 4KB，页表项大小为 8B。假设系统使用纯页式存储，则要采用（ ）级页表，页内偏移（ ）位

```
A. 3,12
B. 3,14
C. 4,12
D. 4,14
```

```
页面大小为 4KB = 2^12 B，因此页内偏移为 12 位；
系统采用 48 位虚拟地址，因此虚页号 48-12=36 位。

采用多级页表时，最高级页表项不能超过一页；
每页能容纳的页表项数为 4KB/8B = 512 = 2^9, 36/9 = 4；
```

✅28. 测得某个采用按需调页策略的计算机系统的部分状态数据为：CPU 利用率为 20%，用于交换空间的磁盘利用率为 97.7%，其他设备的利用率为 5%。由此判断系统出现异常，这种情况下（ ）能提高系统性能

```
A. 安装一个更快的硬盘
B. 通过扩大硬盘容量增加交换空间
C. 增加运行进程数
D. 加内存条来增加物理空间容量
```

```
用于交换空间的磁盘利用率高达 97.7%，其他设备利用率 5%，CPU 利用率 20%，
说明在任务作业不多的情况下交换操作非常频繁，因此判断物理内存严重短缺

建议和下一题一起记忆相关知识点
```

🌟29. 假定有一个请求分页存储管理系统，测得系统各相关设备的利用率为：CPU 的利用率为 10%，磁盘交换区的利用率为 99.7%，其他 I/O 设备的利用率为 5%。下面（ ）措施将可能改进 CPU 的利用率

```
I.   增大内存的容量
II.  增大磁盘交换区的容量
III. 减少多道程序的度数
IV.  增加多道程序的度数
V.   使用更快速的磁盘交换区
VI.  使用更快速的 CPU

A. I,II,III,IV
B. I,III
C. II,III,V
D. II,IV
```

```
I.   => 增大内存容量可以使每个程序得到更多的页框，减少缺页率，进而减少换入/换出过程，提高 CPU 利用率
II.  => 当前情况是系统处于频繁的换入/换出过程中，而不是因为磁盘交换区的容量不够
III. => 减少多道程序的度数可以减少主存中的程序，进而提高 CPU 的利用率
IV.  => 增大多道程序的度数即增加用户进程数，这会导致系统换入/换出的频率更高，使性能更差
V.   => 使用更快速的磁盘交换区并不能加快系统的换出/换入频率
VI.  => CPU 当前利用率不高，意味着 CPU 性能并不是瓶颈，因此此时提高 CPU 频率无法提高其利用率
```

✅31. 「2011真题」当系统发生抖动时，可以采取的有效措施是（ ）

```
I.   撤销部分进程
II.  增加磁盘交换区的容量
III. 提高用户进程的优先级

A. I
B. II
C. III
D. I,II
```

```
在具有对换功能的操作系统中，通常把外存分为文件区和对换区。
前者用于存放文件，后者用于存放从内存换出的进程。

撤销部分进程可以减少所要用到的页面数，防止抖动；

对换区大小和进程优先级都与抖动无关
```

✅34. 「2014真题」下列措施中，能加快虚实地址转换的是（ ）

```
I.   增大快表（TLB）容量
II.  让页表常驻内存
III. 增大交换区（swap）

A. I
B. II
C. I,II
D. II,III
```

```
虚实地址转换是指逻辑地址和物理地址的转换。

增大快表容量能把更多的表项装入快表，会加快虚实地址转换的平均速率；
让页表常驻内存可以省去一些不在内存中的页表从磁盘上调入的过程，也能加快虚实地址转换；
增大交换区对虚实地址转换速度无影响
```

❓42. 「2021真题」某请求分页存储系统的大小为 4KB，按字节编址，系统给进程 P 分配 2 个固定的页框，并采用改进型 CLOCK 置换算法，进程 P 页表的部分内容见下表

| 页号 | 页框号 | 存在位 1:存在；0:不存在 | 访问位 1:访问；0:未访问 | 修改位 1:修改；0:未修改 |
| --- | --- | --- | --- | --- |
| ... | ... | ... | ... | ... |
| 2 | 20H | 0 | 0 | 0 |
| 3 | 60H | 1 | 1 | 0 |
| 4 | 80H | 1 | 1 | 1 |
| ... | ... | ... | ... | ... |

若 P 访问虚拟地址为 02A01H 的存储单元，则经地址变换后得到的物理地址是（ ）

```
A. 00A01H
B. 20A01H
C. 60A01H
D. 80A01H
```

```
页面大小为 4KB，低 12 位是页内偏移。

虚拟地址为 02A01H，则页号为 02H，对应的页表项存在位为 0；
进程 P 分配的页框固定为 2，且内存中已有两个页面存在。

根据 CLOCK 算法，选择将 3 号页换出，将 2 号页放入 60H 页框，经过地址变换后得到的物理地址是 60A01H
```

✅43. 「2021真题」下列选项中，通过系统调用完成的操作是（ ）

```
A. 页置换
B. 进程调度
C. 创建新进程
D. 生成随机整数
```

```
系统调用是由用户发起的（第一章），请求操作系统的服务。

A => 内存中的空闲框不够时，操作系统会将某些页面调出，并将要访问的页面调入，该过程完全由操作系统完成，不涉及系统调用
B => 进程调度完全由操作系统完成，无须用户提交系统调用请求 
C => 创建新进程可由系统调用完成，如 Linux 中通过 fork 系统调用来创建子进程
D => 生成随机数不涉及系统调用层面，用户程序层面即可完成，如 C 语言的 random() 函数
```

 [返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#3210)

# Chapter 4: File Management
## 4.1.8 File Management | 文件管理
01. UNIX 操作系统中，输入/输出设备视为（ ）

```
A. 普通文件
B. 目录文件
C. 索引文件
D. 特殊文件
```

03. 打开文件操作的主要工作是（ ）

```
A. 把指定文件的目录复制到内存指定的区域
B. 把指定文件复制到内存指定的区域
C. 在指定文件所在的存储介质上找到指定文件的目录
D. 在内存寻找指定的文件
```

04. 目录文件存放的信息是（ ）

```
A. 某一文件存放的数据信息
B. 某一文件的文件目录
C. 该目录中所有数据文件目录
D. 该目录中所有自目录文件和数据文件的目录
```

05. FAT32 的文件目录项不包括（ ）

```
A. 文件名
B. 文件访问权限
C. 文件控制块的物理位置
D. 文件所在的物理位置
```

06. 有些操作系统中将文件描述信息从目录项中分离出来，这样做的好处是（ ）

```
A. 减少读文件时的 I/O 信息量
B. 减少写文件时的 I/O 信息量
C. 减少查找文件时的 I/O 信息量
D. 减少复制文件时的 I/O 信息量
```

10. 加密保护和访问控制两种机制相比（ ）

```
A. 加密保护机制的灵活性更好
B. 访问控制机制的安全性更高
C. 加密保护机制必须由系统实现
D. 访问控制机制必须由系统实现
```

22. 文件系统采用两级索引分配方式。若每个磁盘块的大小为 1KB，每个盘块号占 4B，则该系统中，单个文件的最大长度是（ ）

```
A. 64MB
B. 128MB
C. 32MB
D. 以上均不正确
```

23. 设有一个记录文件，采用链接分配方式，逻辑记录的固定长度为 100B，在磁盘上存储是采用记录组成分解技术，盘块长度为 512B。若该文件的目录项已经读入内存，则对第 22 个逻辑记录完成修改后，共启动了磁盘（ ）次

```
A. 3
B. 4
C. 5
D. 6
```

26. 下面关于索引文件的叙述中，正确的是（ ）

```
A. 索引文件中，索引表的每个表项中含有相应记录的关键字和存放该记录的物理地址
B. 顺序文件进行检索时，首先从 FCB 中读出文件的第一个盘块号；而对索引文件进行检索时，应先从 FCB 中读出文件索引块的开始地址
C. 对于一个具有三级索引的文件，存取一条记录通常需要访问三次磁盘
D. 文件较大时，无论是进行顺序存取还是进行随机存取，通常索引文件方式都最快
```

29. 「2009真题」下列文件物理结构中，适合随机访问且易于文件扩展的是（ ）

```
A. 连续结构
B. 索引结构
C. 链式结构且磁盘块定长
D. 链式结构且磁盘块变长
```

30. 「2010真题」设文件索引结点中有 7 个地址项，其中 4 个地址项是直接地址索引，2 个地址项是一级间接地址索引，1 个地址项是二级间接地址索引，每个地址项大小为 4B，若磁盘索引块和磁盘数据块大小均为 256B，则可表示的单个文件最大长度是（ ）

```
A. 33KB
B. 519KB
C. 1057KB
D. 16516KB
```

31. 「2012真题」若一个用户进程通过 read 系统调用读取一个磁盘文件中的数据，则下列关于此过程的叙述中，正确的是（ ）

```
I.   若该文件的数据不在内存，则该进程进入睡眠等待状态
II.  请求 read 系统调用会导致 CPU 从用户态切换到核心态
III. read 系统调用的参数应包含文件的名称

A. I,II
B. I,III
C. II,III
D. I,II,III
```

34. 「2013真题」为支持 CD-ROM 中视频文件的快速随机播放，播放性能最好的文件数据块组织方式是9 ）

```
A. 连续结构
B. 链式结构
C. 直接索引结构
D. 多级索引结构
```

36. 「2015真题」在文件的索引节点中存放直接索引指针 10 个，一级和二级索引指针各 1 个。磁盘块大小为 1KB，每个索引指针占 4B。若某文件的索引节点已在内存中，则把该文件偏移量（按字节编址）为 1234 和 307400 处所在的磁盘块读入内存，需访问的磁盘个数分别是（ ）

```
A. 1,2
B. 1,3
C. 2,3
D. 2,4
```

35. 「2017真题」某文件系统中，针对每个文件，用户类别分为 4 类：安全管理员、文件主、文件主的伙伴、其他用户；访问权限分为 5 种：完全控制、执行、修改、读取、写入。若文件控制块中用二进制位串表示文件权限，为表示不同类别用户对一个文件的访问权限，则描述文件权限的位数至少应为（ ）

```
A. 5
B. 9
C. 12
D. 20
```

38. 「2018真题」下列优化方法中，可以提高文件访问速度的是（ ）

```
I.   提前读
II.  为文件分配连续的簇
III. 延迟写
IV.  采用磁盘高速缓存

A. I,II 
B. II,III
C. I,III,IV
D. I,II,III,IV
```

39. 「2020真题」下列选项中，支持文件长度可变、随机访问的磁盘存储空间分配方式是（ ）

```
A. 索引分配
B. 链接分配
C. 连续分配
D. 动态分区分配
```

40. 「2020真题」某文件系统的目录项由文件名和索引结点号构成。若每个目录项长度为 64 字节，其中 4 字节存放索引结点号，60 字节存放文件名，文件名由小写英文字母构成，则该文件系统能创建的文件数量的上限为（ ）

```
A. 2^26
B. 2^32
C. 2^60
D. 2^64
```

 [返回标题行](https://github.com/AdorableLake/408_Questions/blob/main/Operating_System/Wangdao_Collection_Union.md#418)
