# Catalog | 目录
## [Data Structure](https://github.com/AdorableLake/408_Questions/blob/main/Second_Cycle_Review/Data_Structure.md#data-structure-1)
### [Chapter 1: Linear Table](https://github.com/AdorableLake/408_Questions/blob/main/Second_Cycle_Review/Data_Structure.md#ds1-linear-table)
### [Chapter 2: Stack, Queue, Number Sets](https://github.com/AdorableLake/408_Questions/blob/main/Second_Cycle_Review/Data_Structure.md#ds2-stack-queue-number-sets)
### [Chapter 3: Tree](https://github.com/AdorableLake/408_Questions/blob/main/Second_Cycle_Review/Data_Structure.md#ds3-tree)
### [Chapter 4: Graph](https://github.com/AdorableLake/408_Questions/blob/main/Second_Cycle_Review/Data_Structure.md#ds4-graph)
### [Chapter 5: Searching](https://github.com/AdorableLake/408_Questions/blob/main/Second_Cycle_Review/Data_Structure.md#ds5-searching)
### [Chapter 6: Sorting](https://github.com/AdorableLake/408_Questions/blob/main/Second_Cycle_Review/Data_Structure.md#ds6-sorting)

## [Computer Organization](url)
### [Chapter 1: ](url)
### [Chapter 2: ](url)
### [Chapter 3: ](url)
### [Chapter 4: ](url)
### [Chapter 5: ](url)
### [Chapter 6: ](url)

# Data Structure
## DS.1 Linear Table
### 单项选择题
✅02. 将两个有 n 个元素的有序表归并成一个有序表，其最少的比较次数为（ ）

```
A. n
B. 2n-1
C. 2n
D. n-1
```

```
本质考察归并排序算法。

最少的比较次数为表 1 的所有元素都比表 2 第一个元素小，因此只需比较 n 次。
```

✅06. 给定有 n 个元素的一位数组，建立一个有序单链表的最少时间复杂度是（ ）

```
A. O(1)
B. O(n)
C. O(n^2)
D. O(nlog2n)
```

```
建立链表实质是排序算法。

分成两种情况：
1. 先建立链表，然后依次插入元素。
该种算法使用插入排序，每插入一个元素就需要遍历链表一边去寻找插入位置，时间复杂度为 O(n^2).

2. 先排好序，然后建立链表。
数组排序的最少时间复杂度为 O(nlog2n)；（即快排算法）
建立链表则需要遍历一遍链表，因此时间复杂度为 O(n)；
采用加法原理，因此总体的时间复杂度为 O(nlog2n).
```

✅07. 在一个以 h 为头结点的单循环链表中，p 指针指向链尾的条件是（ ）

```
A. p->next->next=h
B. p->next=h
C. p->next=h->next
D. p->next=NULL
```

```
易错选为 A
注意题中是 “p 指针” 而非 p 结点，因此 p 指针若指向链尾，即说明 p 指针是链尾节点的指针域
```

✅10. 下列程序段的时间复杂度是（ ）

```C
void fun(int n) {
    int i = 0;
    int s = 0;
    while(s<n) {
        ++i;
        s = s+i; 
    }
}
```

```
A. O(n)
B. O(log2n)
C. O(nlog2n)
D. O(n^(1/2))
```

```
基本运算为 '++i' 和 's=s+i'。
每循环一次，i 增 1. 故 s=0+1+2+3+···+i=(i+1)*i/2。
故循环次数 k 满足 (1+k)*k/2 < n，因此时间复杂度为 O(n^(1/2))
```

### 综合应用题
01. 设有两个集合 A、B，设计生成集合 C = A N B 的算法。集合 A、B、C 均使用数组存储。
    1. 给出算法的基本设计思想
    2. 根据设计思想，采用 C 或 C++ 语言描述算法，关键之处给予注释
    3. 说明所设计算法的时间复杂度

```

```

02. 给定一个由 n（n>1）个不同整数组成的升序序列，同时包含负数和正数。设计一个在时间和空间两方面都尽可能高效的算法，求序列中绝对值最小的树，如序列 {-8, -3, -1, 4, 5} 中绝对值最小的数为 -1。
    1.  给出算法的基本设计思想
    2.  根据设计思想，采用 C 语言或 C++ 语言描述算法，关键之处给出解释
    3.  说明你所设计算法的时间复杂度和空间复杂度

```

```

03. 设有两个带头结点的有序单链表，一个为升序，另一个为降序。试编写程序，将这两个链表合并为一个有序链表。

```

```

04. 已知长度为 n（n>1）的单链表，表头指标为 L，结点结构由 data 和 next 两个域构成，其中 data 域为字符型。试设计一个在时间和空间两方面都尽可能高效的算法，判断该单链表是否中心对称（例如 xyx、xxyyxx 都是中心对称的），要求：
    1.  给出算法的基本设计思想
    2.  根据设计思想，采用 C 或 C++ 语言描述算法，关键之处给出注释
    3.  说明你所设计算法的时间复杂度和空间复杂度

```

```

05. 已知两个序列 A={a1, a2, a3, ..., an} 和 B={b1, b2, b3, ..., bn} 存放在两个单链表中，试设计一个算法，判断序列 B 是否为序列 A 的子序列。要求：
    1.  给出算法的基本设计思想
    2.  根据设计思想，采用 C 或 C++ 语言描述算法，关键之处给出注释
    3.  说明你所设计算法的时间复杂度

```

```

06. 设带头结点的双向循环链表的定义为
   
```
typedef int ElemType;
typedef struct DNode {              // 双向循环链表结点的结构定义
    ElemType data;                  // 结点数据
    struct DNode * lLink, *rLink;   // 结点前驱和后继指针
} DblNode;
typedef DblNode * DblList;          // 双向循环链表
```

试设计一个算法，改造一个带头结点的双向循环链表，所有结点的原有次序保存在各结点的右链域 rLink 中，并利用左链域 `lLink` 把所有结点按从小到大的顺序连接起来。

```

```

## DS.2 Stack, Queue, Number Sets
### 综合应用题
01. 假设用 I 表示进栈操作，O 表示出栈操作。若栈的初态和终态均为空，入栈和出栈的操作序列可表示为仅由 I 和 O 组成的序列，则称可以操作的序列为合法序列，否则称为非法序列。
    1.  试指出判别给定操作序列是否合法的一般规则。
    2.  两个不同的合法序列（具有相同元素的不同输入序列）能否得到相同的输出元素序列？如能得到，请举例说明

```

```

02. 借助栈实现带表头结点的单链表的逆置运算「可以直接使用 push(), pop() 等栈的基本操作」

```

```

03. 给定整数数组 `B[m+1][n+1]` 的数据在行、列方向上都按从小到大的顺序排列。试设计一个算法，在数组中找出值为 x 的元素 `B[i][j]` （假设存在），且要求比较的次数不超过 m+n。

```

```

[返回标题行](url)

## DS.3 Tree
### 单项选择题
07. 由 3 个结点可以构造出（ ）种不同形态的有向树和（ ）种不同形态的二叉树

```
A. 2, 5
B. 2, 4
C. 3, 5
D. 3, 4
```

```

```

11. 若二叉树采用二叉链表存储，要交换其所有分支结点左、右子树的位置，利用（ ）遍历最合适

```
A. 前序
B. 中序
C. 后序
D. 层次
```

```

```

12. 在一棵后序线索二叉树中，若指针 s 指向该线索二叉树中的某结点，则（ ）

```
A. s->rchild 指向的结点一定是 s 所指结点的直接后继结点
B. s->lchild 指向的结点一定是 s 所指结点的直接前驱结点
C. 从 s 所指结点出发的 rchild 链可能构成环
D. s 所指结点的 lchild 和 rchild 指针一定指向不同的结点
```

```

```

13. 在线索二叉树中，结点 p 没有左子树的充分必要条件是（ ）

```
A. p->lchild=NULL
B. p->ltag=1
C. p->ltag=1, p->lchild=NULL
D. 以上均不正确
```

```

```

14. 某二叉树中序序列为 {A,B,C,D,E,F,G}，后序序列为 {B,D,C,A,F,G,E} 该二叉树对应的森林包括（ ）棵树

```
A. 1
B. 2
C. 3
D. 4
```

```

```

### 综合应用题
01. 一棵有 n 个结点的满二叉树的高度为 h（根结点所在的层次为 1）则：
   1. 如何用高度表示结点总数 n ？如何用结点总数 n 表示高度 h？
   2. 若对该树的结点从 0 开始按中序遍历次序进行编号，则如何用高度 h 表示根结点的编号？如何用高度 h 表示根结点的做孩子结点编号和右孩子结点编号？

```

```

02. 已知一棵完全二叉树存放于一个一维数组 `T[n]` 中，`T[n]` 中存放的是个结点的值。试设计一个算法，从 `T[n]` 开始顺序读出各结点的值，建立该二叉树的二叉链表。

```

```

03. 该二叉树以二叉链表表示，实现下列函数，返回二叉树指定结点 p 在以 t 为根的子树中的层次。

```C
int level(BiTNode * t, BiTNode * p);
```

```

```

04. 设一棵二叉树以二叉链表 BiTree 表示，请编写一个递归算法，统计二叉树中度为 1 的结点个数

```

```

05. 对于一棵给定的二叉树，写出统计其结点个数的递归算法
    1.  给出算法的基本设计思想
    2.  根据设计思想，采用 C 或 C++ 语言描述算法，关键之处给出注释

```

```

06. 设用于通信的电文仅由 7 个字母 a,b,c,d,e,f,g 组成，字母在电文中出现的频率为 0.27、0.19、0.10、0.04、0.07、0.12、0.21，给出哈夫曼树的构造过程及 7 个字母的哈夫曼编码

```

```

[返回标题行](url)

## DS.4 Graph
### 单项选择题
04. 在一个有 n 个顶点和 e 条边的又想吐的邻接矩阵中，计算某个顶点 i 的出度所耗费的时间是（ ）

```
A. O(n)
B. O(e)
C. O(n+e)
D. O(n^2)
```

```

```

05. n 个顶点的强连通图的邻接矩阵中至少有（ ）个非零元素

```
A. n-1
B. n
C. 2n-2
D. 2n
```

```

```

10. 当各边上的权值（ ）时，BFS 算法可以用来解决单源最短路径问题

```
A. 都相等
B. 都互不相等
C. 不一定相等
D. 都大于 0
```

```

```

### 综合应用题
01. 设含有 n 个顶点的有向图用邻接表表示，图的顶点编号与数组的下标相同，表示为 0～n-1，试写一个算法求顶点 k 的入度

```

```

03. 下面是求无向连通图最小生成树的一种算法的伪代码

```
// 设图中的总顶点数为 n，总边数为 m
// 将图中所有的边按其权值从大到小排序为 (e1,e2,...,em)
i=1;
while(m>=n) {
    从图中删去 ei;(m=m-1)
    若图不再连通，则恢复 ei;(m=m+1)
    i=i+1;
}
```

试问该算法的思想是否正确，并说明原因

```

```

[返回标题行](url)

## DS.5 Searching
### 单项选择题
✅01. 有一个按元素值从小到大排好序的顺序表（长度大于 2），分别用顺序查找法和折半查找法查找与给定值相等的元素，比较次数分别是 s 和 b。在查找成功的情况下，s 和 b 的关系是（ ）

```
A. s=b
B. s>b
C. s<b
D. 不确定
```

```
因为未指明是否为平均性能。
如在有序表中查找最小元素，则顺序查找比折半查找更快，但折半查找的平均性能要优于顺序查找
```

✅04. 当对一个线性表 `R[60]` 进行索引顺序查找（分块查找）时，若共分成了 10 个子表，每个字表有 6 个表项。假定对索引表和数据子表都采用顺序查找，则查找每一个表项的平均查找长度为（ ）

```
A. 7
B. 8 
C. 9
D. 10
```

```
10 个子表需要 10 个索引项，每个子表有 6 个表项，则有：
ASL(索引顺序查找) = ASL(索引表) + ASL(子表) = (10+1)/2+(6+1)/2 = 9
```

✅05. 分别对大小均为 n 的有序表和无序表进行顺序查找，在等概率的情况下，当查找失败时，他们的平均查找长度：（ ）

```
A. 有序表大于无序表
B. 两者相等
C. 无序表大于有序表
D. 无法确定
```

```
无序表每次查找失败都会比较到表尾；
有序表每次查找失败只需比较到比所查关键字大的元素即可停止；
而查找成功时，有序表和无序表的平均查找长度一致
```

✅09. 在下列关于红黑树的说法中，正确的是（ ）

```
A. 红黑树是一种特殊的平衡二叉树
B. 若红黑树的所有结点都是黑色的，则它一定是一颗满二叉树
C. 红黑树的任何一个分支结点都有两个非空孩子结点
D. 红黑树的子树也一定是红黑树
```

```
红黑树是一种特殊的二叉排序树，并非平衡二叉树；
从根结点出发到所有叶结点的黑结点数是相同的，若所有结点都是黑色，则一定是满二叉树；
考虑到某个黑结点，可以有一个空叶结点孩子和非空红结点孩子；
红黑树中可能存在红结点，根结点为红结点的子树不是红黑树；
```

✅13. 在一棵高度为 h 的 B 树中插入一个新关键字时，为查找插入位置需读取（ ）个结点

```
A. h-1
B. h
C. h+1
D. h+2
```

```
为插入一个新关键字，必须从根结点开始逐层向下查找插入位置，一般插入在叶结点中；
因此需要从根结点到叶结点，读取 h 个结点
（红黑树的遍历类似于二叉树的层序遍历）
```

✅15. 在采用拉链法解决冲突时，在每一个散列地址所链接的同义词子表中，各个表项的（ ）相同

```
A. 关键字值
B. 元素值
C. 散列地址
D. 含义
```

```
在拉链法的每一个散列地址所链接的同义词子表中，各个表项的散列地址是相同的
```

🌟19. 下列关于哈希查找说法中，不正确的有（ ）个

```
I.   采用链地址法解决冲突时，查找一个元素的时间是相同的
II.  采用链地址法解决冲突时，若规定插入总是在链首，则插入任意一个元素的时间是相同的
III. 采用链地址法解决冲突易引起聚集现象
IV.  再散列法不易产生聚集
V.   散列查找中不需要任何关键字的比较

A. 2
B. 3
C. 4
D. 5
```

```
I.   使用链地址法处理冲突时，查找一个元素可能需要在链表中遍历，因此所需的时间不一样
III. 同义词发生冲突不等于聚集，而使用链地址法解决冲突时，将同义词放在同一个链表中，不会引起聚集现象；

V.   哈希查找的思想是，先计算 Hash 地址来进行查找，再比较关键字，确定是否查找成功，因此需要关键字的比较
```

### 综合应用题
01. 假定用一个带表头指针 head 且不带表头结点的循环链表来实现一个有序表。指针 current 指向当前查找成功的结点，下一次若给定值 key 大于 current->data，则可以从 current 开始查找；否则从 head 开始查找。编写一个函数实现这种查找。当查找成功时，函数返回 true，同时 current 保存被查找结点的地址，若查找不成功，则返回 false，current 置为表头 head

```C
bool Search(circLinkNode *head, circLinkNode * &current, dataType key) {
    circLinkNode *p, *q;                // 确定查找范围，用 p，q 两个指针表示
    if(key < current->data) {
        p = head;
        q = current;                    
    } else {
        p = current;
        q = head;
    }
    while(p != q && p->data < key) {    // 循链查找
        p = p->link;
    }
    if(p->data == key) {
        current = p;
        return true;                    // 找到，返回正确
    } else {
        current = head;
        return false;                   // 未找到，返回错误
    }
}
```

[返回标题行](url)

## DS.6 Sorting
### 单项选择题
🌟02. 当 n 个待排序元素的关键字都相等时，直接插入排序、冒泡排序、简单选择排序的关键字比较次数和元素移动次数分别为（ ）、（ ）、（ ）

```
A. n-1, 0
B. n(n-1)/2, n
C. n(n-1)/2, 0
D. O(n), O(n)
```

```
当所有待排序元素的关键字都相等时，可按初始序列已有序来进行分析（即有序表）。
1. 对于直接插入排序来说，其比较次数和移动次数受初始序列影响，因此此时每趟只需比较 1 次，重复 n-1 趟（前 n-1 个元素），比较次数为 n-1，移动次数为 0；-> A
2. 对于冒泡排序，其比较次数和移动次数也收序列初始状态影响，比较 1 趟，比较次数为 n-1，移动次数为 0；-> A
3. 对于简单选择排序，其比较次数不受初始序列状态影响，故需要比较 n-1 趟，且比较次数为 n(n-1)/2，但移动次数受初始序列状态影响，故移动次数为 0；-> C
```

🌟03. 对于快速排序算法，假设 n 个待排序元素的关键字都相等，则完成排序所需关键字比较次数为（ ），数据移动次数是（ ），递归工作栈所需活动记录个数是（ ）

```
A. n
B. 2(n-1)
C. n(n-1)/2
D. log2n
```

```
待排序元素的关键字都相等可视作初始序列有序，因此此时快速排序的效率最低。
因为需要依次比较：(n-1)+(n-2)+...+1=n(n-1)/2。
数据移动次数则为 2(n-1)，因为每趟基准元素需要移出和移回，共执行 n-1 趟。
而需要分配的递归工作栈的活动记录则为 n，因为每一次外部调用需要建立活动记录（共 n 个元素，每个元素都需要一次外部调用）
```

✅09. 对下列 4 种排序方法，在排序中关键字比较次数与记录初始排列状态无关的是（ ）

```
A. 直接插入排序
B. 折半插入排序
C. 快速排序
D. 冒泡排序
```

```
在排序过程中，折半插入排序通过对前面已排好序的子序列进行折半查找，已确定当前元素的插入位置，即使原始序列是有序的，所需的比较次数仍是相同的。
而其他三种方式，序列的初始状态均会影响排序过程中的比较次数
```

✅10. 在下列排序算法中，在待排序数据已有序时，花费时间反而最多的是（ ）

```
A. 冒泡排序
B. 希尔排序
C. 快速排序
D. 堆排序
```

```
快速排序在有序表中反而效率最低，因为在每一步递归的过程中出现划分子序列不对称的情况，时间复杂度是 O(n^2)
```

✅11. 序列 {8,9,10,4,5,6,20,1,2} 只能是（ ）两趟排序后的结果

```
A. 选择排序
B. 冒泡排序
C. 插入排序
D. 堆排序
```

```
在执行两趟选择排序后，结果应为 {1,2,...}；

在执行两趟冒泡排序后，（假设从前向后扫描）结果应为 {...,10,20}；

在执行两趟堆排序后：
若采用小根堆，则结果应为 {...,10,20}；
若采用大根堆，则结果应为 {...,2,1}；

在执行两趟插入排序后，待排序序列前 3 个关键码局部有序
```

✅12. 对一组数据 {84,47,25,15,21} 进行排序，数据的排序次序在排序的过程中的变化为：
    1.  {15,47,25,84,21}
    2.  {15,21,25,84,47}
    3.  {15,21,25,84,47}
    4.  {15,21,25,47,84}

则其采用的排序方法是（ ）

```
A. 选择排序
B. 冒泡排序
C. 二路归并排序
D. 插入排序
```

```
用的是小根堆，即堆排序算法，属于选择排序算法

选择排序的第 i 趟从 L[i...n] 中选择关键字最小的元素与 L(i) 交换，第 i 趟排序后前 i 个元素全局有序，各趟排序过程均满足这两个特征；

冒泡排序每一趟两两比较相邻元素，若为逆序则交换，第一步到第二步的变换不符合其特征；

二路归并排序将初始序列视为 n 个长度为 1 的子序列，然后持续两两归并，知道合并成一个长度为 n 的有序序列；

插入排序在第 i 趟排序后，原序列的前 i+1 元素局部有序，不合特征；
```

✅13. 下列排序算法中，（ ）不能保证每趟排序至少能将一个元素放到其最终的位置上

```
A. 快速排序
B. 希尔排序
C. 堆排序
D. 冒泡排序
```

```
希尔排序并不能保证每趟排序后确定某个元素位置，在下一次步长改变时，可能又会发生改变；
归并排序和插入排序同样不能保证每趟排序至少能将一个元素放到其最终的位置
```

✅14. 若对 29 个记录之进行三趟多路平衡归并，则选取的归并路数至少是（ ）

```
A. 2
B. 3
C. 4
D. 5
```

```
设归并路数为 n，有[29/n^3]=1，故 n>3
```

### 综合应用题
09. 编写一个算法，在基于单链表表示的待排序序列上进行简单选择排序

```C
/* 
算法思想：
1. 每趟在原始链表中摘下关键字最大的结点（几个关键字相等时为最前面的结点）；
2. 将其插入结果链表的最前端；
由于在原始链表中摘下的关键字越来越小，因此在结果链表前端插入的关键字也越来越小，最后形成的结果链表中的结点链表中将按关键字非递减的顺序有序链接。
*/

void selectSort(LinkedList& L) {
    LinkNode *h = L, *p, *q, *r, *s;
    L = NULL;
    while(h != NULL) {              // 持续扫描原链表
        p = s = h;
        q = r = NULL;               // 指针 s 和 q 记忆最大结点和前驱
        while(p != NULL) {          // 扫描原链表，寻找最大结点 s
            if(p->data > s->data) { 
                s = p;
                r = q;              // 找到更大的，记忆它
            }
            q = p;
            p = p->link;
        }
        if(s == h) {                
            h = h->link;            // 最大结点在原链表前端
        } else {                    
            r->link = s->link;      // 最大结点在原链表表内
            s->link = L;    
            L = s;                  // 结点 S 插入到结果链前端
        }
    }
}
```

[返回标题行](url)
